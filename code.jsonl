{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Total supply of NWayUtilityCoins in existence"}, {"role": "assistant", "content": "pub var totalSupply: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when the contract is created"}, {"role": "assistant", "content": "pub event TokensInitialized(initialSupply: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when the contract is created"}, {"role": "assistant", "content": "(initialSupply: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are withdrawn from a Vault"}, {"role": "assistant", "content": "pub event TokensWithdrawn(amount: UFix64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are withdrawn from a Vault"}, {"role": "assistant", "content": "(amount: UFix64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are deposited to a Vault"}, {"role": "assistant", "content": "pub event TokensDeposited(amount: UFix64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are deposited to a Vault"}, {"role": "assistant", "content": "(amount: UFix64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are minted"}, {"role": "assistant", "content": "pub event TokensMinted(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are minted"}, {"role": "assistant", "content": "(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed"}, {"role": "assistant", "content": "pub event TokensBurned(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed"}, {"role": "assistant", "content": "(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new minter resource is created"}, {"role": "assistant", "content": "pub event MinterCreated(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new minter resource is created"}, {"role": "assistant", "content": "(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "pub event BurnerCreated()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the `token Vault` is stored"}, {"role": "assistant", "content": "pub let VaultStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the `token Admin` is stored"}, {"role": "assistant", "content": "pub let AdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the public capability for the `token balance` is"}, {"role": "assistant", "content": "pub let TokenBalancePublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the public capability for the `token receiver` is"}, {"role": "assistant", "content": "pub let TokenReceiverPublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Vault\n\nEach user stores an instance of only the Vault in their storage\nThe functions in the Vault and governed by the pre and post conditions\nin FungibleToken when they are called.\nThe checks happen at runtime whenever a function is called.\n\nResources can only be created in the context of the contract that they\nare defined in, so there is no way for a malicious user to create Vaults\nout of thin air. A special Minter resource needs to be defined to mint\nnew tokens.\n"}, {"role": "assistant", "content": "pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {\n\n        // holds the balance of a users tokens\n        pub var balance: UFix64\n\n        // initialize the balance at resource creation time\n        init(balance: UFix64) {\n            self.balance = balance\n        }\n\n        // withdraw\n        //\n        // Function that takes an integer amount as an argument\n        // and withdraws that amount from the Vault.\n        // It creates a new temporary Vault that is used to hold\n        // the money that is being transferred. It returns the newly\n        // created Vault to the context that called so it can be deposited\n        // elsewhere.\n        //\n        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }\n\n        // deposit\n        //\n        // Function that takes a Vault object as an argument and adds\n        // its balance to the balance of the owners Vault.\n        // It is allowed to destroy the sent Vault because the Vault\n        // was a temporary holder of the tokens. The Vault's balance has\n        // been consumed and therefore can be destroyed.\n        pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }\n\n        destroy() {\n            NWayUtilityCoin.totalSupply = NWayUtilityCoin.totalSupply - self.balance\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: holds the balance of a users tokens"}, {"role": "assistant", "content": "pub var balance: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initialize the balance at resource creation time"}, {"role": "assistant", "content": "init(balance: UFix64) {\n            self.balance = balance\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw\n\nFunction that takes an integer amount as an argument\nand withdraws that amount from the Vault.\nIt creates a new temporary Vault that is used to hold\nthe money that is being transferred. It returns the newly\ncreated Vault to the context that called so it can be deposited\nelsewhere.\n"}, {"role": "assistant", "content": "pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit\n\nFunction that takes a Vault object as an argument and adds\nits balance to the balance of the owners Vault.\nIt is allowed to destroy the sent Vault because the Vault\nwas a temporary holder of the tokens. The Vault's balance has\nbeen consumed and therefore can be destroyed."}, {"role": "assistant", "content": "pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyVault\n\nFunction that creates a new Vault with a balance of zero\nand returns it to the calling context. A user must call this function\nand store the returned Vault in their storage in order to allow their\naccount to be able to receive deposits of this token type.\n"}, {"role": "assistant", "content": "pub fun createEmptyVault(): @FungibleToken.Vault {\n        return <-create Vault(balance: 0.0)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewMinter\n\nFunction that creates and returns a new minter resource\n"}, {"role": "assistant", "content": "pub fun createNewMinter(allowedAmount: UFix64): @Minter {\n            emit MinterCreated(allowedAmount: allowedAmount)\n            return <-create Minter(allowedAmount: allowedAmount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewBurner\n\nFunction that creates and returns a new burner resource\n"}, {"role": "assistant", "content": "pub fun createNewBurner(): @Burner {\n            emit BurnerCreated()\n            return <-create Burner()\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Minter\n\nResource object that token admin accounts can hold to mint new tokens.\n"}, {"role": "assistant", "content": "pub resource Minter {\n\n        // the amount of tokens that the minter is allowed to mint\n        pub var allowedAmount: UFix64\n\n        // mintTokens\n        //\n        // Function that mints new tokens, adds them to the total supply,\n        // and returns them to the calling context.\n        //\n        pub fun mintTokens(amount: UFix64): @NWayUtilityCoin.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            NWayUtilityCoin.totalSupply = NWayUtilityCoin.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }\n\n        init(allowedAmount: UFix64) {\n            self.allowedAmount = allowedAmount\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the amount of tokens that the minter is allowed to mint"}, {"role": "assistant", "content": "pub var allowedAmount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintTokens\n\nFunction that mints new tokens, adds them to the total supply,\nand returns them to the calling context.\n"}, {"role": "assistant", "content": "pub fun mintTokens(amount: UFix64): @NWayUtilityCoin.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            NWayUtilityCoin.totalSupply = NWayUtilityCoin.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Burner\n\nResource object that token admin accounts can hold to burn tokens.\n"}, {"role": "assistant", "content": "pub resource Burner {\n\n        // burnTokens\n        //\n        // Function that destroys a Vault instance, effectively burning the tokens.\n        //\n        // Note: the burned tokens are automatically subtracted from the\n        // total supply in the Vault destructor.\n        //\n        pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: burnTokens\n\nFunction that destroys a Vault instance, effectively burning the tokens.\n\nNote: the burned tokens are automatically subtracted from the\ntotal supply in the Vault destructor.\n"}, {"role": "assistant", "content": "pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Simple fee manager\n"}, {"role": "assistant", "content": "pub contract RaribleFee {\n\n    pub let commonFeeManagerStoragePath: StoragePath\n\n    pub event SellerFeeChanged(value: UFix64)\n    pub event BuyerFeeChanged(value: UFix64)\n\n    // Seller fee [0..1)\n    pub var sellerFee: UFix64\n\n    // BuyerFee fee [0..1)\n    pub var buyerFee: UFix64\n\n    pub resource Manager {\n        pub fun setSellerFee(_ fee: UFix64) {\n            RaribleFee.sellerFee = fee\n            emit SellerFeeChanged(value: RaribleFee.sellerFee)\n        }\n\n        pub fun setBuyerFee(_ fee: UFix64) {\n            RaribleFee.buyerFee = fee\n            emit BuyerFeeChanged(value: RaribleFee.buyerFee)\n        }\n    }\n\n    init() {\n        self.sellerFee = 0.025\n        emit SellerFeeChanged(value: RaribleFee.sellerFee)\n        self.buyerFee = 0.025\n        emit BuyerFeeChanged(value: RaribleFee.buyerFee)\n\n        self.commonFeeManagerStoragePath = /storage/commonFeeManager\n        self.account.save(<- create Manager(), to: self.commonFeeManagerStoragePath)\n    }\n\n    pub fun feeAddress(): Address {\n        return self.account.address\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Seller fee [0..1)"}, {"role": "assistant", "content": "pub var sellerFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BuyerFee fee [0..1)"}, {"role": "assistant", "content": "pub var buyerFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: RaribleNFT token contract\n"}, {"role": "assistant", "content": "pub contract RaribleNFT : NonFungibleToken, LicensedNFT {\n\n    pub var totalSupply: UInt64\n\n    pub var collectionPublicPath: PublicPath\n    pub var collectionStoragePath: StoragePath\n    pub var minterPublicPath: PublicPath\n    pub var minterStoragePath: StoragePath\n\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n\n    pub event Mint(id: UInt64, creator: Address, metadata: {String:String}, royalties: [LicensedNFT.Royalty])\n    pub event Destroy(id: UInt64)\n\n    pub struct Royalty {\n        pub let address: Address\n        pub let fee: UFix64\n\n        init(address: Address, fee: UFix64) {\n            self.address = address\n            self.fee = fee\n        }\n    }\n\n    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {\n        pub let id: UInt64\n        pub let creator: Address\n        access(self) let metadata: {String:String}\n        access(self) let royalties: [LicensedNFT.Royalty]\n\n        init(id: UInt64, creator: Address, metadata: {String:String}, royalties: [LicensedNFT.Royalty]) {\n            self.id = id\n            self.creator = creator\n            self.metadata = metadata\n            self.royalties = royalties\n        }\n\n        pub fun getViews(): [Type] {\n            return [Type<MetadataViews.Display>()]\n        }\n\n        pub fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: self.metadata[\"name\"] ?? \"\",\n                        description: self.metadata[\"description\"] ?? \"\",\n                        thumbnail: MetadataViews.HTTPFile(url: self.metadata[\"metaURI\"] ?? \"\"),\n                    )\n            }\n            return nil\n        }\n\n        pub fun getMetadata(): {String:String} {\n            return self.metadata\n        }\n\n        pub fun getRoyalties(): [LicensedNFT.Royalty] {\n            return self.royalties\n        }\n\n        destroy() {\n            emit Destroy(id: self.id)\n        }\n    }\n\n    pub resource interface CollectionPublic {\n        pub fun borrow(id: UInt64): &NFT?\n    }\n\n    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, LicensedNFT.CollectionPublic, CollectionPublic {\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"Missing NFT\")\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            return <- token\n        }\n\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @RaribleNFT.NFT\n            let id: UInt64 = token.id\n            let dummy <- self.ownedNFTs[id] <- token\n            destroy dummy\n            emit Deposit(id: id, to: self.owner?.address)\n        }\n\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {\n            let authRef = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            let ref = authRef as! &NFT\n            return ref as! &{MetadataViews.Resolver}\n        }\n\n        pub fun borrow(id: UInt64): &NFT? {\n            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            return ref as! &RaribleNFT.NFT\n        }\n\n        pub fun getMetadata(id: UInt64): {String:String} {\n            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            return (ref as! &RaribleNFT.NFT).getMetadata()\n        }\n\n        pub fun getRoyalties(id: UInt64): [LicensedNFT.Royalty] {\n            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            return (ref as! &LicensedNFT.NFT).getRoyalties()\n        }\n\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }\n\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    pub resource Minter {\n        pub fun mintTo(creator: Capability<&{NonFungibleToken.Receiver}>, metadata: {String:String}, royalties: [LicensedNFT.Royalty]): &NonFungibleToken.NFT {\n            let token <- create NFT(\n                id: RaribleNFT.totalSupply,\n                creator: creator.address,\n                metadata: metadata,\n                royalties: royalties\n            )\n            RaribleNFT.totalSupply = RaribleNFT.totalSupply + 1\n            let tokenRef = &token as &NonFungibleToken.NFT\n            emit Mint(id: token.id, creator: creator.address, metadata: metadata, royalties: royalties)\n            creator.borrow()!.deposit(token: <- token)\n            return tokenRef\n        }\n    }\n\n    pub fun minter(): Capability<&Minter> {\n        return self.account.getCapability<&Minter>(self.minterPublicPath)\n    }\n\n    init() {\n        self.totalSupply = 0\n        self.collectionPublicPath = /public/RaribleNFTCollection\n        self.collectionStoragePath = /storage/RaribleNFTCollection\n        self.minterPublicPath = /public/RaribleNFTMinter\n        self.minterStoragePath = /storage/RaribleNFTMinter\n\n        let minter <- create Minter()\n        self.account.save(<- minter, to: self.minterStoragePath)\n        self.account.link<&Minter>(self.minterPublicPath, target: self.minterStoragePath)\n\n        let collection <- self.createEmptyCollection()\n        self.account.save(<- collection, to: self.collectionStoragePath)\n        self.account.link<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(self.collectionPublicPath, target: self.collectionStoragePath)\n\n        emit ContractInitialized()\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: RaribleOrder\n\nWraps the NFTStorefront.createListting\n"}, {"role": "assistant", "content": "pub contract RaribleOrder {\n\n    pub let BUYER_FEE: String\n    pub let SELLER_FEE: String\n    pub let OTHER: String\n    pub let ROYALTY: String\n    pub let REWARD: String\n\n    init() {\n        // market buyer fee (on top of the price)\n        self.BUYER_FEE = \"BUYER_FEE\"\n\n        // market seller fee\n        self.SELLER_FEE = \"SELLER_FEE\"\n\n        // additional payments\n        self.OTHER = \"OTHER\"\n\n        // royalty\n        self.ROYALTY = \"ROYALTY\"\n\n        // seller reward\n        self.REWARD = \"REWARD\"\n    }\n\n    // PaymentPart\n    // \n    pub struct PaymentPart {\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        init(address: Address, rate: UFix64) {\n            self.address = address\n            self.rate = rate\n        }\n    }\n\n    // Payment\n    // Describes payment in the event OrderAvailable\n    // \n    pub struct Payment {\n        // type of payment\n        pub let type: String\n\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        // payment amount\n        pub let amount: UFix64\n\n        init(type: String, address: Address, rate: UFix64, amount: UFix64) {\n            self.type = type\n            self.address = address\n            self.rate = rate\n            self.amount = amount\n        }\n    }\n\n    // OrderAvailable\n    // Order created and available for purchase\n    // \n    pub event OrderAvailable(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64, // sum of payment parts\n        offerPrice: UFix64, // base for calculate rates\n        payments: [Payment]\n    )\n\n    pub event OrderClosed(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64,\n        buyerAddress: Address,\n        cuts: [PaymentPart]\n    )\n\n    pub event OrderCancelled(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64,\n        cuts: [PaymentPart]\n    )\n\n    // addOrder\n    // Wrapper for NFTStorefront.createListing\n    //\n    pub fun addOrder(\n        storefront: &NFTStorefront.Storefront,\n        nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftId: UInt64,\n        vaultPath: PublicPath,\n        vaultType: Type,\n        price: UFix64,\n        extraCuts: [PaymentPart],\n        royalties: [PaymentPart]\n    ): UInt64 {\n        let orderAddress = storefront.owner!.address\n        let payments: [Payment] = []\n        let saleCuts: [NFTStorefront.SaleCut] = []\n        var percentage = 1.0\n        var offerPrice = 0.0\n\n        let addPayment = fun (type: String, address: Address, rate: UFix64) {\n            assert(rate >= 0.0 && rate < 1.0, message: \"Rate must be in range [0..1)\")\n            let amount = price * rate\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(vaultPath)\n            assert(receiver.borrow() != nil, message: \"Missing or mis-typed fungible token receiver\")\n\n            payments.append(Payment(type:type, address:address, rate: rate, amount: amount))\n            saleCuts.append(NFTStorefront.SaleCut(receiver: receiver, amount: amount))\n\n            offerPrice = offerPrice + amount\n            percentage = percentage - (type == RaribleOrder.BUYER_FEE ? 0.0 : rate)\n            assert(rate >= 0.0 && rate < 1.0, message: \"Sum of payouts must be in range [0..1)\")\n        }\n\n        addPayment(RaribleOrder.BUYER_FEE, RaribleFee.feeAddress(), RaribleFee.buyerFee)\n        addPayment(RaribleOrder.SELLER_FEE, RaribleFee.feeAddress(), RaribleFee.sellerFee)\n\n        for cut in extraCuts {\n            addPayment(RaribleOrder.OTHER, cut.address, cut.rate)\n        }\n\n        for royalty in royalties {\n            addPayment(RaribleOrder.ROYALTY, royalty.address, royalty.rate)\n        }\n\n        addPayment(RaribleOrder.REWARD, orderAddress, percentage)\n\n        let orderId = storefront.createListing(\n            nftProviderCapability: nftProvider,\n            nftType: nftType,\n            nftID: nftId,\n            salePaymentVaultType: vaultType,\n            saleCuts: saleCuts\n        )\n\n        emit OrderAvailable(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: nftType.identifier,\n            nftId: nftId,\n            vaultType: vaultType.identifier,\n            price: price,\n            offerPrice: offerPrice,\n            payments: payments\n        )\n\n        return orderId\n    }\n\n    // closeOrder\n    // Purchase nft by o\n    //\n    pub fun closeOrder(\n        storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic},\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n        paymentVault: @FungibleToken.Vault,\n        buyerAddress: Address\n    ): @NonFungibleToken.NFT {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderClosed(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            buyerAddress: buyerAddress,\n            cuts: cuts\n        )\n\n        let item <- listing.purchase(payment: <-paymentVault)\n        storefront.cleanup(listingResourceID: orderId)\n        return <- item\n    }\n\n    // removeOrder\n    // Cancel sale, dismiss order\n    //\n    pub fun removeOrder(\n        storefront: &NFTStorefront.Storefront,\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n    ) {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderCancelled(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            cuts: cuts\n        )\n\n        storefront.removeListing(listingResourceID: orderId)\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: PaymentPart\n"}, {"role": "assistant", "content": "pub struct PaymentPart {\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        init(address: Address, rate: UFix64) {\n            self.address = address\n            self.rate = rate\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: receiver address"}, {"role": "assistant", "content": "pub let address: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: payment rate"}, {"role": "assistant", "content": "pub let rate: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Payment\nDescribes payment in the event OrderAvailable\n"}, {"role": "assistant", "content": "pub struct Payment {\n        // type of payment\n        pub let type: String\n\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        // payment amount\n        pub let amount: UFix64\n\n        init(type: String, address: Address, rate: UFix64, amount: UFix64) {\n            self.type = type\n            self.address = address\n            self.rate = rate\n            self.amount = amount\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: type of payment"}, {"role": "assistant", "content": "pub let type: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: payment amount"}, {"role": "assistant", "content": "pub let amount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OrderAvailable\nOrder created and available for purchase\n"}, {"role": "assistant", "content": "pub event OrderAvailable(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64, // sum of payment parts\n        offerPrice: UFix64, // base for calculate rates\n        payments: [Payment]\n    )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OrderAvailable\nOrder created and available for purchase\n"}, {"role": "assistant", "content": "(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64, // sum of payment parts\n        offerPrice: UFix64, // base for calculate rates\n        payments: [Payment]\n    )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: addOrder\nWrapper for NFTStorefront.createListing\n"}, {"role": "assistant", "content": "pub fun addOrder(\n        storefront: &NFTStorefront.Storefront,\n        nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftId: UInt64,\n        vaultPath: PublicPath,\n        vaultType: Type,\n        price: UFix64,\n        extraCuts: [PaymentPart],\n        royalties: [PaymentPart]\n    ): UInt64 {\n        let orderAddress = storefront.owner!.address\n        let payments: [Payment] = []\n        let saleCuts: [NFTStorefront.SaleCut] = []\n        var percentage = 1.0\n        var offerPrice = 0.0\n\n        let addPayment = fun (type: String, address: Address, rate: UFix64) {\n            assert(rate >= 0.0 && rate < 1.0, message: \"Rate must be in range [0..1)\")\n            let amount = price * rate\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(vaultPath)\n            assert(receiver.borrow() != nil, message: \"Missing or mis-typed fungible token receiver\")\n\n            payments.append(Payment(type:type, address:address, rate: rate, amount: amount))\n            saleCuts.append(NFTStorefront.SaleCut(receiver: receiver, amount: amount))\n\n            offerPrice = offerPrice + amount\n            percentage = percentage - (type == RaribleOrder.BUYER_FEE ? 0.0 : rate)\n            assert(rate >= 0.0 && rate < 1.0, message: \"Sum of payouts must be in range [0..1)\")\n        }\n\n        addPayment(RaribleOrder.BUYER_FEE, RaribleFee.feeAddress(), RaribleFee.buyerFee)\n        addPayment(RaribleOrder.SELLER_FEE, RaribleFee.feeAddress(), RaribleFee.sellerFee)\n\n        for cut in extraCuts {\n            addPayment(RaribleOrder.OTHER, cut.address, cut.rate)\n        }\n\n        for royalty in royalties {\n            addPayment(RaribleOrder.ROYALTY, royalty.address, royalty.rate)\n        }\n\n        addPayment(RaribleOrder.REWARD, orderAddress, percentage)\n\n        let orderId = storefront.createListing(\n            nftProviderCapability: nftProvider,\n            nftType: nftType,\n            nftID: nftId,\n            salePaymentVaultType: vaultType,\n            saleCuts: saleCuts\n        )\n\n        emit OrderAvailable(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: nftType.identifier,\n            nftId: nftId,\n            vaultType: vaultType.identifier,\n            price: price,\n            offerPrice: offerPrice,\n            payments: payments\n        )\n\n        return orderId\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: closeOrder\nPurchase nft by o\n"}, {"role": "assistant", "content": "pub fun closeOrder(\n        storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic},\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n        paymentVault: @FungibleToken.Vault,\n        buyerAddress: Address\n    ): @NonFungibleToken.NFT {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderClosed(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            buyerAddress: buyerAddress,\n            cuts: cuts\n        )\n\n        let item <- listing.purchase(payment: <-paymentVault)\n        storefront.cleanup(listingResourceID: orderId)\n        return <- item\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: removeOrder\nCancel sale, dismiss order\n"}, {"role": "assistant", "content": "pub fun removeOrder(\n        storefront: &NFTStorefront.Storefront,\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n    ) {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderCancelled(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            cuts: cuts\n        )\n\n        storefront.removeListing(listingResourceID: orderId)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Data struct signed by account with specified \"adminPublicKey.\"\n\nPermits accounts to purchase specific NFTs for some period of time."}, {"role": "assistant", "content": "pub struct AdminSignedData {\n        pub let externalID: String\n        pub let priceType: String\n        pub let primarySaleAddress: Address\n        pub let purchaserAddress: Address\n        pub let assetIDs: [UInt64]\n        pub let expiration: UInt64 // unix timestamp\n\n        init(externalID: String, primarySaleAddress: Address, purchaserAddress: Address, assetIDs: [UInt64], priceType: String, expiration: UInt64){\n            self.externalID = externalID\n            self.primarySaleAddress = primarySaleAddress\n            self.purchaserAddress = purchaserAddress\n            self.assetIDs = assetIDs\n            self.priceType = priceType\n            self.expiration = expiration\n        }\n\n        pub fun toString(): String {\n            var assetIDs = \"\"\n            var i = 0\n            while (i < self.assetIDs.length) {\n                if (i > 0) {\n                    assetIDs = assetIDs.concat(\",\")\n                }\n                assetIDs = assetIDs.concat(self.assetIDs[i].toString())\n                i = i + 1\n            }\n            return self.externalID.concat(\":\")\n                .concat(self.primarySaleAddress.toString()).concat(\":\")\n                .concat(self.purchaserAddress.toString()).concat(\":\")\n                .concat(assetIDs).concat(\":\")\n                .concat(self.priceType).concat(\":\")\n                .concat(self.expiration.toString())\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: primary sale metadata"}, {"role": "assistant", "content": "access(self) var details: PrimarySaleDetails"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: pub key used to verify signatures from a specified admin"}, {"role": "assistant", "content": "access(self) var adminPublicKey: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are teleported in from Ethereum (from: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "pub event TokensTeleportedIn(amount: UFix64, from: [UInt8], hash: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are teleported in from Ethereum (from: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "(amount: UFix64, from: [UInt8], hash: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed and teleported to Ethereum (to: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "pub event TokensTeleportedOut(amount: UFix64, to: [UInt8])"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed and teleported to Ethereum (to: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "(amount: UFix64, to: [UInt8])"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when teleport fee is collected (type 0: out, 1: in)"}, {"role": "assistant", "content": "pub event FeeCollected(amount: UFix64, type: UInt8)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when teleport fee is collected (type 0: out, 1: in)"}, {"role": "assistant", "content": "(amount: UFix64, type: UInt8)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "pub event TeleportAdminCreated(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The storage path for the admin resource (equivalent to root)"}, {"role": "assistant", "content": "pub let AdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The storage path for the teleport-admin resource (less priviledged than admin)"}, {"role": "assistant", "content": "pub let TeleportAdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The private path for the teleport-admin resource"}, {"role": "assistant", "content": "pub let TeleportAdminPrivatePath: PrivatePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The public path for the teleport user"}, {"role": "assistant", "content": "pub let TeleportUserPublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Frozen flag controlled by Admin"}, {"role": "assistant", "content": "pub var isFrozen: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Record teleported Ethereum hashes"}, {"role": "assistant", "content": "access(contract) var teleported: {String: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Controls REVV vault"}, {"role": "assistant", "content": "access(contract) let revvVault: @REVV.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initialize the balance at resource creation time"}, {"role": "assistant", "content": "init(balance: UFix64) {\n      self.balance = balance\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewTeleportAdmin\n\nFunction that creates and returns a new teleport admin resource\n"}, {"role": "assistant", "content": "pub fun createNewTeleportAdmin(allowedAmount: UFix64): @TeleportAdmin {\n      emit TeleportAdminCreated(allowedAmount: allowedAmount)\n      return <- create TeleportAdmin(allowedAmount: allowedAmount)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit\n\nFunction that deposits REVV token into the contract controlled\nvault.\n"}, {"role": "assistant", "content": "pub fun depositRevv(from: @REVV.Vault) {\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      vaultRef.deposit(from: <- from)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: fee collected when token is teleported from Ethereum to Flow"}, {"role": "assistant", "content": "pub var inwardFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: fee collected when token is teleported from Flow to Ethereum"}, {"role": "assistant", "content": "pub var outwardFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the amount of tokens that the admin is allowed to teleport"}, {"role": "assistant", "content": "pub var allowedAmount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: corresponding controller account on Ethereum"}, {"role": "assistant", "content": "pub var ethereumAdminAccount: [UInt8]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: TeleportAdmin resource\n\nResource object that has the capability to teleport tokens\nupon receiving teleport request from Ethereum side\n"}, {"role": "assistant", "content": "pub resource TeleportAdmin: TeleportUser, TeleportControl {\n    \n    // the amount of tokens that the admin is allowed to teleport\n    pub var allowedAmount: UFix64\n\n    // receiver reference to collect teleport fee\n    pub let feeCollector: @REVV.Vault\n\n    // fee collected when token is teleported from Ethereum to Flow\n    pub var inwardFee: UFix64\n\n    // fee collected when token is teleported from Flow to Ethereum\n    pub var outwardFee: UFix64\n\n    // corresponding controller account on Ethereum\n    pub var ethereumAdminAccount: [UInt8]\n\n    // teleportIn\n    //\n    // Function that release REVV tokens from custody,\n    // and returns them to the calling context.\n    //\n    pub fun teleportIn(amount: UFix64, from: [UInt8], hash: String): @FungibleToken.Vault {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        amount <= self.allowedAmount: \"Amount teleported must be less than the allowed amount\"\n        amount > self.inwardFee: \"Amount teleported must be greater than inward teleport fee\"\n        from.length == 20: \"Ethereum address should be 20 bytes\"\n        hash.length == 64: \"Ethereum tx hash should be 32 bytes\"\n        !(TeleportCustody.teleported[hash] ?? false): \"Same hash already teleported\"\n      }\n      self.allowedAmount = self.allowedAmount - amount\n\n      TeleportCustody.teleported[hash] = true\n      emit TokensTeleportedIn(amount: amount, from: from, hash: hash)\n\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      let vault <- vaultRef.withdraw(amount: amount)\n      let fee <- vault.withdraw(amount: self.inwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.inwardFee, type: 1)\n\n      return <- vault\n    }\n\n    // teleportOut\n    //\n    // Function that destroys a Vault instance, effectively burning the tokens.\n    //\n    // Note: the burned tokens are automatically subtracted from the \n    // total supply in the Vault destructor.\n    //\n    pub fun teleportOut(from: @REVV.Vault, to: [UInt8]) {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        to.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      let vault <- from as! @REVV.Vault\n      let fee <- vault.withdraw(amount: self.outwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.outwardFee, type: 0)\n\n      let amount = vault.balance\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      vaultRef.deposit(from: <- vault)\n      emit TokensTeleportedOut(amount: amount, to: to)\n    }\n\n    pub fun withdrawFee(amount: UFix64): @FungibleToken.Vault {\n      return <- self.feeCollector.withdraw(amount: amount)\n    }\n\n    pub fun updateInwardFee(fee: UFix64) {\n      self.inwardFee = fee\n    }\n\n    pub fun updateOutwardFee(fee: UFix64) {\n      self.outwardFee = fee\n    }\n\n    pub fun updateEthereumAdminAccount(account: [UInt8]) {\n      pre {\n        account.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      self.ethereumAdminAccount = account\n    }\n\n    pub fun getFeeAmount(): UFix64 {\n      return self.feeCollector.balance\n    }\n\n    pub fun depositAllowance(from: @Allowance) {\n      self.allowedAmount = self.allowedAmount + from.balance\n\n      destroy from\n    }\n\n    pub fun getEthereumAdminAccount(): [UInt8] {\n      return self.ethereumAdminAccount\n    }\n\n    init(allowedAmount: UFix64) {\n      self.allowedAmount = allowedAmount\n\n      self.feeCollector <- REVV.createEmptyVault() as! @REVV.Vault\n      self.inwardFee = 0.01\n      self.outwardFee = 10.0\n\n      self.ethereumAdminAccount = []\n    }\n\n    destroy() {\n      destroy self.feeCollector\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: receiver reference to collect teleport fee"}, {"role": "assistant", "content": "pub let feeCollector: @REVV.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: teleportIn\n\nFunction that release REVV tokens from custody,\nand returns them to the calling context.\n"}, {"role": "assistant", "content": "pub fun teleportIn(amount: UFix64, from: [UInt8], hash: String): @FungibleToken.Vault {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        amount <= self.allowedAmount: \"Amount teleported must be less than the allowed amount\"\n        amount > self.inwardFee: \"Amount teleported must be greater than inward teleport fee\"\n        from.length == 20: \"Ethereum address should be 20 bytes\"\n        hash.length == 64: \"Ethereum tx hash should be 32 bytes\"\n        !(TeleportCustody.teleported[hash] ?? false): \"Same hash already teleported\"\n      }\n      self.allowedAmount = self.allowedAmount - amount\n\n      TeleportCustody.teleported[hash] = true\n      emit TokensTeleportedIn(amount: amount, from: from, hash: hash)\n\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      let vault <- vaultRef.withdraw(amount: amount)\n      let fee <- vault.withdraw(amount: self.inwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.inwardFee, type: 1)\n\n      return <- vault\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: teleportOut\n\nFunction that destroys a Vault instance, effectively burning the tokens.\n\nNote: the burned tokens are automatically subtracted from the\ntotal supply in the Vault destructor.\n"}, {"role": "assistant", "content": "pub fun teleportOut(from: @REVV.Vault, to: [UInt8]) {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        to.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      let vault <- from as! @REVV.Vault\n      let fee <- vault.withdraw(amount: self.outwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.outwardFee, type: 0)\n\n      let amount = vault.balance\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      vaultRef.deposit(from: <- vault)\n      emit TokensTeleportedOut(amount: amount, to: to)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: DelayedTransfer must from same account as addXfer is limited to access(account) to avoid spam"}, {"role": "assistant", "content": "import DelayedTransfer from 0x08dd120226ec2213"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: user deposit into SafeBox, cBridge will mint corresponding ERC20 tokens on specified dest chain.\nwhen user burn ERC20 tokens, cBridge will withdraw FungibleTokens to user specified receiver address"}, {"role": "assistant", "content": "pub contract SafeBox {\n  // path for admin resource\n    pub let AdminPath: StoragePath\n  // ========== events ==========\n  pub event Deposited(\n    depoId: String,\n    depositor: Address,\n    token: String,\n    amount: UFix64,\n    mintChId: UInt64,\n    mintAddr: String,\n    nonce: UInt64\n  )\n\n  pub event Withdrawn(\n    wdId: String,\n    receiver: Address,\n    token: String,\n    amount: UFix64,\n    refChId: UInt64,\n    burnAddr: String,\n    refId: String\n  )\n\n  // ========== structs ==========\n  // token vault type identifier string to its config so we can borrow for deposit/withdraw\n  pub struct TokenCfg {\n    pub let vaultPub: PublicPath\n    pub let vaultSto: StoragePath\n    pub let minDepo: UFix64\n    pub let maxDepo: UFix64\n    // if withdraw amount > delayThreshold, put into delayed transfer map\n    pub let delayThreshold: UFix64\n    // used for volume controller\n    pub let cap: UFix64\n\n    init(vaultPub:PublicPath, vaultSto: StoragePath, minDepo: UFix64, maxDepo: UFix64, delayThreshold: UFix64, cap: UFix64) {\n      self.vaultPub = vaultPub\n      self.vaultSto = vaultSto\n      self.minDepo = minDepo\n      self.maxDepo = maxDepo\n      self.delayThreshold = delayThreshold\n      self.cap = cap\n    }\n  }\n  // info about one user deposit\n  pub struct DepoInfo {\n    pub let amt: UFix64\n    pub let mintChId: UInt64\n    pub let mintAddr: String\n    pub let nonce: UInt64\n\n    init(amt: UFix64, mintChId: UInt64, mintAddr: String, nonce: UInt64) {\n      self.amt = amt\n      self.mintChId = mintChId\n      self.mintAddr = mintAddr\n      self.nonce = nonce\n    }\n  }\n\n  // ========== contract states and maps ==========\n  // unique chainid required by cbridge system\n  pub let chainID: UInt64\n  // domainPrefix to ensure no replay on co-sign msgs\n  access(contract) let domainPrefix: [UInt8]\n  // similar to solidity pausable\n  pub var isPaused: Bool\n\n  // key is token vault identifier, eg. A.1122334455667788.ExampleToken.Vault\n  access(account) var tokMap: {String: TokenCfg}\n  // save for each deposit/withdraw to avoid duplicated process\n  // key is calculated depoId or wdId\n  access(account) var records: {String: Bool}\n\n  pub fun getTokenConfig(identifier: String): TokenCfg {\n    let tokenCfg = self.tokMap[identifier]!\n    return tokenCfg\n  }\n\n  pub fun recordExist(id: String): Bool {\n    return self.records.containsKey(id)\n  }\n\n  // ========== resource ==========\n  pub resource SafeBoxAdmin {\n    pub fun addTok(identifier: String, tok: TokenCfg) {\n      assert(!SafeBox.tokMap.containsKey(identifier), message: \"this token already exist\")\n      SafeBox.tokMap[identifier] = tok\n    }\n\n    pub fun rmTok(identifier: String) {\n      assert(SafeBox.tokMap.containsKey(identifier), message: \"this token do not exist\")\n      SafeBox.tokMap.remove(key: identifier)\n    }\n\n    pub fun pause() {\n      SafeBox.isPaused = true\n      DelayedTransfer.pause()\n    }\n    pub fun unPause() {\n      SafeBox.isPaused = false\n      DelayedTransfer.unPause()\n    }\n\n    pub fun createSafeBoxAdmin(): @SafeBoxAdmin {\n        return <-create SafeBoxAdmin()\n    }\n  }\n\n  // ========== functions ==========\n  // chainid must be same as cbridge common proto FLOW_MAINNET = 12340001; FLOW_TEST = 12340002;\n  init(chID:UInt64) {\n    self.chainID = chID\n    // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.SafeBox\".utf8, xxxx is this contract account\n    self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n    self.isPaused = false\n\n    self.records = {}\n    self.tokMap = {}\n\n    self.AdminPath = /storage/SafeBoxAdmin\n    self.account.save<@SafeBoxAdmin>(<- create SafeBoxAdmin(), to: self.AdminPath)\n  }\n\n  pub fun deposit(from: &AnyResource{FungibleToken.Provider}, info:DepoInfo) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    let user = from.owner!.address\n    let tokStr = from.getType().identifier\n    let tokenCfg = self.tokMap[tokStr]!\n    assert(info.amt >= tokenCfg.minDepo, message: \"deposit amount less than min deposit\")\n    if tokenCfg.maxDepo > 0.0 {\n      assert(info.amt < tokenCfg.maxDepo, message: \"deposit amount larger than max deposit\")\n    }\n    // calculate depoId\n    let concatStr = user.toString().concat(tokStr).concat(info.amt.toString()).concat(info.nonce.toString())\n    let depoId = String.encodeHex(HashAlgorithm.SHA3_256.hash(concatStr.utf8))\n    assert(!self.records.containsKey(depoId), message: \"depoId already exists\")\n    self.records[depoId] = true\n\n    let recev = self.account.getCapability(tokenCfg.vaultPub).borrow<&AnyResource{FungibleToken.Receiver}>()\n                      ?? panic(\"Could not borrow a reference to the receiver\")\n    recev.deposit(from: <-from.withdraw(amount: info.amt))\n    emit Deposited(\n      depoId: depoId,\n      depositor: user,\n      token: tokStr,\n      amount: info.amt,\n      mintChId: info.mintChId,\n      mintAddr: info.mintAddr,\n      nonce: info.nonce\n    )\n  }\n\n  // we can also use recipient: &AnyResource{FungibleToken.Receiver} to do deposit.\n  // but now, we use the tokCfg pubPath to get the Receiver first.\n  pub fun withdraw(token: String, wdmsg: [UInt8], sigs: [cBridge.SignerSig]) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    // calculate correct data by prefix domain, sgn needs to sign the same way\n    let domain = self.domainPrefix.concat(\"Withdraw\".utf8)\n    assert(cBridge.verify(data: domain.concat(wdmsg), sigs: sigs), message: \"verify sigs failed\")\n    let wdInfo = PbPegged.Withdraw(wdmsg)\n    assert(wdInfo.eqToken(tkStr: token), message: \"mismatch token string\")\n    // calculate wdId and check records map\n    // withdraw from self storage\n    // and deposit into receiver\n    // emit Withdrawn\n    let tokCfg = SafeBox.tokMap[token] ?? panic(\"token not support in contract\")\n    VolumeControl.updateVolume(token: token, amt: wdInfo.amount, cap: tokCfg.cap)\n    let wdId = String.encodeHex(HashAlgorithm.SHA3_256.hash(wdmsg))\n\n    assert(!self.records.containsKey(wdId), message: \"wdId already exists\")\n    self.records[wdId] = true\n    let receiverCap = getAccount(wdInfo.receiver).getCapability<&{FungibleToken.Receiver}>(tokCfg.vaultPub)\n    let vaultRef = self.account.borrow<&{FungibleToken.Provider}>(from: tokCfg.vaultSto) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n    // vault that holds to deposit ft\n    let vault <- vaultRef.withdraw(amount: wdInfo.amount)\n\n    if wdInfo.amount > tokCfg.delayThreshold {\n      // add to delayed xfer\n      DelayedTransfer.addDelayXfer(id: wdId, receiverCap: receiverCap, from: <- vault)\n    } else {\n      let receiverRef = receiverCap.borrow() ?? panic(\"Could not borrow a reference to the receiver\")\n      // deposit into receiver\n      receiverRef.deposit(from: <- vault)\n    }\n    // emit withdrawn even added to delay, to be consistent with solidity\n    emit Withdrawn(\n      wdId: wdId,\n      receiver: wdInfo.receiver,\n      token: token,\n      amount: wdInfo.amount,\n      refChId: wdInfo.refChainId,\n      burnAddr: wdInfo.burnAccount,\n      refId: wdInfo.refId\n    )\n  }\n\n  pub fun executeDelayedTransfer(wdId: String) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    DelayedTransfer.executeDelayXfer(wdId)\n  }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: path for admin resource"}, {"role": "assistant", "content": "pub let AdminPath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "pub event Deposited(\n    depoId: String,\n    depositor: Address,\n    token: String,\n    amount: UFix64,\n    mintChId: UInt64,\n    mintAddr: String,\n    nonce: UInt64\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "(\n    depoId: String,\n    depositor: Address,\n    token: String,\n    amount: UFix64,\n    mintChId: UInt64,\n    mintAddr: String,\n    nonce: UInt64\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== structs ==========\ntoken vault type identifier string to its config so we can borrow for deposit/withdraw"}, {"role": "assistant", "content": "pub struct TokenCfg {\n    pub let vaultPub: PublicPath\n    pub let vaultSto: StoragePath\n    pub let minDepo: UFix64\n    pub let maxDepo: UFix64\n    // if withdraw amount > delayThreshold, put into delayed transfer map\n    pub let delayThreshold: UFix64\n    // used for volume controller\n    pub let cap: UFix64\n\n    init(vaultPub:PublicPath, vaultSto: StoragePath, minDepo: UFix64, maxDepo: UFix64, delayThreshold: UFix64, cap: UFix64) {\n      self.vaultPub = vaultPub\n      self.vaultSto = vaultSto\n      self.minDepo = minDepo\n      self.maxDepo = maxDepo\n      self.delayThreshold = delayThreshold\n      self.cap = cap\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: if withdraw amount > delayThreshold, put into delayed transfer map"}, {"role": "assistant", "content": "pub let delayThreshold: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: used for volume controller"}, {"role": "assistant", "content": "pub let cap: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: info about one user deposit"}, {"role": "assistant", "content": "pub struct DepoInfo {\n    pub let amt: UFix64\n    pub let mintChId: UInt64\n    pub let mintAddr: String\n    pub let nonce: UInt64\n\n    init(amt: UFix64, mintChId: UInt64, mintAddr: String, nonce: UInt64) {\n      self.amt = amt\n      self.mintChId = mintChId\n      self.mintAddr = mintAddr\n      self.nonce = nonce\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== contract states and maps ==========\nunique chainid required by cbridge system"}, {"role": "assistant", "content": "pub let chainID: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: domainPrefix to ensure no replay on co-sign msgs"}, {"role": "assistant", "content": "access(contract) let domainPrefix: [UInt8]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: similar to solidity pausable"}, {"role": "assistant", "content": "pub var isPaused: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: key is token vault identifier, eg. A.1122334455667788.ExampleToken.Vault"}, {"role": "assistant", "content": "access(account) var tokMap: {String: TokenCfg}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: save for each deposit/withdraw to avoid duplicated process\nkey is calculated depoId or wdId"}, {"role": "assistant", "content": "access(account) var records: {String: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== resource =========="}, {"role": "assistant", "content": "pub resource SafeBoxAdmin {\n    pub fun addTok(identifier: String, tok: TokenCfg) {\n      assert(!SafeBox.tokMap.containsKey(identifier), message: \"this token already exist\")\n      SafeBox.tokMap[identifier] = tok\n    }\n\n    pub fun rmTok(identifier: String) {\n      assert(SafeBox.tokMap.containsKey(identifier), message: \"this token do not exist\")\n      SafeBox.tokMap.remove(key: identifier)\n    }\n\n    pub fun pause() {\n      SafeBox.isPaused = true\n      DelayedTransfer.pause()\n    }\n    pub fun unPause() {\n      SafeBox.isPaused = false\n      DelayedTransfer.unPause()\n    }\n\n    pub fun createSafeBoxAdmin(): @SafeBoxAdmin {\n        return <-create SafeBoxAdmin()\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== functions ==========\nchainid must be same as cbridge common proto FLOW_MAINNET = 12340001; FLOW_TEST = 12340002;"}, {"role": "assistant", "content": "init(chID:UInt64) {\n    self.chainID = chID\n    // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.SafeBox\".utf8, xxxx is this contract account\n    self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n    self.isPaused = false\n\n    self.records = {}\n    self.tokMap = {}\n\n    self.AdminPath = /storage/SafeBoxAdmin\n    self.account.save<@SafeBoxAdmin>(<- create SafeBoxAdmin(), to: self.AdminPath)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: we can also use recipient: &AnyResource{FungibleToken.Receiver} to do deposit.\nbut now, we use the tokCfg pubPath to get the Receiver first."}, {"role": "assistant", "content": "pub fun withdraw(token: String, wdmsg: [UInt8], sigs: [cBridge.SignerSig]) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    // calculate correct data by prefix domain, sgn needs to sign the same way\n    let domain = self.domainPrefix.concat(\"Withdraw\".utf8)\n    assert(cBridge.verify(data: domain.concat(wdmsg), sigs: sigs), message: \"verify sigs failed\")\n    let wdInfo = PbPegged.Withdraw(wdmsg)\n    assert(wdInfo.eqToken(tkStr: token), message: \"mismatch token string\")\n    // calculate wdId and check records map\n    // withdraw from self storage\n    // and deposit into receiver\n    // emit Withdrawn\n    let tokCfg = SafeBox.tokMap[token] ?? panic(\"token not support in contract\")\n    VolumeControl.updateVolume(token: token, amt: wdInfo.amount, cap: tokCfg.cap)\n    let wdId = String.encodeHex(HashAlgorithm.SHA3_256.hash(wdmsg))\n\n    assert(!self.records.containsKey(wdId), message: \"wdId already exists\")\n    self.records[wdId] = true\n    let receiverCap = getAccount(wdInfo.receiver).getCapability<&{FungibleToken.Receiver}>(tokCfg.vaultPub)\n    let vaultRef = self.account.borrow<&{FungibleToken.Provider}>(from: tokCfg.vaultSto) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n    // vault that holds to deposit ft\n    let vault <- vaultRef.withdraw(amount: wdInfo.amount)\n\n    if wdInfo.amount > tokCfg.delayThreshold {\n      // add to delayed xfer\n      DelayedTransfer.addDelayXfer(id: wdId, receiverCap: receiverCap, from: <- vault)\n    } else {\n      let receiverRef = receiverCap.borrow() ?? panic(\"Could not borrow a reference to the receiver\")\n      // deposit into receiver\n      receiverRef.deposit(from: <- vault)\n    }\n    // emit withdrawn even added to delay, to be consistent with solidity\n    emit Withdrawn(\n      wdId: wdId,\n      receiver: wdInfo.receiver,\n      token: token,\n      amount: wdInfo.amount,\n      refChId: wdInfo.refChainId,\n      burnAddr: wdInfo.burnAccount,\n      refId: wdInfo.refId\n    )\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "pub event EpochLengthUpdated(length: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "(length: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== admin resource =========="}, {"role": "assistant", "content": "pub resource Admin {\n    pub fun setEpochLength(newLength: UInt64) {\n      VolumeControl.epochLength = newLength\n      emit EpochLengthUpdated(\n        length: newLength\n      )\n    }\n\n    // createNewAdmin creates a new Admin resource\n    pub fun createNewAdmin(): @Admin {\n      return <-create Admin()\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewAdmin creates a new Admin resource"}, {"role": "assistant", "content": "pub fun createNewAdmin(): @Admin {\n      return <-create Admin()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== functions =========="}, {"role": "assistant", "content": "init() {\n    self.epochLength = 0\n    self.epochVolumes = {}\n    self.lastOpTimestamps = {}\n    self.AdminPath = /storage/VolumeControlAdmin\n    self.account.save<@Admin>(<- create Admin(), to: self.AdminPath)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: only need to support signer verify for now"}, {"role": "assistant", "content": "pub contract cBridge {\n\n    pub event SignersUpdated(\n      signers: {String: UInt256}\n    )\n\n    // path for admin resource\n    pub let AdminPath: StoragePath\n    // unique chainid required by cbridge system\n    pub let chainID: UInt64\n    access(contract) let domainPrefix: [UInt8]\n    // save map from pubkey to power, only visible in this contract to extra safety\n    access(contract) var signers: {String: UInt256}\n    pub var totalPower: UInt256\n    // block height when signers are last updated by sigs\n    // flow block.timestamp is UFix64 so hard to use\n    pub var signerUpdateBlock: UInt64\n\n    // at first we require pubkey to be also present in SignerSig, so verify can just do map lookup in signers\n    // but this make other components in the system to be aware of pubkeys which is hard to do\n    // so without pubkey, we just loop over all signers and call verify, it's less efficient but won't be an issue\n    // as there won't be many signers. we keep struct for future flexibility but pubkey field is NOT needed.\n    pub struct SignerSig {\n        pub let sig: [UInt8]\n        init(sig: [UInt8]) {\n            self.sig = sig\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important functions to modify the contract state\n    pub resource BridgeAdmin {\n        pub fun resetSigners(signers: {String: UInt256}) {\n            cBridge.signers = signers\n            cBridge.totalPower = 0\n            for power in signers.values {\n                cBridge.totalPower = cBridge.totalPower + power\n            }\n            emit SignersUpdated(\n              signers: signers\n            )\n        }\n        pub fun createBridgeAdmin(): @BridgeAdmin {\n            return <-create BridgeAdmin()\n        }\n    }\n\n    // getter for signers/power as self.signers is not accessible outside contract\n    pub fun getSigners(): {String: UInt256} {\n        return self.signers\n    }\n\n    // return true if sigs have more than 2/3 total power\n    pub fun verify(data:[UInt8], sigs: [SignerSig]): Bool {\n        var signedPower: UInt256 = 0\n        var quorum: UInt256 = (self.totalPower*2)/3 + 1\n        // go over all known signers, for each signer, try to find which sig matches\n        for pubkey in self.signers.keys {\n            let pk = PublicKey(\n                    publicKey: pubkey.decodeHex(),\n                    signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1\n            )\n            // for this pk, try to find the matched sig\n            // flow doc says `for index, element in array` but it's only in master https://github.com/onflow/cadence/issues/1230\n            var idx = 0\n            for ss in sigs {\n                if pk.verify(\n                    signature: ss.sig,\n                    signedData: data,\n                    domainSeparationTag: \"FLOW-V0.0-user\",\n                    hashAlgorithm: HashAlgorithm.SHA3_256\n                ) {\n                    signedPower = signedPower + self.signers[pubkey]!\n                    if signedPower >= quorum {\n                        return true\n                    }\n                    // delete ss from sigs\n                    sigs.remove(at: idx)\n                    // now we break the sig loop to check next signer as we only allow one sig per signer\n                    break\n                }\n                idx = idx + 1\n            }\n        }\n        return false\n    }\n\n    init(chID:UInt64) {\n      self.chainID = chID\n      // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.cBridge\".utf8, xxxx is this contract account\n      self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n  \n      self.signers = {}\n      self.totalPower = 0\n\n      self.signerUpdateBlock = 0\n\n      self.AdminPath = /storage/cBridgeAdmin\n      self.account.save<@BridgeAdmin>(<- create BridgeAdmin(), to: self.AdminPath)\n    }\n\n    // below are struct and func needed to update cBridge.signers by cosigned msg\n    // blockheight is like nonce to avoid replay attack\n    /* proto definition\n    message PbSignerPowerMap {\n        uint64 blockheight = 1; // block when this pb was proposed by sgn, must < currentblock\n        repeated SignerPower = 2;\n    }\n    message SignerPower {\n        bytes pubkey = 1; // raw bytes of pubkey, 64 bytes\n        bytes power = 2; // big.Int.Bytes\n    }\n    */\n    pub struct PbSignerPowerMap {\n        pub var blockheight: UInt64\n        pub let signerMap: {String: UInt256}\n        pub var totalPower: UInt256\n        // raw is serialized PbSignerPowerMap\n        init(_ raw: [UInt8]) {\n            self.blockheight = 0\n            self.signerMap = {}\n            self.totalPower = 0\n            // now decode pbraw and assign\n            let buf = Pb.Buffer(raw)\n            while buf.hasMore() {\n              let tagType = buf.decKey()\n              switch Int(tagType.tag) {\n                case 1:\n                  assert(tagType.wt==Pb.WireType.Varint, message: \"wrong wire type\")\n                  self.blockheight = buf.decVarint()\n                case 2:\n                  assert(tagType.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  // now decode SignerPower msg\n                  // pegbridge.pb.go, as the proto code show, repeated field has a key outside\n                  let tag0 = buf.decKey()\n                  let tag1 = buf.decKey()\n                  assert(tag1.tag==1, message: \"tag not 1: \".concat(tag1.tag.toString()))\n                  assert(tag1.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  let pbhex = Pb.toString(buf.decBytes())\n                  let tag2 = buf.decKey()\n                  assert(tag2.tag==2, message: \"tag not 2: \".concat(tag2.tag.toString()))\n                  assert(tag2.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  let power = Pb.toUInt256(buf.decBytes())\n                  // add to map\n                  self.signerMap[pbhex] = power\n                  self.totalPower = self.totalPower + power\n                default:\n                  assert(false, message: \"unsupported tag\")\n              }\n            }\n        }\n    }\n    // new signers can be updated if cosigned by existing signers w/ 2/3 power\n    // pbmsg is serialized PbSignerPowerMap\n    access(account) fun updateSigners(pbmsg:[UInt8], sigs: [SignerSig]) {\n      let domain = self.domainPrefix.concat(\".UpdateSigners\".utf8)\n      assert(self.verify(data: domain.concat(pbmsg), sigs: sigs), message: \"verify sigs failed\")\n      let newSigners = PbSignerPowerMap(pbmsg)\n      assert(newSigners.totalPower > 0, message: \"total power must > 0\")\n      assert(newSigners.blockheight > self.signerUpdateBlock, message: \"new signer timestamp must be larger\")\n      assert(newSigners.blockheight <= getCurrentBlock().height, message: \"new signer timestamp must <= current\")\n      // update signerUpdateBlock and signers\n      self.signerUpdateBlock = getCurrentBlock().height\n      self.totalPower = newSigners.totalPower\n      self.signers = newSigners.signerMap\n\n      emit SignersUpdated(\n        signers: newSigners.signerMap\n      )\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: unique chainid required by cbridge system"}, {"role": "assistant", "content": "pub let chainID: UInt64"}]}
