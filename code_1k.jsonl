{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Total supply of NWayUtilityCoins in existence"}, {"role": "assistant", "content": "pub var totalSupply: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when the contract is created"}, {"role": "assistant", "content": "pub event TokensInitialized(initialSupply: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when the contract is created"}, {"role": "assistant", "content": "(initialSupply: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are withdrawn from a Vault"}, {"role": "assistant", "content": "pub event TokensWithdrawn(amount: UFix64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are withdrawn from a Vault"}, {"role": "assistant", "content": "(amount: UFix64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are deposited to a Vault"}, {"role": "assistant", "content": "pub event TokensDeposited(amount: UFix64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are deposited to a Vault"}, {"role": "assistant", "content": "(amount: UFix64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are minted"}, {"role": "assistant", "content": "pub event TokensMinted(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are minted"}, {"role": "assistant", "content": "(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed"}, {"role": "assistant", "content": "pub event TokensBurned(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed"}, {"role": "assistant", "content": "(amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new minter resource is created"}, {"role": "assistant", "content": "pub event MinterCreated(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new minter resource is created"}, {"role": "assistant", "content": "(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "pub event BurnerCreated()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the `token Vault` is stored"}, {"role": "assistant", "content": "pub let VaultStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the `token Admin` is stored"}, {"role": "assistant", "content": "pub let AdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the public capability for the `token balance` is"}, {"role": "assistant", "content": "pub let TokenBalancePublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Path where the public capability for the `token receiver` is"}, {"role": "assistant", "content": "pub let TokenReceiverPublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Vault\n\nEach user stores an instance of only the Vault in their storage\nThe functions in the Vault and governed by the pre and post conditions\nin FungibleToken when they are called.\nThe checks happen at runtime whenever a function is called.\n\nResources can only be created in the context of the contract that they\nare defined in, so there is no way for a malicious user to create Vaults\nout of thin air. A special Minter resource needs to be defined to mint\nnew tokens.\n"}, {"role": "assistant", "content": "pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {\n\n        // holds the balance of a users tokens\n        pub var balance: UFix64\n\n        // initialize the balance at resource creation time\n        init(balance: UFix64) {\n            self.balance = balance\n        }\n\n        // withdraw\n        //\n        // Function that takes an integer amount as an argument\n        // and withdraws that amount from the Vault.\n        // It creates a new temporary Vault that is used to hold\n        // the money that is being transferred. It returns the newly\n        // created Vault to the context that called so it can be deposited\n        // elsewhere.\n        //\n        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }\n\n        // deposit\n        //\n        // Function that takes a Vault object as an argument and adds\n        // its balance to the balance of the owners Vault.\n        // It is allowed to destroy the sent Vault because the Vault\n        // was a temporary holder of the tokens. The Vault's balance has\n        // been consumed and therefore can be destroyed.\n        pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }\n\n        destroy() {\n            NWayUtilityCoin.totalSupply = NWayUtilityCoin.totalSupply - self.balance\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: holds the balance of a users tokens"}, {"role": "assistant", "content": "pub var balance: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initialize the balance at resource creation time"}, {"role": "assistant", "content": "init(balance: UFix64) {\n            self.balance = balance\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw\n\nFunction that takes an integer amount as an argument\nand withdraws that amount from the Vault.\nIt creates a new temporary Vault that is used to hold\nthe money that is being transferred. It returns the newly\ncreated Vault to the context that called so it can be deposited\nelsewhere.\n"}, {"role": "assistant", "content": "pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit\n\nFunction that takes a Vault object as an argument and adds\nits balance to the balance of the owners Vault.\nIt is allowed to destroy the sent Vault because the Vault\nwas a temporary holder of the tokens. The Vault's balance has\nbeen consumed and therefore can be destroyed."}, {"role": "assistant", "content": "pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyVault\n\nFunction that creates a new Vault with a balance of zero\nand returns it to the calling context. A user must call this function\nand store the returned Vault in their storage in order to allow their\naccount to be able to receive deposits of this token type.\n"}, {"role": "assistant", "content": "pub fun createEmptyVault(): @FungibleToken.Vault {\n        return <-create Vault(balance: 0.0)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewMinter\n\nFunction that creates and returns a new minter resource\n"}, {"role": "assistant", "content": "pub fun createNewMinter(allowedAmount: UFix64): @Minter {\n            emit MinterCreated(allowedAmount: allowedAmount)\n            return <-create Minter(allowedAmount: allowedAmount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewBurner\n\nFunction that creates and returns a new burner resource\n"}, {"role": "assistant", "content": "pub fun createNewBurner(): @Burner {\n            emit BurnerCreated()\n            return <-create Burner()\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Minter\n\nResource object that token admin accounts can hold to mint new tokens.\n"}, {"role": "assistant", "content": "pub resource Minter {\n\n        // the amount of tokens that the minter is allowed to mint\n        pub var allowedAmount: UFix64\n\n        // mintTokens\n        //\n        // Function that mints new tokens, adds them to the total supply,\n        // and returns them to the calling context.\n        //\n        pub fun mintTokens(amount: UFix64): @NWayUtilityCoin.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            NWayUtilityCoin.totalSupply = NWayUtilityCoin.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }\n\n        init(allowedAmount: UFix64) {\n            self.allowedAmount = allowedAmount\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the amount of tokens that the minter is allowed to mint"}, {"role": "assistant", "content": "pub var allowedAmount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintTokens\n\nFunction that mints new tokens, adds them to the total supply,\nand returns them to the calling context.\n"}, {"role": "assistant", "content": "pub fun mintTokens(amount: UFix64): @NWayUtilityCoin.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            NWayUtilityCoin.totalSupply = NWayUtilityCoin.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Burner\n\nResource object that token admin accounts can hold to burn tokens.\n"}, {"role": "assistant", "content": "pub resource Burner {\n\n        // burnTokens\n        //\n        // Function that destroys a Vault instance, effectively burning the tokens.\n        //\n        // Note: the burned tokens are automatically subtracted from the\n        // total supply in the Vault destructor.\n        //\n        pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: burnTokens\n\nFunction that destroys a Vault instance, effectively burning the tokens.\n\nNote: the burned tokens are automatically subtracted from the\ntotal supply in the Vault destructor.\n"}, {"role": "assistant", "content": "pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @NWayUtilityCoin.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Simple fee manager\n"}, {"role": "assistant", "content": "pub contract RaribleFee {\n\n    pub let commonFeeManagerStoragePath: StoragePath\n\n    pub event SellerFeeChanged(value: UFix64)\n    pub event BuyerFeeChanged(value: UFix64)\n\n    // Seller fee [0..1)\n    pub var sellerFee: UFix64\n\n    // BuyerFee fee [0..1)\n    pub var buyerFee: UFix64\n\n    pub resource Manager {\n        pub fun setSellerFee(_ fee: UFix64) {\n            RaribleFee.sellerFee = fee\n            emit SellerFeeChanged(value: RaribleFee.sellerFee)\n        }\n\n        pub fun setBuyerFee(_ fee: UFix64) {\n            RaribleFee.buyerFee = fee\n            emit BuyerFeeChanged(value: RaribleFee.buyerFee)\n        }\n    }\n\n    init() {\n        self.sellerFee = 0.025\n        emit SellerFeeChanged(value: RaribleFee.sellerFee)\n        self.buyerFee = 0.025\n        emit BuyerFeeChanged(value: RaribleFee.buyerFee)\n\n        self.commonFeeManagerStoragePath = /storage/commonFeeManager\n        self.account.save(<- create Manager(), to: self.commonFeeManagerStoragePath)\n    }\n\n    pub fun feeAddress(): Address {\n        return self.account.address\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Seller fee [0..1)"}, {"role": "assistant", "content": "pub var sellerFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BuyerFee fee [0..1)"}, {"role": "assistant", "content": "pub var buyerFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: RaribleNFT token contract\n"}, {"role": "assistant", "content": "pub contract RaribleNFT : NonFungibleToken, LicensedNFT {\n\n    pub var totalSupply: UInt64\n\n    pub var collectionPublicPath: PublicPath\n    pub var collectionStoragePath: StoragePath\n    pub var minterPublicPath: PublicPath\n    pub var minterStoragePath: StoragePath\n\n    pub event ContractInitialized()\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n\n    pub event Mint(id: UInt64, creator: Address, metadata: {String:String}, royalties: [LicensedNFT.Royalty])\n    pub event Destroy(id: UInt64)\n\n    pub struct Royalty {\n        pub let address: Address\n        pub let fee: UFix64\n\n        init(address: Address, fee: UFix64) {\n            self.address = address\n            self.fee = fee\n        }\n    }\n\n    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {\n        pub let id: UInt64\n        pub let creator: Address\n        access(self) let metadata: {String:String}\n        access(self) let royalties: [LicensedNFT.Royalty]\n\n        init(id: UInt64, creator: Address, metadata: {String:String}, royalties: [LicensedNFT.Royalty]) {\n            self.id = id\n            self.creator = creator\n            self.metadata = metadata\n            self.royalties = royalties\n        }\n\n        pub fun getViews(): [Type] {\n            return [Type<MetadataViews.Display>()]\n        }\n\n        pub fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: self.metadata[\"name\"] ?? \"\",\n                        description: self.metadata[\"description\"] ?? \"\",\n                        thumbnail: MetadataViews.HTTPFile(url: self.metadata[\"metaURI\"] ?? \"\"),\n                    )\n            }\n            return nil\n        }\n\n        pub fun getMetadata(): {String:String} {\n            return self.metadata\n        }\n\n        pub fun getRoyalties(): [LicensedNFT.Royalty] {\n            return self.royalties\n        }\n\n        destroy() {\n            emit Destroy(id: self.id)\n        }\n    }\n\n    pub resource interface CollectionPublic {\n        pub fun borrow(id: UInt64): &NFT?\n    }\n\n    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, LicensedNFT.CollectionPublic, CollectionPublic {\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"Missing NFT\")\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            return <- token\n        }\n\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @RaribleNFT.NFT\n            let id: UInt64 = token.id\n            let dummy <- self.ownedNFTs[id] <- token\n            destroy dummy\n            emit Deposit(id: id, to: self.owner?.address)\n        }\n\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {\n            let authRef = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            let ref = authRef as! &NFT\n            return ref as! &{MetadataViews.Resolver}\n        }\n\n        pub fun borrow(id: UInt64): &NFT? {\n            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            return ref as! &RaribleNFT.NFT\n        }\n\n        pub fun getMetadata(id: UInt64): {String:String} {\n            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            return (ref as! &RaribleNFT.NFT).getMetadata()\n        }\n\n        pub fun getRoyalties(id: UInt64): [LicensedNFT.Royalty] {\n            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n            return (ref as! &LicensedNFT.NFT).getRoyalties()\n        }\n\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }\n\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    pub resource Minter {\n        pub fun mintTo(creator: Capability<&{NonFungibleToken.Receiver}>, metadata: {String:String}, royalties: [LicensedNFT.Royalty]): &NonFungibleToken.NFT {\n            let token <- create NFT(\n                id: RaribleNFT.totalSupply,\n                creator: creator.address,\n                metadata: metadata,\n                royalties: royalties\n            )\n            RaribleNFT.totalSupply = RaribleNFT.totalSupply + 1\n            let tokenRef = &token as &NonFungibleToken.NFT\n            emit Mint(id: token.id, creator: creator.address, metadata: metadata, royalties: royalties)\n            creator.borrow()!.deposit(token: <- token)\n            return tokenRef\n        }\n    }\n\n    pub fun minter(): Capability<&Minter> {\n        return self.account.getCapability<&Minter>(self.minterPublicPath)\n    }\n\n    init() {\n        self.totalSupply = 0\n        self.collectionPublicPath = /public/RaribleNFTCollection\n        self.collectionStoragePath = /storage/RaribleNFTCollection\n        self.minterPublicPath = /public/RaribleNFTMinter\n        self.minterStoragePath = /storage/RaribleNFTMinter\n\n        let minter <- create Minter()\n        self.account.save(<- minter, to: self.minterStoragePath)\n        self.account.link<&Minter>(self.minterPublicPath, target: self.minterStoragePath)\n\n        let collection <- self.createEmptyCollection()\n        self.account.save(<- collection, to: self.collectionStoragePath)\n        self.account.link<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(self.collectionPublicPath, target: self.collectionStoragePath)\n\n        emit ContractInitialized()\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: RaribleOrder\n\nWraps the NFTStorefront.createListting\n"}, {"role": "assistant", "content": "pub contract RaribleOrder {\n\n    pub let BUYER_FEE: String\n    pub let SELLER_FEE: String\n    pub let OTHER: String\n    pub let ROYALTY: String\n    pub let REWARD: String\n\n    init() {\n        // market buyer fee (on top of the price)\n        self.BUYER_FEE = \"BUYER_FEE\"\n\n        // market seller fee\n        self.SELLER_FEE = \"SELLER_FEE\"\n\n        // additional payments\n        self.OTHER = \"OTHER\"\n\n        // royalty\n        self.ROYALTY = \"ROYALTY\"\n\n        // seller reward\n        self.REWARD = \"REWARD\"\n    }\n\n    // PaymentPart\n    // \n    pub struct PaymentPart {\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        init(address: Address, rate: UFix64) {\n            self.address = address\n            self.rate = rate\n        }\n    }\n\n    // Payment\n    // Describes payment in the event OrderAvailable\n    // \n    pub struct Payment {\n        // type of payment\n        pub let type: String\n\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        // payment amount\n        pub let amount: UFix64\n\n        init(type: String, address: Address, rate: UFix64, amount: UFix64) {\n            self.type = type\n            self.address = address\n            self.rate = rate\n            self.amount = amount\n        }\n    }\n\n    // OrderAvailable\n    // Order created and available for purchase\n    // \n    pub event OrderAvailable(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64, // sum of payment parts\n        offerPrice: UFix64, // base for calculate rates\n        payments: [Payment]\n    )\n\n    pub event OrderClosed(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64,\n        buyerAddress: Address,\n        cuts: [PaymentPart]\n    )\n\n    pub event OrderCancelled(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64,\n        cuts: [PaymentPart]\n    )\n\n    // addOrder\n    // Wrapper for NFTStorefront.createListing\n    //\n    pub fun addOrder(\n        storefront: &NFTStorefront.Storefront,\n        nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftId: UInt64,\n        vaultPath: PublicPath,\n        vaultType: Type,\n        price: UFix64,\n        extraCuts: [PaymentPart],\n        royalties: [PaymentPart]\n    ): UInt64 {\n        let orderAddress = storefront.owner!.address\n        let payments: [Payment] = []\n        let saleCuts: [NFTStorefront.SaleCut] = []\n        var percentage = 1.0\n        var offerPrice = 0.0\n\n        let addPayment = fun (type: String, address: Address, rate: UFix64) {\n            assert(rate >= 0.0 && rate < 1.0, message: \"Rate must be in range [0..1)\")\n            let amount = price * rate\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(vaultPath)\n            assert(receiver.borrow() != nil, message: \"Missing or mis-typed fungible token receiver\")\n\n            payments.append(Payment(type:type, address:address, rate: rate, amount: amount))\n            saleCuts.append(NFTStorefront.SaleCut(receiver: receiver, amount: amount))\n\n            offerPrice = offerPrice + amount\n            percentage = percentage - (type == RaribleOrder.BUYER_FEE ? 0.0 : rate)\n            assert(rate >= 0.0 && rate < 1.0, message: \"Sum of payouts must be in range [0..1)\")\n        }\n\n        addPayment(RaribleOrder.BUYER_FEE, RaribleFee.feeAddress(), RaribleFee.buyerFee)\n        addPayment(RaribleOrder.SELLER_FEE, RaribleFee.feeAddress(), RaribleFee.sellerFee)\n\n        for cut in extraCuts {\n            addPayment(RaribleOrder.OTHER, cut.address, cut.rate)\n        }\n\n        for royalty in royalties {\n            addPayment(RaribleOrder.ROYALTY, royalty.address, royalty.rate)\n        }\n\n        addPayment(RaribleOrder.REWARD, orderAddress, percentage)\n\n        let orderId = storefront.createListing(\n            nftProviderCapability: nftProvider,\n            nftType: nftType,\n            nftID: nftId,\n            salePaymentVaultType: vaultType,\n            saleCuts: saleCuts\n        )\n\n        emit OrderAvailable(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: nftType.identifier,\n            nftId: nftId,\n            vaultType: vaultType.identifier,\n            price: price,\n            offerPrice: offerPrice,\n            payments: payments\n        )\n\n        return orderId\n    }\n\n    // closeOrder\n    // Purchase nft by o\n    //\n    pub fun closeOrder(\n        storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic},\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n        paymentVault: @FungibleToken.Vault,\n        buyerAddress: Address\n    ): @NonFungibleToken.NFT {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderClosed(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            buyerAddress: buyerAddress,\n            cuts: cuts\n        )\n\n        let item <- listing.purchase(payment: <-paymentVault)\n        storefront.cleanup(listingResourceID: orderId)\n        return <- item\n    }\n\n    // removeOrder\n    // Cancel sale, dismiss order\n    //\n    pub fun removeOrder(\n        storefront: &NFTStorefront.Storefront,\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n    ) {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderCancelled(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            cuts: cuts\n        )\n\n        storefront.removeListing(listingResourceID: orderId)\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: PaymentPart\n"}, {"role": "assistant", "content": "pub struct PaymentPart {\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        init(address: Address, rate: UFix64) {\n            self.address = address\n            self.rate = rate\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: receiver address"}, {"role": "assistant", "content": "pub let address: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: payment rate"}, {"role": "assistant", "content": "pub let rate: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Payment\nDescribes payment in the event OrderAvailable\n"}, {"role": "assistant", "content": "pub struct Payment {\n        // type of payment\n        pub let type: String\n\n        // receiver address\n        pub let address: Address\n\n        // payment rate\n        pub let rate: UFix64\n\n        // payment amount\n        pub let amount: UFix64\n\n        init(type: String, address: Address, rate: UFix64, amount: UFix64) {\n            self.type = type\n            self.address = address\n            self.rate = rate\n            self.amount = amount\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: type of payment"}, {"role": "assistant", "content": "pub let type: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: payment amount"}, {"role": "assistant", "content": "pub let amount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OrderAvailable\nOrder created and available for purchase\n"}, {"role": "assistant", "content": "pub event OrderAvailable(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64, // sum of payment parts\n        offerPrice: UFix64, // base for calculate rates\n        payments: [Payment]\n    )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OrderAvailable\nOrder created and available for purchase\n"}, {"role": "assistant", "content": "(\n        orderAddress: Address,\n        orderId: UInt64,\n        nftType: String,\n        nftId: UInt64,\n        vaultType: String,\n        price: UFix64, // sum of payment parts\n        offerPrice: UFix64, // base for calculate rates\n        payments: [Payment]\n    )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: addOrder\nWrapper for NFTStorefront.createListing\n"}, {"role": "assistant", "content": "pub fun addOrder(\n        storefront: &NFTStorefront.Storefront,\n        nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftId: UInt64,\n        vaultPath: PublicPath,\n        vaultType: Type,\n        price: UFix64,\n        extraCuts: [PaymentPart],\n        royalties: [PaymentPart]\n    ): UInt64 {\n        let orderAddress = storefront.owner!.address\n        let payments: [Payment] = []\n        let saleCuts: [NFTStorefront.SaleCut] = []\n        var percentage = 1.0\n        var offerPrice = 0.0\n\n        let addPayment = fun (type: String, address: Address, rate: UFix64) {\n            assert(rate >= 0.0 && rate < 1.0, message: \"Rate must be in range [0..1)\")\n            let amount = price * rate\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(vaultPath)\n            assert(receiver.borrow() != nil, message: \"Missing or mis-typed fungible token receiver\")\n\n            payments.append(Payment(type:type, address:address, rate: rate, amount: amount))\n            saleCuts.append(NFTStorefront.SaleCut(receiver: receiver, amount: amount))\n\n            offerPrice = offerPrice + amount\n            percentage = percentage - (type == RaribleOrder.BUYER_FEE ? 0.0 : rate)\n            assert(rate >= 0.0 && rate < 1.0, message: \"Sum of payouts must be in range [0..1)\")\n        }\n\n        addPayment(RaribleOrder.BUYER_FEE, RaribleFee.feeAddress(), RaribleFee.buyerFee)\n        addPayment(RaribleOrder.SELLER_FEE, RaribleFee.feeAddress(), RaribleFee.sellerFee)\n\n        for cut in extraCuts {\n            addPayment(RaribleOrder.OTHER, cut.address, cut.rate)\n        }\n\n        for royalty in royalties {\n            addPayment(RaribleOrder.ROYALTY, royalty.address, royalty.rate)\n        }\n\n        addPayment(RaribleOrder.REWARD, orderAddress, percentage)\n\n        let orderId = storefront.createListing(\n            nftProviderCapability: nftProvider,\n            nftType: nftType,\n            nftID: nftId,\n            salePaymentVaultType: vaultType,\n            saleCuts: saleCuts\n        )\n\n        emit OrderAvailable(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: nftType.identifier,\n            nftId: nftId,\n            vaultType: vaultType.identifier,\n            price: price,\n            offerPrice: offerPrice,\n            payments: payments\n        )\n\n        return orderId\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: closeOrder\nPurchase nft by o\n"}, {"role": "assistant", "content": "pub fun closeOrder(\n        storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic},\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n        paymentVault: @FungibleToken.Vault,\n        buyerAddress: Address\n    ): @NonFungibleToken.NFT {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderClosed(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            buyerAddress: buyerAddress,\n            cuts: cuts\n        )\n\n        let item <- listing.purchase(payment: <-paymentVault)\n        storefront.cleanup(listingResourceID: orderId)\n        return <- item\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: removeOrder\nCancel sale, dismiss order\n"}, {"role": "assistant", "content": "pub fun removeOrder(\n        storefront: &NFTStorefront.Storefront,\n        orderId: UInt64,\n        orderAddress: Address,\n        listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic},\n    ) {\n        let details = listing.getDetails()\n        let cuts: [PaymentPart] = []\n        for saleCut in details.saleCuts {\n            cuts.append(PaymentPart(address: saleCut.receiver.address, rate: saleCut.amount))\n        }\n\n        emit OrderCancelled(\n            orderAddress: orderAddress,\n            orderId: orderId,\n            nftType: details.nftType.identifier,\n            nftId: details.nftID,\n            vaultType: details.salePaymentVaultType.identifier,\n            price: details.salePrice,\n            cuts: cuts\n        )\n\n        storefront.removeListing(listingResourceID: orderId)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Data struct signed by account with specified \"adminPublicKey.\"\n\nPermits accounts to purchase specific NFTs for some period of time."}, {"role": "assistant", "content": "pub struct AdminSignedData {\n        pub let externalID: String\n        pub let priceType: String\n        pub let primarySaleAddress: Address\n        pub let purchaserAddress: Address\n        pub let assetIDs: [UInt64]\n        pub let expiration: UInt64 // unix timestamp\n\n        init(externalID: String, primarySaleAddress: Address, purchaserAddress: Address, assetIDs: [UInt64], priceType: String, expiration: UInt64){\n            self.externalID = externalID\n            self.primarySaleAddress = primarySaleAddress\n            self.purchaserAddress = purchaserAddress\n            self.assetIDs = assetIDs\n            self.priceType = priceType\n            self.expiration = expiration\n        }\n\n        pub fun toString(): String {\n            var assetIDs = \"\"\n            var i = 0\n            while (i < self.assetIDs.length) {\n                if (i > 0) {\n                    assetIDs = assetIDs.concat(\",\")\n                }\n                assetIDs = assetIDs.concat(self.assetIDs[i].toString())\n                i = i + 1\n            }\n            return self.externalID.concat(\":\")\n                .concat(self.primarySaleAddress.toString()).concat(\":\")\n                .concat(self.purchaserAddress.toString()).concat(\":\")\n                .concat(assetIDs).concat(\":\")\n                .concat(self.priceType).concat(\":\")\n                .concat(self.expiration.toString())\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: primary sale metadata"}, {"role": "assistant", "content": "access(self) var details: PrimarySaleDetails"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: pub key used to verify signatures from a specified admin"}, {"role": "assistant", "content": "access(self) var adminPublicKey: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are teleported in from Ethereum (from: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "pub event TokensTeleportedIn(amount: UFix64, from: [UInt8], hash: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when new tokens are teleported in from Ethereum (from: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "(amount: UFix64, from: [UInt8], hash: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed and teleported to Ethereum (to: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "pub event TokensTeleportedOut(amount: UFix64, to: [UInt8])"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when tokens are destroyed and teleported to Ethereum (to: Ethereum Address, 20 bytes)"}, {"role": "assistant", "content": "(amount: UFix64, to: [UInt8])"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when teleport fee is collected (type 0: out, 1: in)"}, {"role": "assistant", "content": "pub event FeeCollected(amount: UFix64, type: UInt8)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when teleport fee is collected (type 0: out, 1: in)"}, {"role": "assistant", "content": "(amount: UFix64, type: UInt8)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "pub event TeleportAdminCreated(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Event that is emitted when a new burner resource is created"}, {"role": "assistant", "content": "(allowedAmount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The storage path for the admin resource (equivalent to root)"}, {"role": "assistant", "content": "pub let AdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The storage path for the teleport-admin resource (less priviledged than admin)"}, {"role": "assistant", "content": "pub let TeleportAdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The private path for the teleport-admin resource"}, {"role": "assistant", "content": "pub let TeleportAdminPrivatePath: PrivatePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The public path for the teleport user"}, {"role": "assistant", "content": "pub let TeleportUserPublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Frozen flag controlled by Admin"}, {"role": "assistant", "content": "pub var isFrozen: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Record teleported Ethereum hashes"}, {"role": "assistant", "content": "access(contract) var teleported: {String: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Controls REVV vault"}, {"role": "assistant", "content": "access(contract) let revvVault: @REVV.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initialize the balance at resource creation time"}, {"role": "assistant", "content": "init(balance: UFix64) {\n      self.balance = balance\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewTeleportAdmin\n\nFunction that creates and returns a new teleport admin resource\n"}, {"role": "assistant", "content": "pub fun createNewTeleportAdmin(allowedAmount: UFix64): @TeleportAdmin {\n      emit TeleportAdminCreated(allowedAmount: allowedAmount)\n      return <- create TeleportAdmin(allowedAmount: allowedAmount)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit\n\nFunction that deposits REVV token into the contract controlled\nvault.\n"}, {"role": "assistant", "content": "pub fun depositRevv(from: @REVV.Vault) {\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      vaultRef.deposit(from: <- from)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: fee collected when token is teleported from Ethereum to Flow"}, {"role": "assistant", "content": "pub var inwardFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: fee collected when token is teleported from Flow to Ethereum"}, {"role": "assistant", "content": "pub var outwardFee: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the amount of tokens that the admin is allowed to teleport"}, {"role": "assistant", "content": "pub var allowedAmount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: corresponding controller account on Ethereum"}, {"role": "assistant", "content": "pub var ethereumAdminAccount: [UInt8]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: TeleportAdmin resource\n\nResource object that has the capability to teleport tokens\nupon receiving teleport request from Ethereum side\n"}, {"role": "assistant", "content": "pub resource TeleportAdmin: TeleportUser, TeleportControl {\n    \n    // the amount of tokens that the admin is allowed to teleport\n    pub var allowedAmount: UFix64\n\n    // receiver reference to collect teleport fee\n    pub let feeCollector: @REVV.Vault\n\n    // fee collected when token is teleported from Ethereum to Flow\n    pub var inwardFee: UFix64\n\n    // fee collected when token is teleported from Flow to Ethereum\n    pub var outwardFee: UFix64\n\n    // corresponding controller account on Ethereum\n    pub var ethereumAdminAccount: [UInt8]\n\n    // teleportIn\n    //\n    // Function that release REVV tokens from custody,\n    // and returns them to the calling context.\n    //\n    pub fun teleportIn(amount: UFix64, from: [UInt8], hash: String): @FungibleToken.Vault {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        amount <= self.allowedAmount: \"Amount teleported must be less than the allowed amount\"\n        amount > self.inwardFee: \"Amount teleported must be greater than inward teleport fee\"\n        from.length == 20: \"Ethereum address should be 20 bytes\"\n        hash.length == 64: \"Ethereum tx hash should be 32 bytes\"\n        !(TeleportCustody.teleported[hash] ?? false): \"Same hash already teleported\"\n      }\n      self.allowedAmount = self.allowedAmount - amount\n\n      TeleportCustody.teleported[hash] = true\n      emit TokensTeleportedIn(amount: amount, from: from, hash: hash)\n\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      let vault <- vaultRef.withdraw(amount: amount)\n      let fee <- vault.withdraw(amount: self.inwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.inwardFee, type: 1)\n\n      return <- vault\n    }\n\n    // teleportOut\n    //\n    // Function that destroys a Vault instance, effectively burning the tokens.\n    //\n    // Note: the burned tokens are automatically subtracted from the \n    // total supply in the Vault destructor.\n    //\n    pub fun teleportOut(from: @REVV.Vault, to: [UInt8]) {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        to.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      let vault <- from as! @REVV.Vault\n      let fee <- vault.withdraw(amount: self.outwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.outwardFee, type: 0)\n\n      let amount = vault.balance\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      vaultRef.deposit(from: <- vault)\n      emit TokensTeleportedOut(amount: amount, to: to)\n    }\n\n    pub fun withdrawFee(amount: UFix64): @FungibleToken.Vault {\n      return <- self.feeCollector.withdraw(amount: amount)\n    }\n\n    pub fun updateInwardFee(fee: UFix64) {\n      self.inwardFee = fee\n    }\n\n    pub fun updateOutwardFee(fee: UFix64) {\n      self.outwardFee = fee\n    }\n\n    pub fun updateEthereumAdminAccount(account: [UInt8]) {\n      pre {\n        account.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      self.ethereumAdminAccount = account\n    }\n\n    pub fun getFeeAmount(): UFix64 {\n      return self.feeCollector.balance\n    }\n\n    pub fun depositAllowance(from: @Allowance) {\n      self.allowedAmount = self.allowedAmount + from.balance\n\n      destroy from\n    }\n\n    pub fun getEthereumAdminAccount(): [UInt8] {\n      return self.ethereumAdminAccount\n    }\n\n    init(allowedAmount: UFix64) {\n      self.allowedAmount = allowedAmount\n\n      self.feeCollector <- REVV.createEmptyVault() as! @REVV.Vault\n      self.inwardFee = 0.01\n      self.outwardFee = 10.0\n\n      self.ethereumAdminAccount = []\n    }\n\n    destroy() {\n      destroy self.feeCollector\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: receiver reference to collect teleport fee"}, {"role": "assistant", "content": "pub let feeCollector: @REVV.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: teleportIn\n\nFunction that release REVV tokens from custody,\nand returns them to the calling context.\n"}, {"role": "assistant", "content": "pub fun teleportIn(amount: UFix64, from: [UInt8], hash: String): @FungibleToken.Vault {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        amount <= self.allowedAmount: \"Amount teleported must be less than the allowed amount\"\n        amount > self.inwardFee: \"Amount teleported must be greater than inward teleport fee\"\n        from.length == 20: \"Ethereum address should be 20 bytes\"\n        hash.length == 64: \"Ethereum tx hash should be 32 bytes\"\n        !(TeleportCustody.teleported[hash] ?? false): \"Same hash already teleported\"\n      }\n      self.allowedAmount = self.allowedAmount - amount\n\n      TeleportCustody.teleported[hash] = true\n      emit TokensTeleportedIn(amount: amount, from: from, hash: hash)\n\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      let vault <- vaultRef.withdraw(amount: amount)\n      let fee <- vault.withdraw(amount: self.inwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.inwardFee, type: 1)\n\n      return <- vault\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: teleportOut\n\nFunction that destroys a Vault instance, effectively burning the tokens.\n\nNote: the burned tokens are automatically subtracted from the\ntotal supply in the Vault destructor.\n"}, {"role": "assistant", "content": "pub fun teleportOut(from: @REVV.Vault, to: [UInt8]) {\n      pre {\n        !TeleportCustody.isFrozen: \"Teleport service is frozen\"\n        to.length == 20: \"Ethereum address should be 20 bytes\"\n      }\n\n      let vault <- from as! @REVV.Vault\n      let fee <- vault.withdraw(amount: self.outwardFee)\n\n      self.feeCollector.deposit(from: <-fee)\n      emit FeeCollected(amount: self.outwardFee, type: 0)\n\n      let amount = vault.balance\n      let vaultRef = TeleportCustody.account.borrow<&REVV.Vault>(from: REVV.RevvVaultStoragePath)\n\t\t\t  ?? panic(\"Could not borrow reference to the owner's Vault!\")\n      vaultRef.deposit(from: <- vault)\n      emit TokensTeleportedOut(amount: amount, to: to)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: DelayedTransfer must from same account as addXfer is limited to access(account) to avoid spam"}, {"role": "assistant", "content": "import DelayedTransfer from 0x08dd120226ec2213"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: user deposit into SafeBox, cBridge will mint corresponding ERC20 tokens on specified dest chain.\nwhen user burn ERC20 tokens, cBridge will withdraw FungibleTokens to user specified receiver address"}, {"role": "assistant", "content": "pub contract SafeBox {\n  // path for admin resource\n    pub let AdminPath: StoragePath\n  // ========== events ==========\n  pub event Deposited(\n    depoId: String,\n    depositor: Address,\n    token: String,\n    amount: UFix64,\n    mintChId: UInt64,\n    mintAddr: String,\n    nonce: UInt64\n  )\n\n  pub event Withdrawn(\n    wdId: String,\n    receiver: Address,\n    token: String,\n    amount: UFix64,\n    refChId: UInt64,\n    burnAddr: String,\n    refId: String\n  )\n\n  // ========== structs ==========\n  // token vault type identifier string to its config so we can borrow for deposit/withdraw\n  pub struct TokenCfg {\n    pub let vaultPub: PublicPath\n    pub let vaultSto: StoragePath\n    pub let minDepo: UFix64\n    pub let maxDepo: UFix64\n    // if withdraw amount > delayThreshold, put into delayed transfer map\n    pub let delayThreshold: UFix64\n    // used for volume controller\n    pub let cap: UFix64\n\n    init(vaultPub:PublicPath, vaultSto: StoragePath, minDepo: UFix64, maxDepo: UFix64, delayThreshold: UFix64, cap: UFix64) {\n      self.vaultPub = vaultPub\n      self.vaultSto = vaultSto\n      self.minDepo = minDepo\n      self.maxDepo = maxDepo\n      self.delayThreshold = delayThreshold\n      self.cap = cap\n    }\n  }\n  // info about one user deposit\n  pub struct DepoInfo {\n    pub let amt: UFix64\n    pub let mintChId: UInt64\n    pub let mintAddr: String\n    pub let nonce: UInt64\n\n    init(amt: UFix64, mintChId: UInt64, mintAddr: String, nonce: UInt64) {\n      self.amt = amt\n      self.mintChId = mintChId\n      self.mintAddr = mintAddr\n      self.nonce = nonce\n    }\n  }\n\n  // ========== contract states and maps ==========\n  // unique chainid required by cbridge system\n  pub let chainID: UInt64\n  // domainPrefix to ensure no replay on co-sign msgs\n  access(contract) let domainPrefix: [UInt8]\n  // similar to solidity pausable\n  pub var isPaused: Bool\n\n  // key is token vault identifier, eg. A.1122334455667788.ExampleToken.Vault\n  access(account) var tokMap: {String: TokenCfg}\n  // save for each deposit/withdraw to avoid duplicated process\n  // key is calculated depoId or wdId\n  access(account) var records: {String: Bool}\n\n  pub fun getTokenConfig(identifier: String): TokenCfg {\n    let tokenCfg = self.tokMap[identifier]!\n    return tokenCfg\n  }\n\n  pub fun recordExist(id: String): Bool {\n    return self.records.containsKey(id)\n  }\n\n  // ========== resource ==========\n  pub resource SafeBoxAdmin {\n    pub fun addTok(identifier: String, tok: TokenCfg) {\n      assert(!SafeBox.tokMap.containsKey(identifier), message: \"this token already exist\")\n      SafeBox.tokMap[identifier] = tok\n    }\n\n    pub fun rmTok(identifier: String) {\n      assert(SafeBox.tokMap.containsKey(identifier), message: \"this token do not exist\")\n      SafeBox.tokMap.remove(key: identifier)\n    }\n\n    pub fun pause() {\n      SafeBox.isPaused = true\n      DelayedTransfer.pause()\n    }\n    pub fun unPause() {\n      SafeBox.isPaused = false\n      DelayedTransfer.unPause()\n    }\n\n    pub fun createSafeBoxAdmin(): @SafeBoxAdmin {\n        return <-create SafeBoxAdmin()\n    }\n  }\n\n  // ========== functions ==========\n  // chainid must be same as cbridge common proto FLOW_MAINNET = 12340001; FLOW_TEST = 12340002;\n  init(chID:UInt64) {\n    self.chainID = chID\n    // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.SafeBox\".utf8, xxxx is this contract account\n    self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n    self.isPaused = false\n\n    self.records = {}\n    self.tokMap = {}\n\n    self.AdminPath = /storage/SafeBoxAdmin\n    self.account.save<@SafeBoxAdmin>(<- create SafeBoxAdmin(), to: self.AdminPath)\n  }\n\n  pub fun deposit(from: &AnyResource{FungibleToken.Provider}, info:DepoInfo) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    let user = from.owner!.address\n    let tokStr = from.getType().identifier\n    let tokenCfg = self.tokMap[tokStr]!\n    assert(info.amt >= tokenCfg.minDepo, message: \"deposit amount less than min deposit\")\n    if tokenCfg.maxDepo > 0.0 {\n      assert(info.amt < tokenCfg.maxDepo, message: \"deposit amount larger than max deposit\")\n    }\n    // calculate depoId\n    let concatStr = user.toString().concat(tokStr).concat(info.amt.toString()).concat(info.nonce.toString())\n    let depoId = String.encodeHex(HashAlgorithm.SHA3_256.hash(concatStr.utf8))\n    assert(!self.records.containsKey(depoId), message: \"depoId already exists\")\n    self.records[depoId] = true\n\n    let recev = self.account.getCapability(tokenCfg.vaultPub).borrow<&AnyResource{FungibleToken.Receiver}>()\n                      ?? panic(\"Could not borrow a reference to the receiver\")\n    recev.deposit(from: <-from.withdraw(amount: info.amt))\n    emit Deposited(\n      depoId: depoId,\n      depositor: user,\n      token: tokStr,\n      amount: info.amt,\n      mintChId: info.mintChId,\n      mintAddr: info.mintAddr,\n      nonce: info.nonce\n    )\n  }\n\n  // we can also use recipient: &AnyResource{FungibleToken.Receiver} to do deposit.\n  // but now, we use the tokCfg pubPath to get the Receiver first.\n  pub fun withdraw(token: String, wdmsg: [UInt8], sigs: [cBridge.SignerSig]) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    // calculate correct data by prefix domain, sgn needs to sign the same way\n    let domain = self.domainPrefix.concat(\"Withdraw\".utf8)\n    assert(cBridge.verify(data: domain.concat(wdmsg), sigs: sigs), message: \"verify sigs failed\")\n    let wdInfo = PbPegged.Withdraw(wdmsg)\n    assert(wdInfo.eqToken(tkStr: token), message: \"mismatch token string\")\n    // calculate wdId and check records map\n    // withdraw from self storage\n    // and deposit into receiver\n    // emit Withdrawn\n    let tokCfg = SafeBox.tokMap[token] ?? panic(\"token not support in contract\")\n    VolumeControl.updateVolume(token: token, amt: wdInfo.amount, cap: tokCfg.cap)\n    let wdId = String.encodeHex(HashAlgorithm.SHA3_256.hash(wdmsg))\n\n    assert(!self.records.containsKey(wdId), message: \"wdId already exists\")\n    self.records[wdId] = true\n    let receiverCap = getAccount(wdInfo.receiver).getCapability<&{FungibleToken.Receiver}>(tokCfg.vaultPub)\n    let vaultRef = self.account.borrow<&{FungibleToken.Provider}>(from: tokCfg.vaultSto) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n    // vault that holds to deposit ft\n    let vault <- vaultRef.withdraw(amount: wdInfo.amount)\n\n    if wdInfo.amount > tokCfg.delayThreshold {\n      // add to delayed xfer\n      DelayedTransfer.addDelayXfer(id: wdId, receiverCap: receiverCap, from: <- vault)\n    } else {\n      let receiverRef = receiverCap.borrow() ?? panic(\"Could not borrow a reference to the receiver\")\n      // deposit into receiver\n      receiverRef.deposit(from: <- vault)\n    }\n    // emit withdrawn even added to delay, to be consistent with solidity\n    emit Withdrawn(\n      wdId: wdId,\n      receiver: wdInfo.receiver,\n      token: token,\n      amount: wdInfo.amount,\n      refChId: wdInfo.refChainId,\n      burnAddr: wdInfo.burnAccount,\n      refId: wdInfo.refId\n    )\n  }\n\n  pub fun executeDelayedTransfer(wdId: String) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    DelayedTransfer.executeDelayXfer(wdId)\n  }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: path for admin resource"}, {"role": "assistant", "content": "pub let AdminPath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "pub event Deposited(\n    depoId: String,\n    depositor: Address,\n    token: String,\n    amount: UFix64,\n    mintChId: UInt64,\n    mintAddr: String,\n    nonce: UInt64\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "(\n    depoId: String,\n    depositor: Address,\n    token: String,\n    amount: UFix64,\n    mintChId: UInt64,\n    mintAddr: String,\n    nonce: UInt64\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== structs ==========\ntoken vault type identifier string to its config so we can borrow for deposit/withdraw"}, {"role": "assistant", "content": "pub struct TokenCfg {\n    pub let vaultPub: PublicPath\n    pub let vaultSto: StoragePath\n    pub let minDepo: UFix64\n    pub let maxDepo: UFix64\n    // if withdraw amount > delayThreshold, put into delayed transfer map\n    pub let delayThreshold: UFix64\n    // used for volume controller\n    pub let cap: UFix64\n\n    init(vaultPub:PublicPath, vaultSto: StoragePath, minDepo: UFix64, maxDepo: UFix64, delayThreshold: UFix64, cap: UFix64) {\n      self.vaultPub = vaultPub\n      self.vaultSto = vaultSto\n      self.minDepo = minDepo\n      self.maxDepo = maxDepo\n      self.delayThreshold = delayThreshold\n      self.cap = cap\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: if withdraw amount > delayThreshold, put into delayed transfer map"}, {"role": "assistant", "content": "pub let delayThreshold: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: used for volume controller"}, {"role": "assistant", "content": "pub let cap: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: info about one user deposit"}, {"role": "assistant", "content": "pub struct DepoInfo {\n    pub let amt: UFix64\n    pub let mintChId: UInt64\n    pub let mintAddr: String\n    pub let nonce: UInt64\n\n    init(amt: UFix64, mintChId: UInt64, mintAddr: String, nonce: UInt64) {\n      self.amt = amt\n      self.mintChId = mintChId\n      self.mintAddr = mintAddr\n      self.nonce = nonce\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== contract states and maps ==========\nunique chainid required by cbridge system"}, {"role": "assistant", "content": "pub let chainID: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: domainPrefix to ensure no replay on co-sign msgs"}, {"role": "assistant", "content": "access(contract) let domainPrefix: [UInt8]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: similar to solidity pausable"}, {"role": "assistant", "content": "pub var isPaused: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: key is token vault identifier, eg. A.1122334455667788.ExampleToken.Vault"}, {"role": "assistant", "content": "access(account) var tokMap: {String: TokenCfg}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: save for each deposit/withdraw to avoid duplicated process\nkey is calculated depoId or wdId"}, {"role": "assistant", "content": "access(account) var records: {String: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== resource =========="}, {"role": "assistant", "content": "pub resource SafeBoxAdmin {\n    pub fun addTok(identifier: String, tok: TokenCfg) {\n      assert(!SafeBox.tokMap.containsKey(identifier), message: \"this token already exist\")\n      SafeBox.tokMap[identifier] = tok\n    }\n\n    pub fun rmTok(identifier: String) {\n      assert(SafeBox.tokMap.containsKey(identifier), message: \"this token do not exist\")\n      SafeBox.tokMap.remove(key: identifier)\n    }\n\n    pub fun pause() {\n      SafeBox.isPaused = true\n      DelayedTransfer.pause()\n    }\n    pub fun unPause() {\n      SafeBox.isPaused = false\n      DelayedTransfer.unPause()\n    }\n\n    pub fun createSafeBoxAdmin(): @SafeBoxAdmin {\n        return <-create SafeBoxAdmin()\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== functions ==========\nchainid must be same as cbridge common proto FLOW_MAINNET = 12340001; FLOW_TEST = 12340002;"}, {"role": "assistant", "content": "init(chID:UInt64) {\n    self.chainID = chID\n    // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.SafeBox\".utf8, xxxx is this contract account\n    self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n    self.isPaused = false\n\n    self.records = {}\n    self.tokMap = {}\n\n    self.AdminPath = /storage/SafeBoxAdmin\n    self.account.save<@SafeBoxAdmin>(<- create SafeBoxAdmin(), to: self.AdminPath)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: we can also use recipient: &AnyResource{FungibleToken.Receiver} to do deposit.\nbut now, we use the tokCfg pubPath to get the Receiver first."}, {"role": "assistant", "content": "pub fun withdraw(token: String, wdmsg: [UInt8], sigs: [cBridge.SignerSig]) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    // calculate correct data by prefix domain, sgn needs to sign the same way\n    let domain = self.domainPrefix.concat(\"Withdraw\".utf8)\n    assert(cBridge.verify(data: domain.concat(wdmsg), sigs: sigs), message: \"verify sigs failed\")\n    let wdInfo = PbPegged.Withdraw(wdmsg)\n    assert(wdInfo.eqToken(tkStr: token), message: \"mismatch token string\")\n    // calculate wdId and check records map\n    // withdraw from self storage\n    // and deposit into receiver\n    // emit Withdrawn\n    let tokCfg = SafeBox.tokMap[token] ?? panic(\"token not support in contract\")\n    VolumeControl.updateVolume(token: token, amt: wdInfo.amount, cap: tokCfg.cap)\n    let wdId = String.encodeHex(HashAlgorithm.SHA3_256.hash(wdmsg))\n\n    assert(!self.records.containsKey(wdId), message: \"wdId already exists\")\n    self.records[wdId] = true\n    let receiverCap = getAccount(wdInfo.receiver).getCapability<&{FungibleToken.Receiver}>(tokCfg.vaultPub)\n    let vaultRef = self.account.borrow<&{FungibleToken.Provider}>(from: tokCfg.vaultSto) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n    // vault that holds to deposit ft\n    let vault <- vaultRef.withdraw(amount: wdInfo.amount)\n\n    if wdInfo.amount > tokCfg.delayThreshold {\n      // add to delayed xfer\n      DelayedTransfer.addDelayXfer(id: wdId, receiverCap: receiverCap, from: <- vault)\n    } else {\n      let receiverRef = receiverCap.borrow() ?? panic(\"Could not borrow a reference to the receiver\")\n      // deposit into receiver\n      receiverRef.deposit(from: <- vault)\n    }\n    // emit withdrawn even added to delay, to be consistent with solidity\n    emit Withdrawn(\n      wdId: wdId,\n      receiver: wdInfo.receiver,\n      token: token,\n      amount: wdInfo.amount,\n      refChId: wdInfo.refChainId,\n      burnAddr: wdInfo.burnAccount,\n      refId: wdInfo.refId\n    )\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "pub event EpochLengthUpdated(length: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "(length: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== admin resource =========="}, {"role": "assistant", "content": "pub resource Admin {\n    pub fun setEpochLength(newLength: UInt64) {\n      VolumeControl.epochLength = newLength\n      emit EpochLengthUpdated(\n        length: newLength\n      )\n    }\n\n    // createNewAdmin creates a new Admin resource\n    pub fun createNewAdmin(): @Admin {\n      return <-create Admin()\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewAdmin creates a new Admin resource"}, {"role": "assistant", "content": "pub fun createNewAdmin(): @Admin {\n      return <-create Admin()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== functions =========="}, {"role": "assistant", "content": "init() {\n    self.epochLength = 0\n    self.epochVolumes = {}\n    self.lastOpTimestamps = {}\n    self.AdminPath = /storage/VolumeControlAdmin\n    self.account.save<@Admin>(<- create Admin(), to: self.AdminPath)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: only need to support signer verify for now"}, {"role": "assistant", "content": "pub contract cBridge {\n\n    pub event SignersUpdated(\n      signers: {String: UInt256}\n    )\n\n    // path for admin resource\n    pub let AdminPath: StoragePath\n    // unique chainid required by cbridge system\n    pub let chainID: UInt64\n    access(contract) let domainPrefix: [UInt8]\n    // save map from pubkey to power, only visible in this contract to extra safety\n    access(contract) var signers: {String: UInt256}\n    pub var totalPower: UInt256\n    // block height when signers are last updated by sigs\n    // flow block.timestamp is UFix64 so hard to use\n    pub var signerUpdateBlock: UInt64\n\n    // at first we require pubkey to be also present in SignerSig, so verify can just do map lookup in signers\n    // but this make other components in the system to be aware of pubkeys which is hard to do\n    // so without pubkey, we just loop over all signers and call verify, it's less efficient but won't be an issue\n    // as there won't be many signers. we keep struct for future flexibility but pubkey field is NOT needed.\n    pub struct SignerSig {\n        pub let sig: [UInt8]\n        init(sig: [UInt8]) {\n            self.sig = sig\n        }\n    }\n\n    // Admin is a special authorization resource that \n    // allows the owner to perform important functions to modify the contract state\n    pub resource BridgeAdmin {\n        pub fun resetSigners(signers: {String: UInt256}) {\n            cBridge.signers = signers\n            cBridge.totalPower = 0\n            for power in signers.values {\n                cBridge.totalPower = cBridge.totalPower + power\n            }\n            emit SignersUpdated(\n              signers: signers\n            )\n        }\n        pub fun createBridgeAdmin(): @BridgeAdmin {\n            return <-create BridgeAdmin()\n        }\n    }\n\n    // getter for signers/power as self.signers is not accessible outside contract\n    pub fun getSigners(): {String: UInt256} {\n        return self.signers\n    }\n\n    // return true if sigs have more than 2/3 total power\n    pub fun verify(data:[UInt8], sigs: [SignerSig]): Bool {\n        var signedPower: UInt256 = 0\n        var quorum: UInt256 = (self.totalPower*2)/3 + 1\n        // go over all known signers, for each signer, try to find which sig matches\n        for pubkey in self.signers.keys {\n            let pk = PublicKey(\n                    publicKey: pubkey.decodeHex(),\n                    signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1\n            )\n            // for this pk, try to find the matched sig\n            // flow doc says `for index, element in array` but it's only in master https://github.com/onflow/cadence/issues/1230\n            var idx = 0\n            for ss in sigs {\n                if pk.verify(\n                    signature: ss.sig,\n                    signedData: data,\n                    domainSeparationTag: \"FLOW-V0.0-user\",\n                    hashAlgorithm: HashAlgorithm.SHA3_256\n                ) {\n                    signedPower = signedPower + self.signers[pubkey]!\n                    if signedPower >= quorum {\n                        return true\n                    }\n                    // delete ss from sigs\n                    sigs.remove(at: idx)\n                    // now we break the sig loop to check next signer as we only allow one sig per signer\n                    break\n                }\n                idx = idx + 1\n            }\n        }\n        return false\n    }\n\n    init(chID:UInt64) {\n      self.chainID = chID\n      // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.cBridge\".utf8, xxxx is this contract account\n      self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n  \n      self.signers = {}\n      self.totalPower = 0\n\n      self.signerUpdateBlock = 0\n\n      self.AdminPath = /storage/cBridgeAdmin\n      self.account.save<@BridgeAdmin>(<- create BridgeAdmin(), to: self.AdminPath)\n    }\n\n    // below are struct and func needed to update cBridge.signers by cosigned msg\n    // blockheight is like nonce to avoid replay attack\n    /* proto definition\n    message PbSignerPowerMap {\n        uint64 blockheight = 1; // block when this pb was proposed by sgn, must < currentblock\n        repeated SignerPower = 2;\n    }\n    message SignerPower {\n        bytes pubkey = 1; // raw bytes of pubkey, 64 bytes\n        bytes power = 2; // big.Int.Bytes\n    }\n    */\n    pub struct PbSignerPowerMap {\n        pub var blockheight: UInt64\n        pub let signerMap: {String: UInt256}\n        pub var totalPower: UInt256\n        // raw is serialized PbSignerPowerMap\n        init(_ raw: [UInt8]) {\n            self.blockheight = 0\n            self.signerMap = {}\n            self.totalPower = 0\n            // now decode pbraw and assign\n            let buf = Pb.Buffer(raw)\n            while buf.hasMore() {\n              let tagType = buf.decKey()\n              switch Int(tagType.tag) {\n                case 1:\n                  assert(tagType.wt==Pb.WireType.Varint, message: \"wrong wire type\")\n                  self.blockheight = buf.decVarint()\n                case 2:\n                  assert(tagType.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  // now decode SignerPower msg\n                  // pegbridge.pb.go, as the proto code show, repeated field has a key outside\n                  let tag0 = buf.decKey()\n                  let tag1 = buf.decKey()\n                  assert(tag1.tag==1, message: \"tag not 1: \".concat(tag1.tag.toString()))\n                  assert(tag1.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  let pbhex = Pb.toString(buf.decBytes())\n                  let tag2 = buf.decKey()\n                  assert(tag2.tag==2, message: \"tag not 2: \".concat(tag2.tag.toString()))\n                  assert(tag2.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  let power = Pb.toUInt256(buf.decBytes())\n                  // add to map\n                  self.signerMap[pbhex] = power\n                  self.totalPower = self.totalPower + power\n                default:\n                  assert(false, message: \"unsupported tag\")\n              }\n            }\n        }\n    }\n    // new signers can be updated if cosigned by existing signers w/ 2/3 power\n    // pbmsg is serialized PbSignerPowerMap\n    access(account) fun updateSigners(pbmsg:[UInt8], sigs: [SignerSig]) {\n      let domain = self.domainPrefix.concat(\".UpdateSigners\".utf8)\n      assert(self.verify(data: domain.concat(pbmsg), sigs: sigs), message: \"verify sigs failed\")\n      let newSigners = PbSignerPowerMap(pbmsg)\n      assert(newSigners.totalPower > 0, message: \"total power must > 0\")\n      assert(newSigners.blockheight > self.signerUpdateBlock, message: \"new signer timestamp must be larger\")\n      assert(newSigners.blockheight <= getCurrentBlock().height, message: \"new signer timestamp must <= current\")\n      // update signerUpdateBlock and signers\n      self.signerUpdateBlock = getCurrentBlock().height\n      self.totalPower = newSigners.totalPower\n      self.signers = newSigners.signerMap\n\n      emit SignersUpdated(\n        signers: newSigners.signerMap\n      )\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: unique chainid required by cbridge system"}, {"role": "assistant", "content": "pub let chainID: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: save map from pubkey to power, only visible in this contract to extra safety"}, {"role": "assistant", "content": "access(contract) var signers: {String: UInt256}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: block height when signers are last updated by sigs\nflow block.timestamp is UFix64 so hard to use"}, {"role": "assistant", "content": "pub var signerUpdateBlock: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: at first we require pubkey to be also present in SignerSig, so verify can just do map lookup in signers\nbut this make other components in the system to be aware of pubkeys which is hard to do\nso without pubkey, we just loop over all signers and call verify, it's less efficient but won't be an issue\nas there won't be many signers. we keep struct for future flexibility but pubkey field is NOT needed."}, {"role": "assistant", "content": "pub struct SignerSig {\n        pub let sig: [UInt8]\n        init(sig: [UInt8]) {\n            self.sig = sig\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is a special authorization resource that\nallows the owner to perform important functions to modify the contract state"}, {"role": "assistant", "content": "pub resource BridgeAdmin {\n        pub fun resetSigners(signers: {String: UInt256}) {\n            cBridge.signers = signers\n            cBridge.totalPower = 0\n            for power in signers.values {\n                cBridge.totalPower = cBridge.totalPower + power\n            }\n            emit SignersUpdated(\n              signers: signers\n            )\n        }\n        pub fun createBridgeAdmin(): @BridgeAdmin {\n            return <-create BridgeAdmin()\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getter for signers/power as self.signers is not accessible outside contract"}, {"role": "assistant", "content": "pub fun getSigners(): {String: UInt256} {\n        return self.signers\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: return true if sigs have more than 2/3 total power"}, {"role": "assistant", "content": "pub fun verify(data:[UInt8], sigs: [SignerSig]): Bool {\n        var signedPower: UInt256 = 0\n        var quorum: UInt256 = (self.totalPower*2)/3 + 1\n        // go over all known signers, for each signer, try to find which sig matches\n        for pubkey in self.signers.keys {\n            let pk = PublicKey(\n                    publicKey: pubkey.decodeHex(),\n                    signatureAlgorithm: SignatureAlgorithm.ECDSA_secp256k1\n            )\n            // for this pk, try to find the matched sig\n            // flow doc says `for index, element in array` but it's only in master https://github.com/onflow/cadence/issues/1230\n            var idx = 0\n            for ss in sigs {\n                if pk.verify(\n                    signature: ss.sig,\n                    signedData: data,\n                    domainSeparationTag: \"FLOW-V0.0-user\",\n                    hashAlgorithm: HashAlgorithm.SHA3_256\n                ) {\n                    signedPower = signedPower + self.signers[pubkey]!\n                    if signedPower >= quorum {\n                        return true\n                    }\n                    // delete ss from sigs\n                    sigs.remove(at: idx)\n                    // now we break the sig loop to check next signer as we only allow one sig per signer\n                    break\n                }\n                idx = idx + 1\n            }\n        }\n        return false\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: raw is serialized PbSignerPowerMap"}, {"role": "assistant", "content": "init(_ raw: [UInt8]) {\n            self.blockheight = 0\n            self.signerMap = {}\n            self.totalPower = 0\n            // now decode pbraw and assign\n            let buf = Pb.Buffer(raw)\n            while buf.hasMore() {\n              let tagType = buf.decKey()\n              switch Int(tagType.tag) {\n                case 1:\n                  assert(tagType.wt==Pb.WireType.Varint, message: \"wrong wire type\")\n                  self.blockheight = buf.decVarint()\n                case 2:\n                  assert(tagType.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  // now decode SignerPower msg\n                  // pegbridge.pb.go, as the proto code show, repeated field has a key outside\n                  let tag0 = buf.decKey()\n                  let tag1 = buf.decKey()\n                  assert(tag1.tag==1, message: \"tag not 1: \".concat(tag1.tag.toString()))\n                  assert(tag1.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  let pbhex = Pb.toString(buf.decBytes())\n                  let tag2 = buf.decKey()\n                  assert(tag2.tag==2, message: \"tag not 2: \".concat(tag2.tag.toString()))\n                  assert(tag2.wt==Pb.WireType.LengthDelim, message: \"wrong wire type\")\n                  let power = Pb.toUInt256(buf.decBytes())\n                  // add to map\n                  self.signerMap[pbhex] = power\n                  self.totalPower = self.totalPower + power\n                default:\n                  assert(false, message: \"unsupported tag\")\n              }\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: new signers can be updated if cosigned by existing signers w/ 2/3 power\npbmsg is serialized PbSignerPowerMap"}, {"role": "assistant", "content": "access(account) fun updateSigners(pbmsg:[UInt8], sigs: [SignerSig]) {\n      let domain = self.domainPrefix.concat(\".UpdateSigners\".utf8)\n      assert(self.verify(data: domain.concat(pbmsg), sigs: sigs), message: \"verify sigs failed\")\n      let newSigners = PbSignerPowerMap(pbmsg)\n      assert(newSigners.totalPower > 0, message: \"total power must > 0\")\n      assert(newSigners.blockheight > self.signerUpdateBlock, message: \"new signer timestamp must be larger\")\n      assert(newSigners.blockheight <= getCurrentBlock().height, message: \"new signer timestamp must <= current\")\n      // update signerUpdateBlock and signers\n      self.signerUpdateBlock = getCurrentBlock().height\n      self.totalPower = newSigners.totalPower\n      self.signers = newSigners.signerMap\n\n      emit SignersUpdated(\n        signers: newSigners.signerMap\n      )\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "pub event DelayedTransferAdded(id: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "(id: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== structs ==========\n/ one delayed transfer info, will release if current block.timestamp >= info.blockTs + delayPeriod"}, {"role": "assistant", "content": "pub struct Info {\n    // block.timestamp when this xfer is added\n    pub let blockTs: UFix64\n    // .borrow then .deposit\n    pub let receiverCap: Capability<&AnyResource{FungibleToken.Receiver}>\n\n    init(blockTs: UFix64, receiverCap: Capability<&AnyResource{FungibleToken.Receiver}>){\n      self.blockTs = blockTs\n      self.receiverCap = receiverCap\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: block.timestamp when this xfer is added"}, {"role": "assistant", "content": "pub let blockTs: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: .borrow then .deposit"}, {"role": "assistant", "content": "pub let receiverCap: Capability<&AnyResource{FungibleToken.Receiver}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== contract states and maps ==========\nhow many seconds for delayed transfer to wait,\ndefault is 3600*24 = 86400, can be changed by Admin"}, {"role": "assistant", "content": "pub var delayPeriod: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: map from unique ID string to Info struct and from vault, have to keep fromVault separate as struct can't include Resource\nand Capability can only be acquired by path which doesn't exist in mint case"}, {"role": "assistant", "content": "access(account) var infoMap: {String: Info}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: when SafeBox/PegBridge is paused, this will also be paused"}, {"role": "assistant", "content": "pub var isPaused: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== resource =========="}, {"role": "assistant", "content": "pub resource Admin {\n    pub fun setDelayPeriod(newP: UInt64) {\n      DelayedTransfer.delayPeriod = newP\n      emit DelayPeriodUpdated(\n        period: newP\n      )\n    }\n    // createNewAdmin creates a new Admin resource\n    pub fun createNewAdmin(): @Admin {\n      return <-create Admin()\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== functions =========="}, {"role": "assistant", "content": "init() {\n    self.delayPeriod = 86400\n    self.infoMap = {}\n    self.vaultMap <- {}\n    self.isPaused = false\n    self.AdminPath = /storage/DelayedTransferAdmin\n    self.account.save<@Admin>(<- create Admin(), to: self.AdminPath)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: only accessible by contracts in the same account to avoid spam (storage cost and valid ids)"}, {"role": "assistant", "content": "access(account) fun addDelayXfer(id: String, receiverCap: Capability<&AnyResource{FungibleToken.Receiver}>, from: @FungibleToken.Vault) {\n    pre {\n      !self.infoMap.containsKey(id): \"id already exists!\"\n      !self.vaultMap.containsKey(id): \"id already exists!\"\n    }\n    self.infoMap[id] = Info(blockTs: getCurrentBlock().timestamp, receiverCap: receiverCap)\n    let old <- self.vaultMap[id] <- from\n    destroy old\n    emit DelayedTransferAdded(id: id)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: execute xfer, if id is found in infoMap and block is big enough, deposit fund to receiver\nwe must restrict to account because if safebox/pegbridge contracts are paused, this can't be called either\nnote if only one contract is paused, we pause all executeDelayXfer for safety"}, {"role": "assistant", "content": "access(account) fun executeDelayXfer(_ wdId: String) {\n    pre {\n      !self.isPaused: \"delay transfer is paused\"\n      self.infoMap.containsKey(wdId): \"wdId not found!\"\n      self.vaultMap.containsKey(wdId): \"wdId not found!\"\n    }\n    let xfer = self.infoMap[wdId]!\n    assert(getCurrentBlock().timestamp > xfer.blockTs+UFix64(self.delayPeriod), message: \"delayed transfer still locked\")\n    // delete from map so no re-trigger\n    self.infoMap.remove(key: wdId)\n    let recRef = xfer.receiverCap.borrow() ?? panic(\"Could not borrow reference to receiver\")\n    let fromVault <- self.vaultMap.remove(key: wdId)!\n    let tokStr = fromVault.getType().identifier\n    let amt = fromVault.balance\n    recRef.deposit(from: <- fromVault)\n    emit DelayedTransferExecuted(\n      id: wdId,\n      receiver: recRef.owner!.address,\n      token: tokStr,\n      amount: amt\n    )\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / only support Varint and LengthDelim for now"}, {"role": "assistant", "content": "pub enum WireType: UInt8 {\n    pub case Varint\n    pub case Fixed64\n    pub case LengthDelim\n    pub case StartGroup\n    pub case EndGroup\n    pub case Fixed32\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: if idx >= b.length, means we're done"}, {"role": "assistant", "content": "pub fun hasMore(): Bool {\n      return self.idx < self.b.length\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: has to use struct as cadence can has only single return"}, {"role": "assistant", "content": "pub fun decKey(): TagType {\n      let v = self.decVarint()\n      return TagType(tag: v/8, wt: UInt8(v % 8) )\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: modify self.idx"}, {"role": "assistant", "content": "pub fun decVarint(): UInt64 {\n      var ret: UInt64 = 0\n      // zero-copy for lower gas cost even though it may not matter\n      var i = 0\n      while i < 10 { // varint max 10 bytes\n        let b = self.b[self.idx+i]\n        ret = ret | UInt64(b & 0x7F) << UInt64(i * 7)\n          if (b < 0x80) {\n              self.idx = self.idx + i + 1;\n              return ret;\n          }\n        i = i + 1\n      }\n      assert(i<10, message: \"invalid varint\")\n      return ret\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: modify self.idx"}, {"role": "assistant", "content": "pub fun decBytes(): [UInt8] {\n      let len = self.decVarint()\n      let end = self.idx + Int(len)\n      assert(end <= self.b.length, message: \"invalid bytes length: \".concat(end.toString()))\n      // array slice is https://github.com/onflow/cadence/pull/1315/files\n      // return self.b.slice(from: self.Idx, upTo: end)\n      var ret: [UInt8] = []\n      while self.idx < end {\n        ret.append(self.b[self.idx])\n        self.idx = self.idx + 1\n      }\n      return ret\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: raw is UInt64 big endian, raw.length <= 8"}, {"role": "assistant", "content": "pub fun toUInt64(_ raw: [UInt8]): UInt64 {\n    let rawLen = raw.length\n    assert(rawLen<=8, message: \"invalid raw length for UInt64\")\n    var ret: UInt64 = 0\n    var i = 0\n    while i < rawLen {\n      let val = UInt64(raw[rawLen - 1 - i]) << UInt64(i*8)\n      ret = ret + val\n      i = i + 1\n    }\n    return ret\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: raw is UInt256 big endian, raw.length <= 32"}, {"role": "assistant", "content": "pub fun toUInt256(_ raw: [UInt8]): UInt256 {\n    let rawLen = raw.length\n    assert(rawLen<=32, message: \"invalid raw length for UInt256\")\n    var ret: UInt256 = 0\n    var i = 0\n    while i < rawLen {\n      let val = UInt256(raw[rawLen - 1 - i]) << UInt256(i*8)\n      ret = ret + val\n      i = i + 1\n    }\n    return ret\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / return hex string!"}, {"role": "assistant", "content": "pub fun toString(_ raw: [UInt8]): String {\n    return String.encodeHex(raw)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: compare tkStr.utf8 equals self.token"}, {"role": "assistant", "content": "pub fun eqToken(tkStr:String): Bool {\n      let tk = tkStr.utf8\n      if tk.length == self.token.length {\n        var i = 0;\n        while i < tk.length {\n          if tk[i] != self.token[i] {\n            return false\n          }\n          i = i + 1\n        }\n        return true\n      }\n      return false\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / PegBridge support mint via co-signed message, and burn, will call corresponding PegToken contract\n/ Account of this contract must has Minter/Burner resource for corresponding PegToken\n/ interfaces/resources in FTMinterBurner are needed to avoid token specific types"}, {"role": "assistant", "content": "import FungibleToken from 0xf233dcee88fe0abe"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: FTMinterBurner is needed for mint/burn"}, {"role": "assistant", "content": "import FTMinterBurner from 0x08dd120226ec2213"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: path for FTMinterBurnerMap resource"}, {"role": "assistant", "content": "pub let FTMBMapPath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "pub event Mint(\n    mintId: String,\n    receiver: Address,\n    token: String,\n    amount: UFix64,\n    refChId: UInt64,\n    refId: String,\n    depositor: String\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== events =========="}, {"role": "assistant", "content": "(\n    mintId: String,\n    receiver: Address,\n    token: String,\n    amount: UFix64,\n    refChId: UInt64,\n    refId: String,\n    depositor: String\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== structs ==========\ntoken vault type identifier string to its config so we can borrow to deposit minted token"}, {"role": "assistant", "content": "pub struct TokenCfg {\n    pub let vaultPub: PublicPath\n    pub let minBurn: UFix64\n    pub let maxBurn: UFix64\n    // if mint amount > delayThreshold, put into delayed transfer map\n    pub let delayThreshold: UFix64\n    // used for volume controller\n    pub let cap: UFix64\n\n    init(vaultPub:PublicPath, minBurn: UFix64, maxBurn: UFix64, delayThreshold: UFix64, cap: UFix64) {\n      self.vaultPub = vaultPub\n      self.minBurn = minBurn\n      self.maxBurn = maxBurn\n      self.delayThreshold = delayThreshold\n      self.cap = cap\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: if mint amount > delayThreshold, put into delayed transfer map"}, {"role": "assistant", "content": "pub let delayThreshold: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: info about one user burn"}, {"role": "assistant", "content": "pub struct BurnInfo {\n    pub let amt: UFix64\n    pub let toChId: UInt64\n    pub let toAddr: String\n    pub let nonce: UInt64\n\n    init(amt: UFix64, toChId: UInt64, toAddr: String, nonce: UInt64) {\n      self.amt = amt\n      self.toChId = toChId\n      self.toAddr = toAddr\n      self.nonce = nonce\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: save for each mint/burn to avoid duplicated process\nkey is calculated mintID or burnID"}, {"role": "assistant", "content": "access(account) var records: {String: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== resources =========="}, {"role": "assistant", "content": "pub resource PegBridgeAdmin {\n    pub fun addTok(identifier: String, tok: TokenCfg) {\n      assert(!PegBridge.tokMap.containsKey(identifier), message: \"this token already exist\")\n      PegBridge.tokMap[identifier] = tok\n    }\n\n    pub fun rmTok(identifier: String) {\n      assert(PegBridge.tokMap.containsKey(identifier), message: \"this token do not exist\")\n      PegBridge.tokMap.remove(key: identifier)\n    }\n\n    pub fun pause() {\n      PegBridge.isPaused = true\n      DelayedTransfer.pause()\n    }\n    pub fun unPause() {\n      PegBridge.isPaused = false\n      DelayedTransfer.unPause()\n    }\n\n    pub fun createPegBridgeAdmin(): @PegBridgeAdmin {\n        return <-create PegBridgeAdmin()\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: token admin must create minter/burner resource and call add"}, {"role": "assistant", "content": "pub resource interface IAddMinter {\n    pub fun addMinter(minter: @FTMinterBurner.Minter)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / MinterBurnerMap support public add minter/burner by token admin,\n/ del minter/burner by account, and mint/burn corresponding ft\n/ when called by this contract"}, {"role": "assistant", "content": "pub resource MinterBurnerMap: IAddMinter, IAddBurner {\n    // map from token vault identifier to minter or burner resource\n    access(account) var hasMinters: @{String: FTMinterBurner.Minter}\n    access(account) var hasBurners: @{String: FTMinterBurner.Burner}\n\n    // called by token admin\n    pub fun addMinter(minter: @FTMinterBurner.Minter) {\n      let idStr = minter.getType().identifier\n      let newIdStr = idStr.slice(from: 0, upTo: idStr.length - 6).concat(\"Vault\")\n      // only supported token minter can be added\n      assert(PegBridge.tokMap.containsKey(newIdStr), message: \"this token not support\")\n\n      let oldMinter <- self.hasMinters[newIdStr] <- minter\n      destroy oldMinter\n    }\n    pub fun addBurner(burner: @FTMinterBurner.Burner) {\n      let idStr = burner.getType().identifier\n      let newIdStr = idStr.slice(from: 0, upTo: idStr.length - 6).concat(\"Vault\")\n      // only supported token burner can be added\n      assert(PegBridge.tokMap.containsKey(newIdStr), message: \"this token not support\")\n      let old <- self.hasBurners[newIdStr] <- burner\n      destroy old\n    }\n\n    // func in this contract or func of other contract in this account can call this as not exposed by public path, other contracts under\n    access(account) fun delMinter(idStr: String) {\n      let minter <- self.hasMinters.remove(key: idStr) ?? panic(\"missing Minter\")\n      destroy minter\n    }\n    access(account) fun delBurner(idStr: String) {\n      let burner <- self.hasBurners.remove(key: idStr) ?? panic(\"missing Burner\")\n      destroy burner\n    }\n\n    // for extra security, only this contract can call mint/burn\n    access(contract) fun mint(id:String, amt: UFix64): @FungibleToken.Vault {\n      let minter = (&self.hasMinters[id] as &FTMinterBurner.Minter?)!\n      return <- minter.mintTokens(amount: amt)\n    }\n    access(contract) fun burn(id:String, from: @FungibleToken.Vault) {\n      let burner = (&self.hasBurners[id] as &FTMinterBurner.Burner?)!\n      burner.burnTokens(from: <- from)\n    }\n    init(){\n      self.hasMinters <- {}\n      self.hasBurners <- {}\n    }\n    destroy() {\n      destroy self.hasMinters\n      destroy self.hasBurners\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: map from token vault identifier to minter or burner resource"}, {"role": "assistant", "content": "access(account) var hasMinters: @{String: FTMinterBurner.Minter}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: called by token admin"}, {"role": "assistant", "content": "pub fun addMinter(minter: @FTMinterBurner.Minter) {\n      let idStr = minter.getType().identifier\n      let newIdStr = idStr.slice(from: 0, upTo: idStr.length - 6).concat(\"Vault\")\n      // only supported token minter can be added\n      assert(PegBridge.tokMap.containsKey(newIdStr), message: \"this token not support\")\n\n      let oldMinter <- self.hasMinters[newIdStr] <- minter\n      destroy oldMinter\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: func in this contract or func of other contract in this account can call this as not exposed by public path, other contracts under"}, {"role": "assistant", "content": "access(account) fun delMinter(idStr: String) {\n      let minter <- self.hasMinters.remove(key: idStr) ?? panic(\"missing Minter\")\n      destroy minter\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: for extra security, only this contract can call mint/burn"}, {"role": "assistant", "content": "access(contract) fun mint(id:String, amt: UFix64): @FungibleToken.Vault {\n      let minter = (&self.hasMinters[id] as &FTMinterBurner.Minter?)!\n      return <- minter.mintTokens(amount: amt)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ========== functions =========="}, {"role": "assistant", "content": "init(chID:UInt64) {\n    self.chainID = chID\n    // domainPrefix is chainID big endianbytes followed by \"A.xxxxxx.PegBridge\".utf8, xxxx is this contract account\n    self.domainPrefix = chID.toBigEndianBytes().concat(self.getType().identifier.utf8)\n    self.isPaused = false\n\n    self.records = {}\n    self.tokMap = {}\n\n    self.AdminPath = /storage/PegBridgeAdmin\n    self.account.save<@PegBridgeAdmin>(<- create PegBridgeAdmin(), to: self.AdminPath)\n\n    self.FTMBMapPath = /storage/FTMinterBurnerMap\n    // needed for minter/burner\n    self.account.save(<-create MinterBurnerMap(), to: self.FTMBMapPath)\n    // anyone can call /public/AddMinter to add a minter to map\n    self.account.link<&MinterBurnerMap{IAddMinter}>(/public/AddMinter, target: self.FTMBMapPath)\n    self.account.link<&MinterBurnerMap{IAddBurner}>(/public/AddBurner, target: self.FTMBMapPath)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: large amount mint"}, {"role": "assistant", "content": "pub fun executeDelayedTransfer(mintId: String) {\n    pre {\n      !self.isPaused: \"contract is paused\"\n    }\n    DelayedTransfer.executeDelayXfer(mintId)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: and event emitted when somebody follows another user"}, {"role": "assistant", "content": "pub event Follow(follower:Address, following: Address, tags: [String])"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: and event emitted when somebody follows another user"}, {"role": "assistant", "content": "(follower:Address, following: Address, tags: [String])"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: an event emitted when somebody unfollows somebody"}, {"role": "assistant", "content": "pub event Unfollow(follower:Address, unfollowing: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: an event emitted when somebody unfollows somebody"}, {"role": "assistant", "content": "(follower:Address, unfollowing: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: and event emitted when a user verifies something"}, {"role": "assistant", "content": "pub event Verification(account:Address, message:String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: and event emitted when a user verifies something"}, {"role": "assistant", "content": "(account:Address, message:String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: validate length of description to be 255 or something?"}, {"role": "assistant", "content": "pub fun setDescription(_ val: String) {\n\t\t\tpre {\n\t\t\t\tval.length <= 1024: \"Description must be 1024 characters or less\"\n\t\t\t}\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Verify that this user has signed something."}, {"role": "assistant", "content": "pub fun verify(_ val:String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A user must be able to remove a follower since this data in your account is added there by another user"}, {"role": "assistant", "content": "pub fun removeFollower(_ val: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: manage bans"}, {"role": "assistant", "content": "pub fun addBan(_ val: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Set if user is allowed to store followers or now"}, {"role": "assistant", "content": "pub fun setAllowStoringFollowers(_ val: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: set if this user prefers sensitive information about his account to be kept private, no guarantee here but should be honored"}, {"role": "assistant", "content": "pub fun setPrivateMode(_ val: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: this is just a bag of properties if we need more fields here, so that we can do it with contract upgrade"}, {"role": "assistant", "content": "access(self) var additionalProperties: {String : String}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / We do not have a seperate field for this so we use the additionalProperties 'bag' to store this in"}, {"role": "assistant", "content": "pub fun setPrivateMode(_ val: Bool) {\n\t\t\tvar private=\"true\"\n\t\t\tif !val{\n\t\t\t\tprivate=\"false\"\n\t\t\t}\n\t\t\tself.additionalProperties[\"privateMode\"]  = private\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / This is just an empty resource we create in storage, you can safely send a reference to it to obtain msg.sender"}, {"role": "assistant", "content": "pub resource Accounts: Public {\n\n\n\t\taccess(self) let accounts: { String: AccountInformation}\n\n\t\tpub fun getFlowAccounts() : {String: Address} {\n\t\t\tlet items : {String: Address} ={}\n\t\t\tfor account in self.accounts.keys {\n\t\t\t\tlet item = self.accounts[account]!\n\t\t\t\tif item.network == \"Flow\" {\n\t\t\t\t\titems[item.name]=item.address!\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn items\n\t\t}\n\n\t\tpub fun setFlowAccount(name: String, address:Address) {\n\t\t\tself.accounts[name] = AccountInformation(name: name, address:address, network: \"Flow\", otherAddress:\"\")\n\t\t\temit RelatedFlowAccountAdded(name:name, address: self.owner!.address, related:address)\n\t\t}\n\n\t\tpub fun deleteAccount(name: String) {\n\t\t\tlet item =self.accounts.remove(key: name)!\n\t\t\tif item.network == \"Flow\" {\n\t\t\t\temit RelatedFlowAccountRemoved(name:name,address: self.owner!.address, related: item.address!)\n\t\t\t}\n\t\t}\n\n\t\tinit() {\n\t\t\tself.accounts={}\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / This is just an empty resource we create in storage, you can safely send a reference to it to obtain msg.sender"}, {"role": "assistant", "content": "pub resource Token { }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The public interface can show metadata and the content for the Art piece"}, {"role": "assistant", "content": "pub resource interface Public {\n\t\tpub let id: UInt64\n\t\tpub fun getMetadata() : {String : String}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Standard NFT collectionPublic interface that can also borrowArt as the correct type"}, {"role": "assistant", "content": "pub resource interface CollectionPublic {\n\n\t\tpub fun deposit(token: @NonFungibleToken.NFT)\n\t\tpub fun getIDs(): [UInt64]\n\t\tpub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n\t\tpub fun borrowCharity(id: UInt64): &{Public}?\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: dictionary of NFT conforming tokens\nNFT is a resource type with an `UInt64` ID field"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an NFT from the collection and moves it to the caller"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\t\t\tlet token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n\t\t\temit Withdraw(id: token.id, from: self.owner?.address)\n\n\t\t\treturn <-token\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a NFT and adds it to the collections dictionary\nand adds the ID to the id array"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n\t\t\tlet token <- token as! @CharityNFT.NFT\n\n\t\t\tlet id: UInt64 = token.id\n\n\t\t\t// add the new token to the dictionary which removes the old one\n\t\t\tlet oldToken <- self.ownedNFTs[id] <- token\n\n\t\t\temit Deposit(id: id, to: self.owner?.address)\n\n\t\t\tdestroy oldToken\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getIDs returns an array of the IDs that are in the collection"}, {"role": "assistant", "content": "pub fun getIDs(): [UInt64] {\n\t\t\treturn self.ownedNFTs.keys\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT gets a reference to an NFT in the collection\nso that the caller can read its metadata and call its methods"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n\t\t\treturn (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrow charity"}, {"role": "assistant", "content": "pub fun borrowCharity(id: UInt64): &{CharityNFT.Public}? {\n\t\t\tif self.ownedNFTs[id] != nil {\n\t\t\t\tlet ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n\t\t\t\treturn ref as! &NFT\n\t\t\t} else {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: public function that anyone can call to create a new empty collection"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n\t\treturn <- create Collection()\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintNFT mints a new NFT with a new ID\nand deposit it in the recipients collection using their collection reference"}, {"role": "assistant", "content": "access(account) fun mintCharity(metadata: {String:String}, recipient: Capability<&{NonFungibleToken.CollectionPublic}>) {\n\n\t\t// create a new NFT\n\t\tvar newNFT <- create NFT(initID: CharityNFT.totalSupply, metadata:metadata)\n\n\t\t// deposit it in the recipient's account using their reference\n\t\trecipient.borrow()!.deposit(token: <-newNFT)\n\t\temit Minted(id: CharityNFT.totalSupply, metadata:metadata, to: recipient.address)\n\n\t\tCharityNFT.totalSupply = CharityNFT.totalSupply + 1 \n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: want to mock time on emulator."}, {"role": "assistant", "content": "access(contract) var fakeClock:UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mocking the time! Should probably remove self.fakeClock in mainnet?"}, {"role": "assistant", "content": "pub fun time() : UFix64 {\n\t\tif self.enabled {\n\t\t\treturn self.fakeClock \n\t\t}\n\t\treturn getCurrentBlock().timestamp\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: event when FT is sent"}, {"role": "assistant", "content": "pub event FungibleTokenSent(from:Address, fromName:String?, name:String, toAddress:Address, message:String, tag:String, amount: UFix64, type:Type)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: event when FT is sent"}, {"role": "assistant", "content": "(from:Address, fromName:String?, name:String, toAddress:Address, message:String, tag:String, amount: UFix64, type:Type)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / An event to singla that there is a name in the network"}, {"role": "assistant", "content": "pub event Name(name: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / An event to singla that there is a name in the network"}, {"role": "assistant", "content": "(name: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: /  Emitted when a name is registred in FIND"}, {"role": "assistant", "content": "pub event Register(name: String, owner: Address, validUntil: UFix64, lockedUntil: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: /  Emitted when a name is registred in FIND"}, {"role": "assistant", "content": "(name: String, owner: Address, validUntil: UFix64, lockedUntil: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when a name is moved to a new owner"}, {"role": "assistant", "content": "pub event Moved(name: String, previousOwner: Address, newOwner: Address, validUntil: UFix64, lockedUntil: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when a name is moved to a new owner"}, {"role": "assistant", "content": "(name: String, previousOwner: Address, newOwner: Address, validUntil: UFix64, lockedUntil: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when a name is sold to a new owner"}, {"role": "assistant", "content": "pub event Sold(name: String, previousOwner: Address, newOwner: Address, validUntil: UFix64, lockedUntil: UFix64, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when a name is sold to a new owner"}, {"role": "assistant", "content": "(name: String, previousOwner: Address, newOwner: Address, validUntil: UFix64, lockedUntil: UFix64, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when a name is explicistly put up for sale"}, {"role": "assistant", "content": "pub event ForSale(name: String, owner: Address, validUntil: UFix64, lockedUntil: UFix64, directSellPrice: UFix64, active: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when a name is explicistly put up for sale"}, {"role": "assistant", "content": "(name: String, owner: Address, validUntil: UFix64, lockedUntil: UFix64, directSellPrice: UFix64, active: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when an name is put up for on-demand auction"}, {"role": "assistant", "content": "pub event ForAuction(name: String, owner: Address, validUntil: UFix64, lockedUntil: UFix64,  auctionStartPrice: UFix64, auctionReservePrice: UFix64, active: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when an name is put up for on-demand auction"}, {"role": "assistant", "content": "(name: String, owner: Address, validUntil: UFix64, lockedUntil: UFix64,  auctionStartPrice: UFix64, auctionReservePrice: UFix64, active: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if a bid occurs at a name that is too low or not for sale"}, {"role": "assistant", "content": "pub event DirectOffer(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if a bid occurs at a name that is too low or not for sale"}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if a blind bid is canceled"}, {"role": "assistant", "content": "pub event DirectOfferCanceled(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if a blind bid is canceled"}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if a blind bid is rejected"}, {"role": "assistant", "content": "pub event DirectOfferRejected(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String,amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if a blind bid is rejected"}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String,amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if an auction is canceled"}, {"role": "assistant", "content": "pub event AuctionCanceled(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if an auction is canceled"}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if an auction is canceled because it did not reach the reserved price"}, {"role": "assistant", "content": "pub event AuctionCanceledReservePrice(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted if an auction is canceled because it did not reach the reserved price"}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when an auction starts."}, {"role": "assistant", "content": "pub event AuctionStarted(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64, auctionEndAt: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when an auction starts."}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64, auctionEndAt: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when there is a new bid in an auction"}, {"role": "assistant", "content": "pub event AuctionBid(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64, auctionEndAt: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Emitted when there is a new bid in an auction"}, {"role": "assistant", "content": "(name: String, bidder: Address, bidderName: String?, owner:Address, ownerName:String, amount: UFix64, auctionEndAt: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: store bids made by a bidder to somebody elses leases"}, {"role": "assistant", "content": "pub let BidPublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: store the network itself"}, {"role": "assistant", "content": "pub let NetworkStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: store the leases you own"}, {"role": "assistant", "content": "pub let LeaseStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Calculate the cost of an name\n/ @param _ the name to calculate the cost for"}, {"role": "assistant", "content": "pub fun calculateCost(_ name:String) : UFix64 {\n\t\tpre {\n\t\t\tFIND.validateFindName(name) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t}\n\n\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\treturn network.calculateCost(name)\n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Lookup the address registered for a name"}, {"role": "assistant", "content": "pub fun lookupAddress(_ name:String): Address? {\n\t\tpre {\n\t\t\tFIND.validateFindName(name) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t}\n\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\treturn network.lookup(name)?.owner?.address\n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Lookup the profile registered for a name"}, {"role": "assistant", "content": "pub fun lookup(_ name:String): &{Profile.Public}? {\n\t\tpre {\n\t\t\tFIND.validateFindName(name) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t}\n\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\treturn network.lookup(name)\n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / lookup if an address has a .find name, if it does pick either the default one or the first registered"}, {"role": "assistant", "content": "pub fun reverseLookup(_ address:Address): String? {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\tif !leaseCap.check() {\n\t\t\treturn nil\n\t\t}\n\n\t\tlet profile= Profile.find(address).asProfile()\n\t\tlet leases = leaseCap.borrow()!.getLeaseInformation() \n\t\tvar time : UFix64?= nil\n\t\tvar name :String?= nil\n\t\tfor lease in leases {\n\n\t\t\t//filter out all leases that are FREE or LOCKED since they are not actice\n\t\t\tif lease.status != \"TAKEN\" {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t//if we have not set a \n\t\t\tif profile.findName == \"\" {\n\t\t\t\tif time == nil || lease.validUntil < time! {\n\t\t\t\t\ttime=lease.validUntil\n\t\t\t\t\tname=lease.name\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif profile.findName == lease.name {\n\t\t\t\treturn lease.name\n\t\t\t}\n\t\t}\n\t\treturn name\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Deposit FT to name\n/ @param to: The name to send money too\n/ @param message: The message to send\n/ @param tag: The tag to add to the event\n/ @param vault: The vault to send too\n/ @param from: The sender that sent the funds"}, {"role": "assistant", "content": "pub fun depositWithTagAndMessage(to:String, message:String, tag: String, vault: @FungibleToken.Vault, from: &Sender.Token) {\n\t\tpre {\n\t\t\tFIND.validateFindName(to) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t}\n\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\tlet profile=network.lookup(to) ?? panic(\"could not find name\")\n\t\t\tlet fromAddress= from.owner!.address\n\t\t\temit FungibleTokenSent(from: fromAddress, fromName: FIND.reverseLookup(fromAddress), name: to, toAddress: profile.asProfile().address, message:message, tag:tag, amount:vault.balance, type:vault.getType()) \n\t\t\tprofile.deposit(from: <- vault)\n\t\t\treturn \n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Deposit FT to name\n/ @param to: The name to send money too\n/ @param from: The vault to send too"}, {"role": "assistant", "content": "pub fun deposit(to:String, from: @FungibleToken.Vault) {\n\t\tpre {\n\t\t\tFIND.validateFindName(to) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t}\n\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\tlet profile=network.lookup(to) ?? panic(\"could not find name\")\n\t\t\tprofile.deposit(from: <- from)\n\t\t\treturn \n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Return the status for a given name\n/ @return The Name status of a name"}, {"role": "assistant", "content": "pub fun status(_ name: String): NameStatus {\n\t\tpre {\n\t\t\tFIND.validateFindName(name) : \"A FIND name has to be lower-cased alphanumeric or dashes and between 3 and 16 characters\"\n\t\t}\n\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\treturn network.readStatus(name)\n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Struct holding information about a lease. Contains both the internal status the owner of the lease and if the state is persisted or not."}, {"role": "assistant", "content": "pub struct NameStatus{\n\t\tpub let status: LeaseStatus\n\t\tpub let owner: Address?\n\n\t\tinit(status:LeaseStatus, owner:Address?) {\n\t\t\tself.status=status\n\t\t\tself.owner=owner\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: struct to expose information about leases"}, {"role": "assistant", "content": "pub struct LeaseInformation {\n\t\tpub let name: String\n\t\tpub let address: Address\n\t\tpub let cost: UFix64\n\t\tpub let status: String\n\t\tpub let validUntil: UFix64\n\t\tpub let lockedUntil: UFix64\n\t\tpub let latestBid: UFix64?\n\t\tpub let auctionEnds: UFix64?\n\t\tpub let salePrice: UFix64?\n\t\tpub let latestBidBy: Address?\n\t\tpub let currentTime: UFix64\n\t\tpub let auctionStartPrice: UFix64?\n\t\tpub let auctionReservePrice: UFix64?\n\t\tpub let extensionOnLateBid: UFix64?\n\t\tpub let addons: [String]\n\n\t\tinit(name: String, status:LeaseStatus, validUntil: UFix64, lockedUntil:UFix64, latestBid: UFix64?, auctionEnds: UFix64?, salePrice: UFix64?, latestBidBy: Address?, auctionStartPrice: UFix64?, auctionReservePrice: UFix64?, extensionOnLateBid:UFix64?, address:Address, addons: [String]){\n\n\t\t\tself.name=name\n\t\t\tvar s=\"TAKEN\"\t\n\t\t\tif status == LeaseStatus.FREE {\n\t\t\t\ts=\"FREE\"\n\t\t\t} else if status == LeaseStatus.LOCKED {\n\t\t\t\ts=\"LOCKED\"\n\t\t\t}\n\t\t\tself.status=s\n\t\t\tself.validUntil=validUntil\n\t\t\tself.lockedUntil=lockedUntil\n\t\t\tself.latestBid=latestBid\n\t\t\tself.latestBidBy=latestBidBy\n\t\t\tself.auctionEnds=auctionEnds\n\t\t\tself.salePrice=salePrice\n\t\t\tself.currentTime=Clock.time()\n\t\t\tself.auctionStartPrice=auctionStartPrice\n\t\t\tself.auctionReservePrice=auctionReservePrice\n\t\t\tself.extensionOnLateBid=extensionOnLateBid\n\t\t\tself.address=address\n\t\t\tself.cost=FIND.calculateCost(name)\n\t\t\tself.addons=addons\n\n\t\t}\n\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: fetch all the tokens in the collection"}, {"role": "assistant", "content": "pub fun getLeases(): [String]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: fetch all names that are for sale"}, {"role": "assistant", "content": "pub fun getLeaseInformation() : [LeaseInformation]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: add a new lease token to the collection, can only be called in this contract"}, {"role": "assistant", "content": "access(contract) fun deposit(token: @FIND.Lease"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: place a bid on a token"}, {"role": "assistant", "content": "access(contract) fun registerBid(name: String, callback: Capability<&BidCollection{BidCollectionPublic}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: anybody should be able to fulfill an auction as long as it is done"}, {"role": "assistant", "content": "pub fun fulfillAuction(_ name: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: dictionary of NFT conforming tokens\nNFT is a resource type with an `UInt64` ID field"}, {"role": "assistant", "content": "access(contract) var leases: @{String: FIND.Lease}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the cut the network will take, default 2.5%"}, {"role": "assistant", "content": "access(contract) let networkCut: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the wallet of the network to transfer royalty to"}, {"role": "assistant", "content": "access(contract) let networkWallet: Capability<&{FungibleToken.Receiver}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: call this to start an auction for this lease"}, {"role": "assistant", "content": "pub fun startAuction(_ name: String) {\n\t\t\tlet timestamp=Clock.time()\n\t\t\tlet lease = self.borrow(name)\n\t\t\tlet duration=lease.auctionDuration\n\t\t\tlet extensionOnLateBid=lease.auctionExtensionOnLateBid\n\t\t\tif lease.offerCallback == nil {\n\t\t\t\tpanic(\"cannot start an auction on a name without a bid, set salePrice\")\n\t\t\t}\n\n\t\t\tlet callback=lease.offerCallback!\n\t\t\tlet offer=callback.borrow()!\n\t\t\toffer.setBidType(name: name, type: \"auction\")\n\n\n\n\t\t\tlet bidder= callback.address\n\t\t\tlet bidderName= getAccount(bidder).getCapability<&{Profile.Public}>(Profile.publicPath).borrow()!.getName()\n\t\t\tlet owner=lease.owner!.address\n\t\t\tlet ownerName=lease.getProfile()!.getName()\n\n\t\t\tlet endsAt=timestamp + duration\n\t\t\temit AuctionStarted(name: name, bidder: bidder, bidderName:bidderName, owner:owner, ownerName:ownerName, amount: offer.getBalance(name), auctionEndAt: endsAt)\n\n\t\t\tlet oldAuction <- self.auctions[name] <- create Auction(endsAt:endsAt, startedAt: timestamp, extendOnLateBid: extensionOnLateBid, latestBidCallback: callback, name: name)\n\t\t\tlease.setCallback(nil)\n\n\t\t\tif lease.offerCallback == nil {\n\t\t\t\tDebug.log(\"offer callback is empty\")\n\t\t\t}else {\n\t\t\t\tDebug.log(\"offer callback is NOT empty\")\n\t\t\t}\n\n\t\t\tdestroy oldAuction\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: cancel will cancel and auction or reject a bid if no auction has started"}, {"role": "assistant", "content": "pub fun cancel(_ name: String) {\n\t\t\tpre {\n\t\t\t\tself.leases.containsKey(name) : \"Invalid name=\".concat(name)\n\t\t\t}\n\n\t\t\tlet lease = self.borrow(name)\n\t\t\t//if we have a callback there is no auction and it is a blind bid\n\t\t\tif let cb= lease.offerCallback {\n\n\t\t\t\tlet bidder= cb.address\n\t\t\t\tlet bidderName= getAccount(bidder).getCapability<&{Profile.Public}>(Profile.publicPath).borrow()!.getName()\n\t\t\t\tlet owner=lease.owner!.address\n\t\t\t\tlet ownerName=lease.getProfile()!.getName()\n\t\t\t\tDebug.log(\"we have a blind bid so we cancel that\")\n\t\t\t\temit DirectOfferRejected(name: name, bidder: bidder, bidderName:bidderName, owner:owner, ownerName:ownerName, amount: cb.borrow()!.getBalance(name))\n\t\t\t\tcb.borrow()!.cancel(name)\n\t\t\t\tlease.setCallback(nil)\n\t\t\t}\n\n\t\t\tif self.auctions.containsKey(name) {\n\n\t\t\t\tlet auction=self.borrowAuction(name)\n\t\t\t\tlet balance=auction.getBalance()\n\n\t\t\t\tlet auctionEnded= auction.endsAt <= Clock.time()\n\t\t\t\tvar hasMetReservePrice= false\n\t\t\t\tif lease.auctionReservePrice != nil && lease.auctionReservePrice! <= balance {\n\t\t\t\t\thasMetReservePrice=true\n\t\t\t\t}\n\t\t\t\tlet price= lease.auctionReservePrice?.toString() ?? \"\"\n\t\t\t\t//the auction has ended\n\t\t\t\tDebug.log(\"Latest bid is \".concat(balance.toString()).concat(\" reserve price is \").concat(price))\n\t\t\t\tif auctionEnded && hasMetReservePrice {\n\t\t\t\t\t//&& lease.auctionReservePrice != nil && lease.auctionReservePrice! < balance {\n\t\t\t\t\tpanic(\"Cannot cancel finished auction, fulfill it instead\")\n\t\t\t\t}\n\n\t\t\t\tlet bidder= auction.latestBidCallback.address\n\t\t\t\tlet bidderName= getAccount(bidder).getCapability<&{Profile.Public}>(Profile.publicPath).borrow()!.getName()\n\t\t\t\tlet owner=lease.owner!.address\n\t\t\t\tlet ownerName=lease.getProfile()!.getName()\n\n\t\t\t\tif auctionEnded {\n\t\t\t\t\temit AuctionCanceledReservePrice(name: name, bidder: bidder, bidderName:bidderName, owner:owner, ownerName:ownerName, amount: balance)\n\t\t\t\t} else {\n\t\t\t\t\temit AuctionCanceled(name: name, bidder: bidder, bidderName:bidderName, owner:owner, ownerName:ownerName, amount: balance)\n\t\t\t\t}\n\t\t\t\tauction.latestBidCallback.borrow()!.cancel(name)\n\t\t\t\tdestroy <- self.auctions.remove(key: name)!\n\t\t\t}\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / fulfillAuction wraps the fulfill method and ensure that only a finished auction can be fulfilled by anybody"}, {"role": "assistant", "content": "pub fun fulfillAuction(_ name: String) {\n\t\t\tpre {\n\t\t\t\tself.leases.containsKey(name) : \"Invalid name=\".concat(name)\n\t\t\t\tself.auctions.containsKey(name) : \"Cannot fulfill sale that is not an auction=\".concat(name)\n\t\t\t}\n\n\t\t\treturn self.fulfill(name)\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: note that when moving a name"}, {"role": "assistant", "content": "pub fun move(name: String, profile: Capability<&{Profile.Public}>, to: Capability<&LeaseCollection{LeaseCollectionPublic}>) {\n\t\t\tlet token <- self.leases.remove(key:  name) ?? panic(\"missing NFT\")\n\t\t\temit Moved(name: name, previousOwner:self.owner!.address, newOwner: profile.address, validUntil: token.getLeaseExpireTime(), lockedUntil: token.getLeaseLockedUntil())\n\t\t\temit Register(name: name, owner:profile.address, validUntil: token.getLeaseExpireTime(), lockedUntil: token.getLeaseLockedUntil())\n\t\t\ttoken.move(profile: profile)\n\t\t\tto.borrow()!.deposit(token: <- token)\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: depoit a lease token into the lease collection, not available from the outside"}, {"role": "assistant", "content": "access(contract) fun deposit(token: @FIND.Lease) {\n\t\t\t// add the new token to the dictionary which removes the old one\n\t\t\tlet oldToken <- self.leases[token.name] <- token\n\n\t\t\tdestroy oldToken\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getIDs returns an array of the IDs that are in the collection"}, {"role": "assistant", "content": "pub fun getLeases(): [String] {\n\t\t\treturn self.leases.keys\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT gets a reference to an NFT in the collection\nso that the caller can read its metadata and call its methods"}, {"role": "assistant", "content": "pub fun borrow(_ name: String): &FIND.Lease {\n\t\t\treturn (&self.leases[name] as &FIND.Lease?)!\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrow the auction"}, {"role": "assistant", "content": "pub fun borrowAuction(_ name: String): &FIND.Auction {\n\t\t\treturn (&self.auctions[name] as &FIND.Auction?)!\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This has to be here since you can only get this from a auth account and thus we ensure that you cannot use wrong paths"}, {"role": "assistant", "content": "pub fun register(name: String, vault: @FUSD.Vault){\n\t\t\tlet profileCap = self.owner!.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\t\tlet leases= self.owner!.getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\t\tlet network=FIND.account.borrow<&Network>(from: FIND.NetworkStoragePath)!\n\n\t\t\tif !network.publicEnabled {\n\t\t\t\tpanic(\"Public registration is not enabled yet\")\n\t\t\t}\n\n\t\t\tnetwork.register(name:name, vault: <- vault, profile: profileCap, leases: leases)\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create an empty lease collection that store your leases to a name"}, {"role": "assistant", "content": "pub fun createEmptyLeaseCollection(): @FIND.LeaseCollection {\n\t\tif let network = self.account.borrow<&Network>(from: FIND.NetworkStoragePath) {\n\t\t\treturn <- create LeaseCollection(networkCut:network.secondaryCut, networkWallet: network.wallet)\n\t\t}\n\t\tpanic(\"Network is not set up\")\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: a struct that represents a lease of a name in the network."}, {"role": "assistant", "content": "pub struct NetworkLease {\n\t\tpub let registeredTime: UFix64\n\t\tpub var validUntil: UFix64\n\t\tpub var lockedUntil: UFix64\n\t\tpub(set) var profile: Capability<&{Profile.Public}>\n\t\tpub var address: Address\n\t\tpub var name: String\n\n\t\tinit( validUntil:UFix64, lockedUntil:UFix64, profile: Capability<&{Profile.Public}>, name: String) {\n\t\t\tself.validUntil=validUntil\n\t\t\tself.lockedUntil=lockedUntil\n\t\t\tself.registeredTime=Clock.time()\n\t\t\tself.profile=profile\n\t\t\tself.address= profile.address\n\t\t\tself.name=name\n\t\t}\n\n\t\tpub fun setValidUntil(_ unit: UFix64) {\n\t\t\tself.validUntil=unit\n\t\t}\n\n\t\tpub fun setLockedUntil(_ unit: UFix64) {\n\t\t\tself.lockedUntil=unit\n\t\t}\n\n\t\tpub fun status() : LeaseStatus {\n\t\t\tlet time=Clock.time()\n\n\t\t\tif time >= self.lockedUntil {\n\t\t\t\treturn LeaseStatus.FREE\n\t\t\t}\n\n\t\t\tif time >= self.validUntil {\n\t\t\t\treturn LeaseStatus.LOCKED\n\t\t\t}\n\t\t\treturn \tLeaseStatus.TAKEN\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: map from name to lease for that name"}, {"role": "assistant", "content": "access(contract) let profiles: { String: NetworkLease}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: this method is only called from a lease, and only the owner has that capability"}, {"role": "assistant", "content": "access(contract) fun renew(name: String, vault: @FUSD.Vault) {\n\t\t\tif let lease= self.profiles[name] {\n\n\t\t\t\tvar newTime=0.0\n\t\t\t\tif lease.status() == LeaseStatus.TAKEN {\n\t\t\t\t\t//the name is taken but not expired so we extend the total period of the lease\n\t\t\t\t\tlease.setValidUntil(lease.validUntil + self.leasePeriod)\n\t\t\t\t} else {\n\t\t\t\t\tlease.setValidUntil(Clock.time() + self.leasePeriod)\n\t\t\t\t}\n\t\t\t\tlease.setLockedUntil(lease.validUntil+ self.lockPeriod)\n\n\t\t\t\tlet cost= self.calculateCost(name)\n\t\t\t\tif vault.balance != cost {\n\t\t\t\t\tpanic(\"Vault did not contain \".concat(cost.toString()).concat(\" amount of FUSD\"))\n\t\t\t\t}\n\t\t\t\tself.wallet.borrow()!.deposit(from: <- vault)\n\n\t\t\t\temit Register(name: name, owner:lease.profile.address, validUntil: lease.validUntil, lockedUntil: lease.lockedUntil)\n\t\t\t\tself.profiles[name] =  lease\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpanic(\"Could not find profile with name=\".concat(name))\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: moving leases are done from the lease collection"}, {"role": "assistant", "content": "access(contract) fun move(name: String, profile: Capability<&{Profile.Public}>) {\n\t\t\tif let lease= self.profiles[name] {\n\t\t\t\tlease.profile=profile\n\t\t\t\tself.profiles[name] = lease\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpanic(\"Could not find profile with name=\".concat(name))\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: everybody can call register, normally done through the convenience method in the contract"}, {"role": "assistant", "content": "pub fun register(name: String, vault: @FUSD.Vault, profile: Capability<&{Profile.Public}>,  leases: Capability<&LeaseCollection{LeaseCollectionPublic}>) {\n\t\t\tpre {\n\t\t\t\tname.length >= 3 : \"A FIND name has to be minimum 3 letters long\"\n\t\t\t}\n\n\t\t\tlet nameStatus=self.readStatus(name)\n\t\t\tif nameStatus.status == LeaseStatus.TAKEN {\n\t\t\t\tpanic(\"Name already registered\")\n\t\t\t}\n\n\t\t\t//if we have a locked profile that is not owned by the same identity then panic\n\t\t\tif nameStatus.status == LeaseStatus.LOCKED {\n\t\t\t\tpanic(\"Name is locked\")\n\t\t\t}\n\n\t\t\tlet cost= self.calculateCost(name)\n\t\t\tif vault.balance != cost {\n\t\t\t\tpanic(\"Vault did not contain \".concat(cost.toString()).concat(\" amount of FUSD\"))\n\t\t\t}\n\t\t\tself.wallet.borrow()!.deposit(from: <- vault)\n\n\t\t\tself.internal_register(name: name, profile: profile, leases: leases)\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: lookup a name that is not locked"}, {"role": "assistant", "content": "pub fun lookup(_ name: String) : &{Profile.Public}? {\n\t\t\tlet nameStatus=self.readStatus(name)\n\t\t\tif nameStatus.status != LeaseStatus.TAKEN {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif let lease=self.profiles[name] {\n\t\t\t\treturn lease.profile.borrow()\n\t\t\t}\n\t\t\treturn nil\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Struct that is used to return information about bids"}, {"role": "assistant", "content": "pub struct BidInfo{\n\t\tpub let name: String\n\t\tpub let type: String\n\t\tpub let amount: UFix64\n\t\tpub let timestamp: UFix64\n\t\tpub let lease: LeaseInformation?\n\n\t\tinit(name: String, amount: UFix64, timestamp: UFix64, type: String, lease: LeaseInformation?) {\n\t\t\tself.name=name\n\t\t\tself.amount=amount\n\t\t\tself.timestamp=timestamp\n\t\t\tself.type=type\n\t\t\tself.lease=lease\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A collection stored for bidders/buyers"}, {"role": "assistant", "content": "pub resource BidCollection: BidCollectionPublic {\n\n\t\taccess(contract) var bids : @{String: Bid}\n\t\taccess(contract) let receiver: Capability<&{FungibleToken.Receiver}>\n\t\taccess(contract) let leases: Capability<&LeaseCollection{LeaseCollectionPublic}>\n\n\t\tinit(receiver: Capability<&{FungibleToken.Receiver}>, leases: Capability<&LeaseCollection{LeaseCollectionPublic}>) {\n\t\t\tself.bids <- {}\n\t\t\tself.receiver=receiver\n\t\t\tself.leases=leases\n\t\t}\n\n\t\t//called from lease when auction is ended\n\t\t//if purchase if fulfilled then we deposit money back into vault we get passed along and token into your own leases collection\n\t\taccess(contract) fun fulfillLease(_ token: @FIND.Lease) : @FungibleToken.Vault{\n\n\t\t\tlet bid <- self.bids.remove(key: token.name) ?? panic(\"missing bid\")\n\n\t\t\tlet vaultRef = &bid.vault as &FungibleToken.Vault\n\n\t\t\ttoken.setSalePrice(nil)\n\t\t\ttoken.setCallback(nil)\n\t\t\ttoken.setReservePrice(nil)\n\t\t\ttoken.setStartAuctionPrice(nil)\n\t\t\tself.leases.borrow()!.deposit(token: <- token)\n\t\t\tlet vault  <- vaultRef.withdraw(amount: vaultRef.balance)\n\t\t\tdestroy bid\n\t\t\treturn <- vault\n\t\t}\n\n\t\t//called from lease when things are canceled\n\t\t//if the bid is canceled from seller then we move the vault tokens back into your vault\n\t\taccess(contract) fun cancel(_ name: String) {\n\t\t\tlet bid <- self.bids.remove(key: name) ?? panic(\"missing bid\")\n\t\t\tlet vaultRef = &bid.vault as &FungibleToken.Vault\n\t\t\tself.receiver.borrow()!.deposit(from: <- vaultRef.withdraw(amount: vaultRef.balance))\n\t\t\tdestroy bid\n\t\t}\n\n\t\tpub fun getBids() : [BidInfo] {\n\t\t\tvar bidInfo: [BidInfo] = []\n\t\t\tfor id in self.bids.keys {\n\t\t\t\tlet bid = self.borrowBid(id)\n\t\t\t\tlet leaseCollection= bid.from.borrow() ?? panic(\"Could not borrow lease bid from owner of name=\".concat(bid.name))\n\t\t\t\tbidInfo.append(BidInfo(name: bid.name, amount: bid.vault.balance, timestamp: bid.bidAt, type: bid.type, lease: leaseCollection.getLease(bid.name)))\n\t\t\t}\n\t\t\treturn bidInfo\n\t\t}\n\n\t\t//make a bid on a name\n\t\tpub fun bid(name: String, vault: @FUSD.Vault) {\n\t\t\tlet nameStatus=FIND.status(name)\n\t\t\tif nameStatus.status ==  LeaseStatus.FREE {\n\t\t\t\tpanic(\"cannot bid on name that is free\")\n\t\t\t}\n\n\t\t\tif self.owner!.address == nameStatus.owner {\n\t\t\t\tpanic(\"cannot bid on your own name\")\n\t\t\t}\n\n\t\t\tlet from=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\t\tlet bid <- create Bid(from: from, name:name, vault: <- vault)\n\t\t\tlet leaseCollection= from.borrow() ?? panic(\"Could not borrow lease bid from owner of name=\".concat(name))\n\n\n\t\t\tlet callbackCapability =self.owner!.getCapability<&BidCollection{BidCollectionPublic}>(FIND.BidPublicPath)\n\t\t\tlet oldToken <- self.bids[bid.name] <- bid\n\t\t\t//send info to leaseCollection\n\t\t\tdestroy oldToken\n\t\t\tleaseCollection.registerBid(name: name, callback: callbackCapability) \n\t\t}\n\n\n\t\t//increase a bid, will not work if the auction has already started\n\t\tpub fun increaseBid(name: String, vault: @FungibleToken.Vault) {\n\t\t\tlet nameStatus=FIND.status(name)\n\t\t\tif nameStatus.status ==  LeaseStatus.FREE {\n\t\t\t\tpanic(\"cannot increaseBid on name that is free\")\n\t\t\t}\n\t\t\tlet seller=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\t\tlet balance = vault.balance\n\t\t\tlet bid =self.borrowBid(name)\n\t\t\tbid.setBidAt(Clock.time())\n\t\t\tbid.vault.deposit(from: <- vault)\n\n\t\t\tlet from=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\t\tfrom.borrow()!.increaseBid(name, balance: balance)\n\t\t}\n\n\t\t//cancel a bid, will panic if called after auction has started\n\t\tpub fun cancelBid(_ name: String) {\n\n\t\t\tlet nameStatus=FIND.status(name)\n\t\t\tif nameStatus.status == LeaseStatus.FREE {\n\t\t\t\tself.cancel(name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlet from=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\t\tfrom.borrow()!.cancelUserBid(name)\n\t\t\tself.cancel(name)\n\t\t}\n\n\t\tpub fun borrowBid(_ name: String): &Bid {\n\t\t\treturn (&self.bids[name] as &Bid?)!\n\t\t}\n\n\t\taccess(contract) fun setBidType(name: String, type: String) {\n\t\t\tlet bid= self.borrowBid(name)\n\t\t\tbid.setType(type)\n\t\t}\n\n\t\tpub fun getBalance(_ name: String) : UFix64 {\n\t\t\tlet bid= self.borrowBid(name)\n\t\t\treturn bid.vault.balance\n\t\t}\n\n\t\tdestroy() {\n\t\t\tdestroy self.bids\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: called from lease when auction is ended\nif purchase if fulfilled then we deposit money back into vault we get passed along and token into your own leases collection"}, {"role": "assistant", "content": "access(contract) fun fulfillLease(_ token: @FIND.Lease) : @FungibleToken.Vault{\n\n\t\t\tlet bid <- self.bids.remove(key: token.name) ?? panic(\"missing bid\")\n\n\t\t\tlet vaultRef = &bid.vault as &FungibleToken.Vault\n\n\t\t\ttoken.setSalePrice(nil)\n\t\t\ttoken.setCallback(nil)\n\t\t\ttoken.setReservePrice(nil)\n\t\t\ttoken.setStartAuctionPrice(nil)\n\t\t\tself.leases.borrow()!.deposit(token: <- token)\n\t\t\tlet vault  <- vaultRef.withdraw(amount: vaultRef.balance)\n\t\t\tdestroy bid\n\t\t\treturn <- vault\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: called from lease when things are canceled\nif the bid is canceled from seller then we move the vault tokens back into your vault"}, {"role": "assistant", "content": "access(contract) fun cancel(_ name: String) {\n\t\t\tlet bid <- self.bids.remove(key: name) ?? panic(\"missing bid\")\n\t\t\tlet vaultRef = &bid.vault as &FungibleToken.Vault\n\t\t\tself.receiver.borrow()!.deposit(from: <- vaultRef.withdraw(amount: vaultRef.balance))\n\t\t\tdestroy bid\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: make a bid on a name"}, {"role": "assistant", "content": "pub fun bid(name: String, vault: @FUSD.Vault) {\n\t\t\tlet nameStatus=FIND.status(name)\n\t\t\tif nameStatus.status ==  LeaseStatus.FREE {\n\t\t\t\tpanic(\"cannot bid on name that is free\")\n\t\t\t}\n\n\t\t\tif self.owner!.address == nameStatus.owner {\n\t\t\t\tpanic(\"cannot bid on your own name\")\n\t\t\t}\n\n\t\t\tlet from=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\t\tlet bid <- create Bid(from: from, name:name, vault: <- vault)\n\t\t\tlet leaseCollection= from.borrow() ?? panic(\"Could not borrow lease bid from owner of name=\".concat(name))\n\n\n\t\t\tlet callbackCapability =self.owner!.getCapability<&BidCollection{BidCollectionPublic}>(FIND.BidPublicPath)\n\t\t\tlet oldToken <- self.bids[bid.name] <- bid\n\t\t\t//send info to leaseCollection\n\t\t\tdestroy oldToken\n\t\t\tleaseCollection.registerBid(name: name, callback: callbackCapability) \n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: increase a bid, will not work if the auction has already started"}, {"role": "assistant", "content": "pub fun increaseBid(name: String, vault: @FungibleToken.Vault) {\n\t\t\tlet nameStatus=FIND.status(name)\n\t\t\tif nameStatus.status ==  LeaseStatus.FREE {\n\t\t\t\tpanic(\"cannot increaseBid on name that is free\")\n\t\t\t}\n\t\t\tlet seller=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\t\tlet balance = vault.balance\n\t\t\tlet bid =self.borrowBid(name)\n\t\t\tbid.setBidAt(Clock.time())\n\t\t\tbid.vault.deposit(from: <- vault)\n\n\t\t\tlet from=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\t\tfrom.borrow()!.increaseBid(name, balance: balance)\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: cancel a bid, will panic if called after auction has started"}, {"role": "assistant", "content": "pub fun cancelBid(_ name: String) {\n\n\t\t\tlet nameStatus=FIND.status(name)\n\t\t\tif nameStatus.status == LeaseStatus.FREE {\n\t\t\t\tself.cancel(name)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlet from=getAccount(nameStatus.owner!).getCapability<&LeaseCollection{LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\t\tfrom.borrow()!.cancelUserBid(name)\n\t\t\tself.cancel(name)\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the Garment contract is created"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the Garment contract is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new GarmentData struct is created"}, {"role": "assistant", "content": "pub event GarmentDataCreated(garmentDataID: UInt32, designerAddress: Address, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new GarmentData struct is created"}, {"role": "assistant", "content": "(garmentDataID: UInt32, designerAddress: Address, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Garment is minted"}, {"role": "assistant", "content": "pub event GarmentMinted(garmentID: UInt64, garmentDataID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Garment is minted"}, {"role": "assistant", "content": "(garmentID: UInt64, garmentDataID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a Garment is withdrawn from a Collection"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a Garment is withdrawn from a Collection"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Garment is deposited into a Collection"}, {"role": "assistant", "content": "pub event Deposit(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Garment is deposited into a Collection"}, {"role": "assistant", "content": "(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Garment is destroyed"}, {"role": "assistant", "content": "pub event GarmentDestroyed(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Garment is destroyed"}, {"role": "assistant", "content": "(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Contains standard storage and public paths of resources"}, {"role": "assistant", "content": "pub let CollectionStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of Garment structs"}, {"role": "assistant", "content": "access(self) var garmentDatas: {UInt32: GarmentData}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary with GarmentDataID as key and number of NFTs with GarmentDataID are minted"}, {"role": "assistant", "content": "access(self) var numberMintedPerGarment: {UInt32: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of garmentDataID to  whether they are retired"}, {"role": "assistant", "content": "access(self) var isGarmentDataRetired: {UInt32: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Keeps track of how many unique GarmentData's are created"}, {"role": "assistant", "content": "pub var nextGarmentDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Royalty struct that each GarmentData will contain"}, {"role": "assistant", "content": "pub struct Royalty{\n\n\t\tpub let wallet:Capability<&{FungibleToken.Receiver}> \n        pub let initialCut: UFix64\n\t\tpub let cut: UFix64\n\n\t\t/// @param wallet : The wallet to send royalty too\n\t\tinit(wallet:Capability<&{FungibleToken.Receiver}>, initialCut: UFix64, cut: UFix64){\n\t\t\tself.wallet=wallet\n            self.initialCut= initialCut\n\t\t\tself.cut=cut\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / @param wallet : The wallet to send royalty too"}, {"role": "assistant", "content": "init(wallet:Capability<&{FungibleToken.Receiver}>, initialCut: UFix64, cut: UFix64){\n\t\t\tself.wallet=wallet\n            self.initialCut= initialCut\n\t\t\tself.cut=cut\n\t\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The unique ID for the Garment Data"}, {"role": "assistant", "content": "pub let garmentDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The flow address of the designer"}, {"role": "assistant", "content": "pub let designerAddress: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Other metadata"}, {"role": "assistant", "content": "access(self) let metadata: {String: String}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mapping of royalty name to royalty struct"}, {"role": "assistant", "content": "access(self) let royalty: {String: Royalty}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID of the GarmentData that the Garment references"}, {"role": "assistant", "content": "pub let garmentDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The N'th NFT with 'GarmentDataID' minted"}, {"role": "assistant", "content": "pub let serialNumber: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The resource that represents the Garment NFTs\n"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT {\n\n        // Global unique Garment ID\n        pub let id: UInt64\n\n        // struct of Garment\n        pub let garment: Garment\n\n        init(serialNumber: UInt32, garmentDataID: UInt32) {\n            TheFabricantS1GarmentNFT.totalSupply = TheFabricantS1GarmentNFT.totalSupply + 1\n            \n            self.id = TheFabricantS1GarmentNFT.totalSupply\n\n            self.garment = Garment(garmentDataID: garmentDataID)    \n\n            // Emitted when a Garment is minted\n            emit GarmentMinted(garmentID: self.id, garmentDataID: garmentDataID, serialNumber: serialNumber)\n        }\n\n        destroy() {\n            emit GarmentDestroyed(id: self.id)\n        }\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Global unique Garment ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: struct of Garment"}, {"role": "assistant", "content": "pub let garment: Garment"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is a special authorization resource that\nallows the owner to perform important functions to modify the\nvarious aspects of the Garment and NFTs\n"}, {"role": "assistant", "content": "pub resource Admin {\n\n        pub fun createGarmentData(\n            designerAddress: Address, \n            metadata: {String: String},\n            royalty: {String: Royalty}\n        ): UInt32 {\n            // Create the new GarmentData\n            var newGarment = GarmentData(\n                designerAddress: designerAddress,\n                metadata: metadata,\n                royalty: royalty\n            )\n\n            let newID = newGarment.garmentDataID\n\n            // Store it in the contract storage\n            TheFabricantS1GarmentNFT.garmentDatas[newID] = newGarment\n\n            TheFabricantS1GarmentNFT.numberMintedPerGarment[newID] = 0 as UInt32\n\n            return newID\n        }\n        \n        // createNewAdmin creates a new Admin resource\n        //\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n        // Mint the new Garment\n        pub fun mintNFT(garmentDataID: UInt32): @NFT {\n            let numInGarment = TheFabricantS1GarmentNFT.numberMintedPerGarment[garmentDataID]??\n                panic(\"Cannot mint Garment. garmentData not found\")\n                \n            if (TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID]! == nil) {\n                panic(\"Cannot mint Garment. garmentData not found\")\n            }\n\n            if (TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID]!) {\n                panic(\"Cannot mint garment. garmentDataID retired\")\n            }\n\n            let newGarment: @NFT <- create NFT(serialNumber: numInGarment + 1, garmentDataID: garmentDataID)\n\n            return <-newGarment\n        }\n\n        pub fun batchMintNFT(garmentDataID: UInt32, quantity: UInt64): @Collection {\n            let newCollection <- create Collection()\n\n            var i: UInt64 = 0\n            while i < quantity {\n                newCollection.deposit(token: <-self.mintNFT(garmentDataID: garmentDataID))\n                i = i + 1\n            }\n\n            return <-newCollection\n        }\n\n        // Retire garmentData so that it cannot be used to mint anymore\n        pub fun retireGarmentData(garmentDataID: UInt32) {           \n            pre {\n                TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID] != nil: \"Cannot retire Garment: Garment doesn't exist!\"\n            }\n\n            if !TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID]! {\n                TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID] = true\n\n                emit GarmentDataIDRetired(garmentDataID: garmentDataID)\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createNewAdmin creates a new Admin resource\n"}, {"role": "assistant", "content": "pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint the new Garment"}, {"role": "assistant", "content": "pub fun mintNFT(garmentDataID: UInt32): @NFT {\n            let numInGarment = TheFabricantS1GarmentNFT.numberMintedPerGarment[garmentDataID]??\n                panic(\"Cannot mint Garment. garmentData not found\")\n                \n            if (TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID]! == nil) {\n                panic(\"Cannot mint Garment. garmentData not found\")\n            }\n\n            if (TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID]!) {\n                panic(\"Cannot mint garment. garmentDataID retired\")\n            }\n\n            let newGarment: @NFT <- create NFT(serialNumber: numInGarment + 1, garmentDataID: garmentDataID)\n\n            return <-newGarment\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire garmentData so that it cannot be used to mint anymore"}, {"role": "assistant", "content": "pub fun retireGarmentData(garmentDataID: UInt32) {           \n            pre {\n                TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID] != nil: \"Cannot retire Garment: Garment doesn't exist!\"\n            }\n\n            if !TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID]! {\n                TheFabricantS1GarmentNFT.isGarmentDataRetired[garmentDataID] = true\n\n                emit GarmentDataIDRetired(garmentDataID: garmentDataID)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This is the interface users can cast their Garment Collection as\nto allow others to deposit into their Collection. It also allows for reading\nthe IDs of Garment in the Collection."}, {"role": "assistant", "content": "pub resource interface GarmentCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowGarment(id: UInt64): &TheFabricantS1GarmentNFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id): \n                    \"Cannot borrow Garment reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection is a resource that every user who owns NFTs\nwill store in their account to manage their NFTS\n"}, {"role": "assistant", "content": "pub resource Collection: GarmentCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic { \n        // Dictionary of Garment conforming tokens\n        // NFT is a resource type with a UInt64 ID field\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        // withdraw removes an Garment from the Collection and moves it to the caller\n        //\n        // Parameters: withdrawID: The ID of the NFT \n        // that is to be removed from the Collection\n        //\n        // returns: @NonFungibleToken.NFT the token that was withdrawn\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Garment does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple tokens and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: A collection that contains\n        //                                        the withdrawn Garment\n        //\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit takes a Garment and adds it to the Collections dictionary\n        //\n        // Parameters: token: the NFT to be deposited in the collection\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            // Cast the deposited token as NFT to make sure\n            // it is the correct type\n            let token <- token as! @TheFabricantS1GarmentNFT.NFT\n\n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token tGarment was \"removed\"\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs returns an array of the IDs that are in the Collection\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT Returns a borrowed reference to a Garment in the Collection\n        // so tGarment the caller can read its ID\n        //\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        //\n        // Note: This only allows the caller to read the ID of the NFT,\n        // not an specific data. Please use borrowGarment to \n        // read Garment data.\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        pub fun borrowGarment(id: UInt64): &TheFabricantS1GarmentNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TheFabricantS1GarmentNFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // If a transaction destroys the Collection object,\n        // All the NFTs contained within are also destroyed!\n        //\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of Garment conforming tokens\nNFT is a resource type with a UInt64 ID field"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an Garment from the Collection and moves it to the caller\n\nParameters: withdrawID: The ID of the NFT\nthat is to be removed from the Collection\n\nreturns: @NonFungibleToken.NFT the token that was withdrawn"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Garment does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchWithdraw withdraws multiple tokens and returns them as a Collection\n\nParameters: ids: An array of IDs to withdraw\n\nReturns: @NonFungibleToken.Collection: A collection that contains\nthe withdrawn Garment\n"}, {"role": "assistant", "content": "pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a Garment and adds it to the Collections dictionary\n\nParameters: token: the NFT to be deposited in the collection\n"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            // Cast the deposited token as NFT to make sure\n            // it is the correct type\n            let token <- token as! @TheFabricantS1GarmentNFT.NFT\n\n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token tGarment was \"removed\"\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchDeposit takes a Collection object as an argument\nand deposits each contained NFT into this Collection"}, {"role": "assistant", "content": "pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getIDs returns an array of the IDs that are in the Collection"}, {"role": "assistant", "content": "pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT Returns a borrowed reference to a Garment in the Collection\nso tGarment the caller can read its ID\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT\n\nNote: This only allows the caller to read the ID of the NFT,\nnot an specific data. Please use borrowGarment to\nread Garment data.\n"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Parameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT"}, {"role": "assistant", "content": "pub fun borrowGarment(id: UInt64): &TheFabricantS1GarmentNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TheFabricantS1GarmentNFT.NFT\n            } else {\n                return nil\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: If a transaction destroys the Collection object,\nAll the NFTs contained within are also destroyed!\n"}, {"role": "assistant", "content": "destroy() {\n            destroy self.ownedNFTs\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyCollection creates a new, empty Collection object so that\na user can store it in their account storage.\nOnce they have a Collection in their storage, they are able to receive\nGarment in transactions.\n"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <-create TheFabricantS1GarmentNFT.Collection()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get dictionary of numberMintedPerGarment"}, {"role": "assistant", "content": "pub fun getNumberMintedPerGarment(): {UInt32: UInt32} {\n        return TheFabricantS1GarmentNFT.numberMintedPerGarment\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get how many Garments with garmentDataID are minted"}, {"role": "assistant", "content": "pub fun getGarmentNumberMinted(id: UInt32): UInt32 {\n        let numberMinted = TheFabricantS1GarmentNFT.numberMintedPerGarment[id]??\n            panic(\"garmentDataID not found\")\n        return numberMinted\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the garmentData of a specific id"}, {"role": "assistant", "content": "pub fun getGarmentData(id: UInt32): GarmentData {\n        let garmentData = TheFabricantS1GarmentNFT.garmentDatas[id]??\n            panic(\"garmentDataID not found\")\n        return garmentData\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get all garmentDatas created"}, {"role": "assistant", "content": "pub fun getGarmentDatas(): {UInt32: GarmentData} {\n        return TheFabricantS1GarmentNFT.garmentDatas\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\ninitialization function\n-----------------------------------------------------------------------\n"}, {"role": "assistant", "content": "init() {\n        // Initialize contract fields\n        self.garmentDatas = {}\n        self.numberMintedPerGarment = {}\n        self.nextGarmentDataID = 1\n        self.isGarmentDataRetired = {}\n        self.totalSupply = 0\n        self.CollectionPublicPath = /public/S1GarmentCollection0021\n        self.CollectionStoragePath = /storage/S1GarmentCollection0021\n        self.AdminStoragePath = /storage/S1GarmentAdmin0021\n\n        // Put a new Collection in storage\n        self.account.save<@Collection>(<- create Collection(), to: self.CollectionStoragePath)\n\n        // Create a public capability for the Collection\n        self.account.link<&{GarmentCollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)\n\n        // Put the Minter in storage\n        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)\n\n        emit ContractInitialized()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the Item contract is created"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the Item contract is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new ItemData struct is created"}, {"role": "assistant", "content": "pub event ItemDataCreated(itemDataID: UInt32, coCreator: Address, metadatas: {String: TheFabricantS1ItemNFT.Metadata})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new ItemData struct is created"}, {"role": "assistant", "content": "(itemDataID: UInt32, coCreator: Address, metadatas: {String: TheFabricantS1ItemNFT.Metadata})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a mutable metadata in an itemData is changed"}, {"role": "assistant", "content": "pub event ItemMetadataChanged(itemDataID: UInt32, metadataKey: String, metadataValue: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a mutable metadata in an itemData is changed"}, {"role": "assistant", "content": "(itemDataID: UInt32, metadataKey: String, metadataValue: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a mutable metadata in an itemData is set to immutable"}, {"role": "assistant", "content": "pub event ItemMetadataImmutable(itemDataID: UInt32, metadataKey: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a mutable metadata in an itemData is set to immutable"}, {"role": "assistant", "content": "(itemDataID: UInt32, metadataKey: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an Item is minted"}, {"role": "assistant", "content": "pub event ItemMinted(itemID: UInt64, itemDataID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an Item is minted"}, {"role": "assistant", "content": "(itemID: UInt64, itemDataID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an Item's name is changed"}, {"role": "assistant", "content": "pub event ItemNameChanged(id: UInt64, name: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an Item's name is changed"}, {"role": "assistant", "content": "(id: UInt64, name: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an ItemData is allocated"}, {"role": "assistant", "content": "pub event ItemDataAllocated(garmentDataID: UInt32, materialDataID: UInt32, primaryColor: String, secondaryColor: String, key: String, itemDataID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an ItemData is allocated"}, {"role": "assistant", "content": "(garmentDataID: UInt32, materialDataID: UInt32, primaryColor: String, secondaryColor: String, key: String, itemDataID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the items are set to be splittable"}, {"role": "assistant", "content": "pub event ItemNFTNowSplittable()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the items are set to be splittable"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the number of items with ItemDataID that can be minted changes"}, {"role": "assistant", "content": "pub event numberItemDataMintableChanged(itemDataID: UInt32, number: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the number of items with ItemDataID that can be minted changes"}, {"role": "assistant", "content": "(itemDataID: UInt32, number: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an ItemData is retired"}, {"role": "assistant", "content": "pub event ItemDataIDRetired(itemDataID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an ItemData is retired"}, {"role": "assistant", "content": "(itemDataID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is added to availablePrimaryColors array"}, {"role": "assistant", "content": "pub event PrimaryColorAdded(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is added to availablePrimaryColors array"}, {"role": "assistant", "content": "(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is added to availableSecondaryColors array"}, {"role": "assistant", "content": "pub event SecondaryColorAdded(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is added to availableSecondaryColors array"}, {"role": "assistant", "content": "(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is removed from availablePrimaryColors array"}, {"role": "assistant", "content": "pub event PrimaryColorRemoved(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is removed from availablePrimaryColors array"}, {"role": "assistant", "content": "(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is removed from availableSecondaryColors array"}, {"role": "assistant", "content": "pub event SecondaryColorRemoved(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a color is removed from availableSecondaryColors array"}, {"role": "assistant", "content": "(color: String)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a Item is withdrawn from a Collection"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a Item is withdrawn from a Collection"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Item is deposited into a Collection"}, {"role": "assistant", "content": "pub event Deposit(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Item is deposited into a Collection"}, {"role": "assistant", "content": "(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Item is destroyed"}, {"role": "assistant", "content": "pub event ItemDestroyed(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Item is destroyed"}, {"role": "assistant", "content": "(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: itemDataID: number of NFTs with that ItemDataID are minted"}, {"role": "assistant", "content": "access(self) var numberMintedPerItem: {UInt32: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: itemDataID: how many items with itemData can be minted"}, {"role": "assistant", "content": "access(self) var numberMintablePerItemData: {UInt32: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: itemDataID: itemData struct"}, {"role": "assistant", "content": "access(self) var itemDatas: {UInt32: ItemData}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: concat of garmentDataID_materialDataID_primaryColor_secondaryColor: itemDataID (eg. 1_1_FFFFFF_000000)"}, {"role": "assistant", "content": "access(self) var itemDataAllocation: {String: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: itemDataID: whether item with ItemDataID cannot be minted anymore"}, {"role": "assistant", "content": "access(self) var isItemDataRetired: {UInt32: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: array of available primaryColors"}, {"role": "assistant", "content": "access(self) var availablePrimaryColors: [String]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: array of available secondaryColors"}, {"role": "assistant", "content": "access(self) var availableSecondaryColors: [String]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Keeps track of how many unique ItemDatas are created"}, {"role": "assistant", "content": "pub var nextItemDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Keeps track of how many unique ItemDataAllocations are created"}, {"role": "assistant", "content": "pub var nextItemDataAllocation: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Are garment and material removable from item"}, {"role": "assistant", "content": "pub var isSplittable: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: metadata of an ItemData struct that contains the metadata value\nand whether it is mutable"}, {"role": "assistant", "content": "pub struct Metadata {\n        pub var metadataValue: String\n        pub var mutable: Bool\n        \n        init(\n            metadataValue: String,\n            mutable: Bool\n        ){\n            self.metadataValue = metadataValue\n            self.mutable = mutable\n        }\n        \n        pub fun setMetadataImmutable(){\n            pre {\n                self.mutable == true:\n                \"metadata is already immutable\"\n            }\n            self.mutable = false\n        }\n\n        pub fun setMetadataValue(metadataValue: String){\n            pre {\n                self.mutable == true:\n                \"metadata is already immutable\"\n            }\n            self.metadataValue = metadataValue\n        }\n\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The unique ID for the Item Data"}, {"role": "assistant", "content": "pub let itemDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the address of the user who created the unique combination"}, {"role": "assistant", "content": "pub let coCreator: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: other metadata"}, {"role": "assistant", "content": "access(self) let metadatas: {String: TheFabricantS1ItemNFT.Metadata}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change a mutable metadata in the metadata struct"}, {"role": "assistant", "content": "pub fun setMetadata(metadataKey: String, metadataValue: String){\n            self.metadatas[metadataKey]!.setMetadataValue(metadataValue: metadataValue)\n\n            emit ItemMetadataChanged(itemDataID: self.itemDataID, metadataKey: metadataKey, metadataValue: metadataValue)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: prevent changing of a metadata in the metadata struct"}, {"role": "assistant", "content": "pub fun setMetadataKeyImmutable(metadataKey: String){\n            self.metadatas[metadataKey]!.setMetadataImmutable()\n\n            emit ItemMetadataImmutable(itemDataID: self.itemDataID, metadataKey: metadataKey)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID of the itemData that the item references"}, {"role": "assistant", "content": "pub let itemDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The N'th NFT with 'ItemDataID' minted"}, {"role": "assistant", "content": "pub let serialNumber: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Royalty struct that each TheFabricantS1ItemNFT will contain"}, {"role": "assistant", "content": "pub struct Royalty{\n\n\t\tpub let wallet:Capability<&{FungibleToken.Receiver}> \n        pub let initialCut: UFix64\n\t\tpub let cut: UFix64\n\n\t\t/// @param wallet : The wallet to send royalty too\n\t\tinit(wallet:Capability<&{FungibleToken.Receiver}>, initialCut: UFix64, cut: UFix64){\n\t\t\tself.wallet=wallet\n            self.initialCut= initialCut\n\t\t\tself.cut=cut\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The resource that represents the Item NFTs\n"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT {\n\n        // Global unique Item ID\n        pub let id: UInt64\n        \n        // struct of Item\n        pub let item: Item \n\n        // name of nft, can be changed\n        pub var name: String\n        \n        // Royalty struct\n        pub let royaltyVault: TheFabricantS1ItemNFT.Royalty\n\n        // after you remove the garment and material from the item, the TheFabricantS1ItemNFT will be considered \"dead\". \n        // accounts will be unable to deposit, withdraw or call functions of the nft.\n        pub var isDead : Bool\n\n        // this is where the garment nft is stored, it cannot be moved out\n        access(self) var garment: @TheFabricantS1GarmentNFT.NFT?\n\n        // this is where the material nft is stored, it cannot be moved out\n        access(self) var material: @TheFabricantS1MaterialNFT.NFT?\n\n        init(serialNumber: UInt32, name: String, itemDataID: UInt32, royaltyVault: TheFabricantS1ItemNFT.Royalty, garment: @TheFabricantS1GarmentNFT.NFT, material: @TheFabricantS1MaterialNFT.NFT) {\n            \n            TheFabricantS1ItemNFT.totalSupply = TheFabricantS1ItemNFT.totalSupply + 1 as UInt64\n            \n            self.id = TheFabricantS1ItemNFT.totalSupply\n\n            self.name = name\n\n            self.royaltyVault = royaltyVault\n\n            self.isDead = false\n\n            self.garment <- garment\n\n            self.material <- material\n\n            self.item = Item(itemDataID: itemDataID)\n\n            // Emitted when a Item is minted\n            emit ItemMinted(itemID: self.id, itemDataID: itemDataID, serialNumber: serialNumber)\n\n        }\n\n        destroy() {\n            emit ItemDestroyed(id: self.id)\n            //destroy self.items\n            destroy self.garment\n            destroy self.material\n        }\n\n        //Make Item considered dead. Deposit garment and material to respective vaults\n        access(contract) fun split(garmentCap: Capability<&{TheFabricantS1GarmentNFT.GarmentCollectionPublic}>, materialCap: Capability<&{TheFabricantS1MaterialNFT.MaterialCollectionPublic}>) {\n            pre {\n                !self.isDead: \n                \"Cannot split. Item is dead\"\n                TheFabricantS1ItemNFT.isSplittable:\n                \"Item is set to unsplittable\"\n                garmentCap.check():\n                \"Garment Capability is invalid\"\n                materialCap.check():\n                \"Material Capability is invalid\"\n            }\n            let garmentOptional <- self.garment <- nil\n            let materialOptional <- self.material <- nil\n            let garmentRecipient = garmentCap.borrow()!\n            let materialRecipient = materialCap.borrow()!\n            let garment <- garmentOptional!\n            let material <- materialOptional!\n            let garmentNFT <- garment as! @NonFungibleToken.NFT\n            let materialNFT <- material as! @NonFungibleToken.NFT\n            garmentRecipient.deposit(token: <- garmentNFT)\n            materialRecipient.deposit(token: <- materialNFT)\n            TheFabricantS1ItemNFT.numberMintedPerItem[self.item.itemDataID] = TheFabricantS1ItemNFT.numberMintedPerItem[self.item.itemDataID]! - 1 as UInt32\n            self.isDead = true\n        }\n\n        // get a reference to the garment that item stores\n        pub fun borrowGarment(): &TheFabricantS1GarmentNFT.NFT? {\n            let garmentOptional <- self.garment <- nil\n            let garment <- garmentOptional!\n            let garmentRef = &garment as auth &TheFabricantS1GarmentNFT.NFT\n            self.garment <-! garment\n            return garmentRef   \n        }\n\n        // get a reference to the material that item stores\n        pub fun borrowMaterial(): &TheFabricantS1MaterialNFT.NFT?  {\n            let materialOptional <- self.material <- nil\n            let material <- materialOptional!\n            let materialRef = &material as auth &TheFabricantS1MaterialNFT.NFT\n            self.material <-! material\n            return materialRef\n        }\n\n        // change name of item nft\n        access(contract) fun changeName(name: String) {\n            pre {\n                !self.isDead: \n                \"Cannot change garment name. Item is dead\"\n            }\n            self.name = name;\n\n           emit ItemNameChanged(id: self.id, name: self.name)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Global unique Item ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: struct of Item"}, {"role": "assistant", "content": "pub let item: Item"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: name of nft, can be changed"}, {"role": "assistant", "content": "pub var name: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Royalty struct"}, {"role": "assistant", "content": "pub let royaltyVault: TheFabricantS1ItemNFT.Royalty"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: after you remove the garment and material from the item, the TheFabricantS1ItemNFT will be considered \"dead\".\naccounts will be unable to deposit, withdraw or call functions of the nft."}, {"role": "assistant", "content": "pub var isDead : Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: this is where the garment nft is stored, it cannot be moved out"}, {"role": "assistant", "content": "access(self) var garment: @TheFabricantS1GarmentNFT.NFT?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: this is where the material nft is stored, it cannot be moved out"}, {"role": "assistant", "content": "access(self) var material: @TheFabricantS1MaterialNFT.NFT?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Make Item considered dead. Deposit garment and material to respective vaults"}, {"role": "assistant", "content": "access(contract) fun split(garmentCap: Capability<&{TheFabricantS1GarmentNFT.GarmentCollectionPublic}>, materialCap: Capability<&{TheFabricantS1MaterialNFT.MaterialCollectionPublic}>) {\n            pre {\n                !self.isDead: \n                \"Cannot split. Item is dead\"\n                TheFabricantS1ItemNFT.isSplittable:\n                \"Item is set to unsplittable\"\n                garmentCap.check():\n                \"Garment Capability is invalid\"\n                materialCap.check():\n                \"Material Capability is invalid\"\n            }\n            let garmentOptional <- self.garment <- nil\n            let materialOptional <- self.material <- nil\n            let garmentRecipient = garmentCap.borrow()!\n            let materialRecipient = materialCap.borrow()!\n            let garment <- garmentOptional!\n            let material <- materialOptional!\n            let garmentNFT <- garment as! @NonFungibleToken.NFT\n            let materialNFT <- material as! @NonFungibleToken.NFT\n            garmentRecipient.deposit(token: <- garmentNFT)\n            materialRecipient.deposit(token: <- materialNFT)\n            TheFabricantS1ItemNFT.numberMintedPerItem[self.item.itemDataID] = TheFabricantS1ItemNFT.numberMintedPerItem[self.item.itemDataID]! - 1 as UInt32\n            self.isDead = true\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get a reference to the garment that item stores"}, {"role": "assistant", "content": "pub fun borrowGarment(): &TheFabricantS1GarmentNFT.NFT? {\n            let garmentOptional <- self.garment <- nil\n            let garment <- garmentOptional!\n            let garmentRef = &garment as auth &TheFabricantS1GarmentNFT.NFT\n            self.garment <-! garment\n            return garmentRef   \n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get a reference to the material that item stores"}, {"role": "assistant", "content": "pub fun borrowMaterial(): &TheFabricantS1MaterialNFT.NFT?  {\n            let materialOptional <- self.material <- nil\n            let material <- materialOptional!\n            let materialRef = &material as auth &TheFabricantS1MaterialNFT.NFT\n            self.material <-! material\n            return materialRef\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change name of item nft"}, {"role": "assistant", "content": "access(contract) fun changeName(name: String) {\n            pre {\n                !self.isDead: \n                \"Cannot change garment name. Item is dead\"\n            }\n            self.name = name;\n\n           emit ItemNameChanged(id: self.id, name: self.name)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: destroy item if it is considered dead"}, {"role": "assistant", "content": "pub fun cleanDeadItems(item: @TheFabricantS1ItemNFT.NFT) {\n        pre {\n            item.isDead: \n            \"Cannot destroy, item not dead\" \n        }\n        destroy item\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mint the NFT, based on a combination of garment, material, primaryColor and secondaryColor.\nThe itemData that is used to mint the Item is based on the garment and material' garmentDataID and materialDataID"}, {"role": "assistant", "content": "pub fun mintNFT(name: String, royaltyVault: TheFabricantS1ItemNFT.Royalty, garment: @TheFabricantS1GarmentNFT.NFT, material: @TheFabricantS1MaterialNFT.NFT, primaryColor: String, secondaryColor: String): @NFT {\n        let garmentDataID = garment.garment.garmentDataID\n\n        let materialDataID = material.material.materialDataID\n\n        let key = TheFabricantS1ItemNFT.getUniqueString(garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor)\n\n        //check whether unique combination is allocated\n        let itemDataID = TheFabricantS1ItemNFT.itemDataAllocation[key]??\n            panic(\"Cannot mint Item. ItemData not found\")\n\n        //check whether itemdata is retired\n        if (TheFabricantS1ItemNFT.isItemDataRetired[itemDataID]!) {\n            panic(\"Cannot mint Item. ItemDataID retired\")\n        }\n\n        let numInItem = TheFabricantS1ItemNFT.numberMintedPerItem[itemDataID]??\n            panic(\"Maximum number of Items with itemDataID minted\")\n\n        let item <-create NFT(serialNumber: numInItem + 1, name: name, itemDataID: itemDataID, royaltyVault: royaltyVault, garment: <- garment, material: <- material)\n\n        return <- item\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This is the interface that users can cast their Item Collection as\nto allow others to deposit Items into their Collection. It also allows for reading\nthe IDs of Items in the Collection."}, {"role": "assistant", "content": "pub resource interface ItemCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowItem(id: UInt64): &TheFabricantS1ItemNFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id): \n                    \"Cannot borrow Item reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection is a resource that every user who owns NFTs\nwill store in their account to manage their NFTS\n"}, {"role": "assistant", "content": "pub resource Collection: ItemCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic { \n        // Dictionary of Item conforming tokens\n        // NFT is a resource type with a UInt64 ID field\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        // change name of item nft\n        pub fun changeName(id: UInt64, name: String) {\n            let token <- self.ownedNFTs.remove(key: id)\n                ?? panic(\"Cannot withdraw: Item does not exist in the collection\")\n            \n            let item <- token as! @TheFabricantS1ItemNFT.NFT\n            item.changeName(name: name)\n\n            self.ownedNFTs[id] <-! item\n        }\n\n        pub fun split(id: UInt64, garmentCap: Capability<&{TheFabricantS1GarmentNFT.GarmentCollectionPublic}>, materialCap: Capability<&{TheFabricantS1MaterialNFT.MaterialCollectionPublic}>){\n            let token <- self.ownedNFTs.remove(key: id)\n                ?? panic(\"Cannot withdraw: Item does not exist in the collection\")\n            \n            let item <- token as! @TheFabricantS1ItemNFT.NFT\n            item.split(garmentCap: garmentCap, materialCap: materialCap)\n\n            self.ownedNFTs[id] <-! item\n        }\n\n        // withdraw removes an Item from the Collection and moves it to the caller\n        //\n        // Parameters: withdrawID: The ID of the NFT \n        // that is to be removed from the Collection\n        //\n        // returns: @NonFungibleToken.NFT the token that was withdrawn\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Item does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple tokens and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: A collection that contains\n        //                                        the withdrawn Items\n        //\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit takes a Item and adds it to the Collections dictionary\n        //\n        // Paramters: token: the NFT to be deposited in the collection\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            //todo: someFunction that transfers royalty\n            // Cast the deposited token as  NFT to make sure\n            // it is the correct type\n            let token <- token as! @TheFabricantS1ItemNFT.NFT\n            \n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token that was \"removed\"\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs returns an array of the IDs that are in the Collection\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT Returns a borrowed reference to a Item in the Collection\n        // so that the caller can read its ID\n        //\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        //\n        // Note: This only allows the caller to read the ID of the NFT,\n        // not an specific data. Please use borrowItem to \n        // read Item data.\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        pub fun borrowItem(id: UInt64): &TheFabricantS1ItemNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TheFabricantS1ItemNFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // If a transaction destroys the Collection object,\n        // All the NFTs contained within are also destroyed!\n        //\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of Item conforming tokens\nNFT is a resource type with a UInt64 ID field"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change name of item nft"}, {"role": "assistant", "content": "pub fun changeName(id: UInt64, name: String) {\n            let token <- self.ownedNFTs.remove(key: id)\n                ?? panic(\"Cannot withdraw: Item does not exist in the collection\")\n            \n            let item <- token as! @TheFabricantS1ItemNFT.NFT\n            item.changeName(name: name)\n\n            self.ownedNFTs[id] <-! item\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an Item from the Collection and moves it to the caller\n\nParameters: withdrawID: The ID of the NFT\nthat is to be removed from the Collection\n\nreturns: @NonFungibleToken.NFT the token that was withdrawn"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Item does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchWithdraw withdraws multiple tokens and returns them as a Collection\n\nParameters: ids: An array of IDs to withdraw\n\nReturns: @NonFungibleToken.Collection: A collection that contains\nthe withdrawn Items\n"}, {"role": "assistant", "content": "pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a Item and adds it to the Collections dictionary\n\nParamters: token: the NFT to be deposited in the collection\n"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            //todo: someFunction that transfers royalty\n            // Cast the deposited token as  NFT to make sure\n            // it is the correct type\n            let token <- token as! @TheFabricantS1ItemNFT.NFT\n            \n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token that was \"removed\"\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT Returns a borrowed reference to a Item in the Collection\nso that the caller can read its ID\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT\n\nNote: This only allows the caller to read the ID of the NFT,\nnot an specific data. Please use borrowItem to\nread Item data.\n"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Parameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT"}, {"role": "assistant", "content": "pub fun borrowItem(id: UInt64): &TheFabricantS1ItemNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TheFabricantS1ItemNFT.NFT\n            } else {\n                return nil\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is a special authorization resource that\nallows the owner to perform important functions to modify the\nvarious aspects of the Items and NFTs\n"}, {"role": "assistant", "content": "pub resource Admin {\n\n        // create itemdataid allocation based on the \n        // garmentDataID, materialDataID, primaryColor and secondaryColor\n        // and create an itemdata struct based on it\n        pub fun createItemDataWithAllocation(\n            garmentDataID: UInt32, \n            materialDataID: UInt32, \n            primaryColor: String, \n            secondaryColor: String,\n            metadatas: {String: TheFabricantS1ItemNFT.Metadata},\n            coCreator: Address):UInt32 {\n\n            // check whether colors are valid colors\n            pre {\n                TheFabricantS1ItemNFT.availablePrimaryColors.contains(primaryColor):\n                    \"PrimaryColor not available\"\n\n                TheFabricantS1ItemNFT.availableSecondaryColors.contains(secondaryColor):\n                    \"SecondaryColor not available\"\n\n                TheFabricantS1GarmentNFT.getGarmentDatas().containsKey(garmentDataID):\n                    \"GarmentData not found\"\n\n                TheFabricantS1MaterialNFT.getMaterialDatas().containsKey(materialDataID):\n                    \"MaterialData not found\"\n            }\n            // set the primaryColor and secondaryColor metadata of Metadata struct\n            metadatas[\"primaryColor\"] = TheFabricantS1ItemNFT.Metadata(metadataValue: primaryColor, mutable: false)\n            metadatas[\"secondaryColor\"] = TheFabricantS1ItemNFT.Metadata(metadataValue: secondaryColor, mutable: false)\n\n            // check whether unique combination is allocated already\n            let key = TheFabricantS1ItemNFT.getUniqueString(garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor)\n            if(TheFabricantS1ItemNFT.itemDataAllocation.containsKey(key)){\n                panic(\"Item already allocated\")\n            } \n\n            // set unique combination's itemdataallocation, then increment nextItemDataAllocation\n            TheFabricantS1ItemNFT.itemDataAllocation[key] = TheFabricantS1ItemNFT.nextItemDataAllocation\n            emit ItemDataAllocated(garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor, key: key, itemDataID: TheFabricantS1ItemNFT.nextItemDataAllocation)\n            TheFabricantS1ItemNFT.nextItemDataAllocation = TheFabricantS1ItemNFT.nextItemDataAllocation + 1 as UInt32\n\n            // create new itemData \n            var newItem = ItemData(coCreator: coCreator, metadatas: metadatas)\n\n            // Store it in the contract storage\n            let newID = newItem.itemDataID\n            TheFabricantS1ItemNFT.itemDatas[newID] = newItem\n            TheFabricantS1ItemNFT.numberMintedPerItem[newID] = 0 as UInt32\n            return newID\n        }\n\n        // change the metadatavalue of an itemData\n        pub fun setMetadata(itemDataID: UInt32, metadataKey: String, metadataValue: String) {\n            let itemDataTemp = TheFabricantS1ItemNFT.itemDatas[itemDataID]!\n            itemDataTemp.setMetadata(metadataKey: metadataKey, metadataValue: metadataValue)\n            TheFabricantS1ItemNFT.itemDatas[itemDataID] = itemDataTemp\n        }\n\n        // make the metadatavalue of an itemData immutable\n        pub fun setMetadataImmutable(itemData: UInt32, metadataKey: String) {\n            let itemDataTemp = TheFabricantS1ItemNFT.itemDatas[itemData]!\n            itemDataTemp.setMetadataKeyImmutable(metadataKey: metadataKey)\n            TheFabricantS1ItemNFT.itemDatas[itemData] = itemDataTemp\n        }\n\n        // add the primaryColor to array of availablePrimaryColors\n        pub fun addPrimaryColor(color: String) {\n            pre {\n                !TheFabricantS1ItemNFT.availablePrimaryColors.contains(color):\n                \"availablePrimaryColors already has color\"\n            }\n            TheFabricantS1ItemNFT.availablePrimaryColors.append(color)\n            emit PrimaryColorAdded(color: color)\n        }\n\n        // add the primaryColor to array of availablePrimaryColors\n        pub fun addSecondaryColor(color: String) {\n            pre {\n                !TheFabricantS1ItemNFT.availableSecondaryColors.contains(color):\n                \"availableSecondaryColors does not contain color\"\n            }\n            TheFabricantS1ItemNFT.availableSecondaryColors.append(color)\n            emit SecondaryColorAdded(color: color)\n        }\n\n        // add the primaryColor to array of availablePrimaryColors\n        pub fun removePrimaryColor(color: String) {\n            pre {\n                TheFabricantS1ItemNFT.availablePrimaryColors.contains(color):\n                \"availablePrimaryColors does not contain color\"\n            }\n            var index = 0\n            for primaryColor in TheFabricantS1ItemNFT.availablePrimaryColors {\n                if primaryColor == color {\n                    TheFabricantS1ItemNFT.availablePrimaryColors.remove(at: index)\n                } else {\n                    index = index + 1\n                }\n            }\n            emit PrimaryColorRemoved(color: color)\n        }\n\n        // add the primaryColor to array of availablePrimaryColors\n        pub fun removeSecondaryColor(color: String) {\n            pre {\n                TheFabricantS1ItemNFT.availableSecondaryColors.contains(color):\n                \"availableSecondaryColors already has color\"\n            }\n            var index = 0\n            for secondaryColor in TheFabricantS1ItemNFT.availableSecondaryColors {\n                if secondaryColor == color {\n                    TheFabricantS1ItemNFT.availableSecondaryColors.remove(at: index)\n                } else {\n                    index = index + 1\n                }\n            }\n            emit SecondaryColorRemoved(color: color)\n        }\n        \n        // createNewAdmin creates a new Admin resource\n        //\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n        // Change the royalty percentage of the contract\n        pub fun makeSplittable() {\n            TheFabricantS1ItemNFT.isSplittable = true\n            \n            emit ItemNFTNowSplittable()\n        }\n\n        // Change the royalty percentage of the contract\n        pub fun changeItemDataNumberMintable(itemDataID: UInt32, number: UInt32) {\n            TheFabricantS1ItemNFT.numberMintablePerItemData[itemDataID] = number\n            \n            emit numberItemDataMintableChanged(itemDataID: itemDataID, number: number)\n        }\n\n        // Retire itemData so that it cannot be used to mint anymore\n        pub fun retireItemData(itemDataID: UInt32) {           \n            pre {\n                TheFabricantS1ItemNFT.isItemDataRetired[itemDataID] != nil: \"Cannot retire item: Item doesn't exist!\"\n            }\n\n            if !TheFabricantS1ItemNFT.isItemDataRetired[itemDataID]! {\n                TheFabricantS1ItemNFT.isItemDataRetired[itemDataID] = true\n\n                emit ItemDataIDRetired(itemDataID: itemDataID)\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: create itemdataid allocation based on the\ngarmentDataID, materialDataID, primaryColor and secondaryColor\nand create an itemdata struct based on it"}, {"role": "assistant", "content": "pub fun createItemDataWithAllocation(\n            garmentDataID: UInt32, \n            materialDataID: UInt32, \n            primaryColor: String, \n            secondaryColor: String,\n            metadatas: {String: TheFabricantS1ItemNFT.Metadata},\n            coCreator: Address):UInt32 {\n\n            // check whether colors are valid colors\n            pre {\n                TheFabricantS1ItemNFT.availablePrimaryColors.contains(primaryColor):\n                    \"PrimaryColor not available\"\n\n                TheFabricantS1ItemNFT.availableSecondaryColors.contains(secondaryColor):\n                    \"SecondaryColor not available\"\n\n                TheFabricantS1GarmentNFT.getGarmentDatas().containsKey(garmentDataID):\n                    \"GarmentData not found\"\n\n                TheFabricantS1MaterialNFT.getMaterialDatas().containsKey(materialDataID):\n                    \"MaterialData not found\"\n            }\n            // set the primaryColor and secondaryColor metadata of Metadata struct\n            metadatas[\"primaryColor\"] = TheFabricantS1ItemNFT.Metadata(metadataValue: primaryColor, mutable: false)\n            metadatas[\"secondaryColor\"] = TheFabricantS1ItemNFT.Metadata(metadataValue: secondaryColor, mutable: false)\n\n            // check whether unique combination is allocated already\n            let key = TheFabricantS1ItemNFT.getUniqueString(garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor)\n            if(TheFabricantS1ItemNFT.itemDataAllocation.containsKey(key)){\n                panic(\"Item already allocated\")\n            } \n\n            // set unique combination's itemdataallocation, then increment nextItemDataAllocation\n            TheFabricantS1ItemNFT.itemDataAllocation[key] = TheFabricantS1ItemNFT.nextItemDataAllocation\n            emit ItemDataAllocated(garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor, key: key, itemDataID: TheFabricantS1ItemNFT.nextItemDataAllocation)\n            TheFabricantS1ItemNFT.nextItemDataAllocation = TheFabricantS1ItemNFT.nextItemDataAllocation + 1 as UInt32\n\n            // create new itemData \n            var newItem = ItemData(coCreator: coCreator, metadatas: metadatas)\n\n            // Store it in the contract storage\n            let newID = newItem.itemDataID\n            TheFabricantS1ItemNFT.itemDatas[newID] = newItem\n            TheFabricantS1ItemNFT.numberMintedPerItem[newID] = 0 as UInt32\n            return newID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change the metadatavalue of an itemData"}, {"role": "assistant", "content": "pub fun setMetadata(itemDataID: UInt32, metadataKey: String, metadataValue: String) {\n            let itemDataTemp = TheFabricantS1ItemNFT.itemDatas[itemDataID]!\n            itemDataTemp.setMetadata(metadataKey: metadataKey, metadataValue: metadataValue)\n            TheFabricantS1ItemNFT.itemDatas[itemDataID] = itemDataTemp\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: make the metadatavalue of an itemData immutable"}, {"role": "assistant", "content": "pub fun setMetadataImmutable(itemData: UInt32, metadataKey: String) {\n            let itemDataTemp = TheFabricantS1ItemNFT.itemDatas[itemData]!\n            itemDataTemp.setMetadataKeyImmutable(metadataKey: metadataKey)\n            TheFabricantS1ItemNFT.itemDatas[itemData] = itemDataTemp\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: add the primaryColor to array of availablePrimaryColors"}, {"role": "assistant", "content": "pub fun addPrimaryColor(color: String) {\n            pre {\n                !TheFabricantS1ItemNFT.availablePrimaryColors.contains(color):\n                \"availablePrimaryColors already has color\"\n            }\n            TheFabricantS1ItemNFT.availablePrimaryColors.append(color)\n            emit PrimaryColorAdded(color: color)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: add the primaryColor to array of availablePrimaryColors"}, {"role": "assistant", "content": "pub fun addSecondaryColor(color: String) {\n            pre {\n                !TheFabricantS1ItemNFT.availableSecondaryColors.contains(color):\n                \"availableSecondaryColors does not contain color\"\n            }\n            TheFabricantS1ItemNFT.availableSecondaryColors.append(color)\n            emit SecondaryColorAdded(color: color)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: add the primaryColor to array of availablePrimaryColors"}, {"role": "assistant", "content": "pub fun removePrimaryColor(color: String) {\n            pre {\n                TheFabricantS1ItemNFT.availablePrimaryColors.contains(color):\n                \"availablePrimaryColors does not contain color\"\n            }\n            var index = 0\n            for primaryColor in TheFabricantS1ItemNFT.availablePrimaryColors {\n                if primaryColor == color {\n                    TheFabricantS1ItemNFT.availablePrimaryColors.remove(at: index)\n                } else {\n                    index = index + 1\n                }\n            }\n            emit PrimaryColorRemoved(color: color)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: add the primaryColor to array of availablePrimaryColors"}, {"role": "assistant", "content": "pub fun removeSecondaryColor(color: String) {\n            pre {\n                TheFabricantS1ItemNFT.availableSecondaryColors.contains(color):\n                \"availableSecondaryColors already has color\"\n            }\n            var index = 0\n            for secondaryColor in TheFabricantS1ItemNFT.availableSecondaryColors {\n                if secondaryColor == color {\n                    TheFabricantS1ItemNFT.availableSecondaryColors.remove(at: index)\n                } else {\n                    index = index + 1\n                }\n            }\n            emit SecondaryColorRemoved(color: color)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Change the royalty percentage of the contract"}, {"role": "assistant", "content": "pub fun makeSplittable() {\n            TheFabricantS1ItemNFT.isSplittable = true\n            \n            emit ItemNFTNowSplittable()\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Change the royalty percentage of the contract"}, {"role": "assistant", "content": "pub fun changeItemDataNumberMintable(itemDataID: UInt32, number: UInt32) {\n            TheFabricantS1ItemNFT.numberMintablePerItemData[itemDataID] = number\n            \n            emit numberItemDataMintableChanged(itemDataID: itemDataID, number: number)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire itemData so that it cannot be used to mint anymore"}, {"role": "assistant", "content": "pub fun retireItemData(itemDataID: UInt32) {           \n            pre {\n                TheFabricantS1ItemNFT.isItemDataRetired[itemDataID] != nil: \"Cannot retire item: Item doesn't exist!\"\n            }\n\n            if !TheFabricantS1ItemNFT.isItemDataRetired[itemDataID]! {\n                TheFabricantS1ItemNFT.isItemDataRetired[itemDataID] = true\n\n                emit ItemDataIDRetired(itemDataID: itemDataID)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyCollection creates a new, empty Collection object so that\na user can store it in their account storage.\nOnce they have a Collection in their storage, they are able to receive\nItems in transactions.\n"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <-create TheFabricantS1ItemNFT.Collection()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get dictionary of numberMintedPerItem"}, {"role": "assistant", "content": "pub fun getNumberMintedPerItem(): {UInt32: UInt32} {\n        return TheFabricantS1ItemNFT.numberMintedPerItem\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get how many Items with itemDataID are minted"}, {"role": "assistant", "content": "pub fun getItemNumberMinted(id: UInt32): UInt32 {\n        let numberMinted = TheFabricantS1ItemNFT.numberMintedPerItem[id]??\n            panic(\"itemDataID not found\")\n        return numberMinted\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the ItemData of a specific id"}, {"role": "assistant", "content": "pub fun getItemData(id: UInt32): ItemData {\n        let itemData = TheFabricantS1ItemNFT.itemDatas[id]??\n            panic(\"itemDataID not found\")\n        return itemData\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the map of item data allocations"}, {"role": "assistant", "content": "pub fun getItemDataAllocations(): {String: UInt32} {\n        let itemDataAllocation = TheFabricantS1ItemNFT.itemDataAllocation\n        return itemDataAllocation\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the itemData allocation from the garment and material dataID"}, {"role": "assistant", "content": "pub fun getItemDataAllocation(garmentDataID: UInt32, materialDataID: UInt32, primaryColor: String, secondaryColor: String): UInt32 {\n        let itemDataAllocation = TheFabricantS1ItemNFT.itemDataAllocation[TheFabricantS1ItemNFT.getUniqueString(\n            garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor)]??\n            panic(\"garment and material dataID pair not allocated\")\n\n        return itemDataAllocation\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get all ItemDatas created"}, {"role": "assistant", "content": "pub fun getItemDatas(): {UInt32: ItemData} {\n        return TheFabricantS1ItemNFT.itemDatas\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get dictionary of itemdataids and whether they are retired"}, {"role": "assistant", "content": "pub fun getItemDatasRetired(): {UInt32: Bool} { \n        return TheFabricantS1ItemNFT.isItemDataRetired\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get bool of if itemdataid is retired"}, {"role": "assistant", "content": "pub fun getItemDataRetired(itemDataID: UInt32): Bool? { \n        return TheFabricantS1ItemNFT.isItemDataRetired[itemDataID]!\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\ninitialization function\n-----------------------------------------------------------------------\n"}, {"role": "assistant", "content": "init() {\n        self.itemDatas = {}\n        self.itemDataAllocation = {}\n        self.numberMintedPerItem = {}\n        self.numberMintablePerItemData = {}\n        self.nextItemDataID = 1\n        self.nextItemDataAllocation = 1\n        self.isSplittable = false\n        self.isItemDataRetired = {}\n        self.totalSupply = 0\n        self.availablePrimaryColors = []\n        self.availableSecondaryColors = []\n        \n        self.CollectionPublicPath = /public/S1ItemCollection0021\n        self.CollectionStoragePath = /storage/S1ItemCollection0021\n        self.AdminStoragePath = /storage/S1ItemAdmin0021\n\n        // Put a new Collection in storage\n        self.account.save<@Collection>(<- create Collection(), to: self.CollectionStoragePath)\n\n        // Create a public capability for the Collection\n        self.account.link<&{ItemCollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)\n        \n        // Put the Minter in storage\n        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)\n\n        emit ContractInitialized()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the Material contract is created"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the Material contract is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new MaterialData struct is created"}, {"role": "assistant", "content": "pub event MaterialDataCreated(materialDataID: UInt32, designerAddress: Address, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new MaterialData struct is created"}, {"role": "assistant", "content": "(materialDataID: UInt32, designerAddress: Address, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Material is minted"}, {"role": "assistant", "content": "pub event MaterialMinted(materialID: UInt64, materialDataID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Material is minted"}, {"role": "assistant", "content": "(materialID: UInt64, materialDataID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a Material is withdrawn from a Collection"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a Material is withdrawn from a Collection"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Material is deposited into a Collection"}, {"role": "assistant", "content": "pub event Deposit(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Material is deposited into a Collection"}, {"role": "assistant", "content": "(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Material is destroyed"}, {"role": "assistant", "content": "pub event MaterialDestroyed(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Material is destroyed"}, {"role": "assistant", "content": "(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of Material structs"}, {"role": "assistant", "content": "access(self) var materialDatas: {UInt32: MaterialData}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary with MaterialDataID as key and number of NFTs with MaterialDataID are minted"}, {"role": "assistant", "content": "access(self) var numberMintedPerMaterial: {UInt32: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of materialDataID to  whether they are retired"}, {"role": "assistant", "content": "access(self) var isMaterialDataRetired: {UInt32: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Keeps track of how many unique MaterialData's are created"}, {"role": "assistant", "content": "pub var nextMaterialDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Royalty struct that each MaterialData will contain"}, {"role": "assistant", "content": "pub struct Royalty{\n\n\t\tpub let wallet:Capability<&{FungibleToken.Receiver}> \n        pub let initialCut: UFix64\n\t\tpub let cut: UFix64\n\n\t\t/// @param wallet : The wallet to send royalty too\n\t\tinit(wallet:Capability<&{FungibleToken.Receiver}>, initialCut: UFix64, cut: UFix64){\n\t\t\tself.wallet=wallet\n            self.initialCut= initialCut\n\t\t\tself.cut=cut\n\t\t}\n\t}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The unique ID for the Material Data"}, {"role": "assistant", "content": "pub let materialDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID of the MaterialData that the Material references"}, {"role": "assistant", "content": "pub let materialDataID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The N'th NFT with 'MaterialDataID' minted"}, {"role": "assistant", "content": "pub let serialNumber: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The resource that represents the Material NFTs\n"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT {\n\n        // Global unique Material ID\n        pub let id: UInt64\n\n        // struct of Material\n        pub let material: Material\n\n        init(serialNumber: UInt32, materialDataID: UInt32) {\n            TheFabricantS1MaterialNFT.totalSupply = TheFabricantS1MaterialNFT.totalSupply + 1 as UInt64\n            \n            self.id = TheFabricantS1MaterialNFT.totalSupply\n\n            self.material = Material(materialDataID: materialDataID)     \n\n            // Emitted when a Material is minted\n            emit MaterialMinted(materialID: self.id, materialDataID: materialDataID, serialNumber: serialNumber)\n        }\n\n        destroy() {\n            emit MaterialDestroyed(id: self.id)\n        }\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Global unique Material ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: struct of Material"}, {"role": "assistant", "content": "pub let material: Material"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is a special authorization resource that\nallows the owner to perform important functions to modify the\nvarious aspects of the Material and NFTs\n"}, {"role": "assistant", "content": "pub resource Admin {\n\n        pub fun createMaterialData(\n            designerAddress: Address, \n            metadata: {String: String},\n            royalty: {String: Royalty}\n        ): UInt32 {\n            // Create the new MaterialData\n            var newMaterial = MaterialData(\n                designerAddress: designerAddress,\n                metadata: metadata,\n                royalty: royalty\n            )\n\n            let newID = newMaterial.materialDataID\n\n            // Store it in the contract storage\n            TheFabricantS1MaterialNFT.materialDatas[newID] = newMaterial\n\n            TheFabricantS1MaterialNFT.numberMintedPerMaterial[newID] = 0 as UInt32\n\n            return newID\n        }\n        \n        // createNewAdmin creates a new Admin resource\n        //\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n\n        // Mint the new Material\n        pub fun mintNFT(materialDataID: UInt32): @NFT {\n            let numInMaterial = TheFabricantS1MaterialNFT.numberMintedPerMaterial[materialDataID]??\n                panic(\"no materialDataID found\")\n\n            if (TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID]! == nil) {\n                panic(\"Cannot mint Material. materialData not found\")\n            }\n\n            if (TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID]!) {\n                panic(\"Cannot mint material. materialDataID retired\")\n            }\n\n            let newMaterial: @NFT <- create NFT(serialNumber: numInMaterial + 1, materialDataID: materialDataID)\n\n            return <-newMaterial\n        }\n\n        pub fun batchMintNFT(materialDataID: UInt32, quantity: UInt64): @Collection {\n            let newCollection <- create Collection()\n\n            var i: UInt64 = 0\n            while i < quantity {\n                newCollection.deposit(token: <-self.mintNFT(materialDataID: materialDataID))\n                i = i + 1 as UInt64\n            }\n\n            return <-newCollection\n        }\n\n        // Retire materialData so that it cannot be used to mint anymore\n        pub fun retireMaterialData(materialDataID: UInt32) {           \n            pre {\n                TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID] != nil: \"Cannot retire Material: Material doesn't exist!\"\n            }\n\n            if !TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID]! {\n                TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID] = true\n\n                emit MaterialDataIDRetired(materialDataID: materialDataID)\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint the new Material"}, {"role": "assistant", "content": "pub fun mintNFT(materialDataID: UInt32): @NFT {\n            let numInMaterial = TheFabricantS1MaterialNFT.numberMintedPerMaterial[materialDataID]??\n                panic(\"no materialDataID found\")\n\n            if (TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID]! == nil) {\n                panic(\"Cannot mint Material. materialData not found\")\n            }\n\n            if (TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID]!) {\n                panic(\"Cannot mint material. materialDataID retired\")\n            }\n\n            let newMaterial: @NFT <- create NFT(serialNumber: numInMaterial + 1, materialDataID: materialDataID)\n\n            return <-newMaterial\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire materialData so that it cannot be used to mint anymore"}, {"role": "assistant", "content": "pub fun retireMaterialData(materialDataID: UInt32) {           \n            pre {\n                TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID] != nil: \"Cannot retire Material: Material doesn't exist!\"\n            }\n\n            if !TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID]! {\n                TheFabricantS1MaterialNFT.isMaterialDataRetired[materialDataID] = true\n\n                emit MaterialDataIDRetired(materialDataID: materialDataID)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This is the interface users can cast their Material Collection as\nto allow others to deposit into their Collection. It also allows for reading\nthe IDs of Material in the Collection."}, {"role": "assistant", "content": "pub resource interface MaterialCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowMaterial(id: UInt64): &TheFabricantS1MaterialNFT.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id): \n                    \"Cannot borrow Material reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection is a resource that every user who owns NFTs\nwill store in their account to manage their NFTS\n"}, {"role": "assistant", "content": "pub resource Collection: MaterialCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic { \n        // Dictionary of Material conforming tokens\n        // NFT is a resource type with a UInt64 ID field\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        // withdraw removes an Material from the Collection and moves it to the caller\n        //\n        // Parameters: withdrawID: The ID of the NFT \n        // that is to be removed from the Collection\n        //\n        // returns: @NonFungibleToken.NFT the token that was withdrawn\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Material does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple tokens and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: A collection that contains\n        //                                        the withdrawn Material\n        //\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit takes a Material and adds it to the Collections dictionary\n        //\n        // Parameters: token: the NFT to be deposited in the collection\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            // Cast the deposited token as NFT to make sure\n            // it is the correct type\n            let token <- token as! @TheFabricantS1MaterialNFT.NFT\n\n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token tMaterial was \"removed\"\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs returns an array of the IDs that are in the Collection\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT Returns a borrowed reference to a Material in the Collection\n        // so tMaterial the caller can read its ID\n        //\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        //\n        // Note: This only allows the caller to read the ID of the NFT,\n        // not an specific data. Please use borrowMaterial to \n        // read Material data.\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        pub fun borrowMaterial(id: UInt64): &TheFabricantS1MaterialNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TheFabricantS1MaterialNFT.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // If a transaction destroys the Collection object,\n        // All the NFTs contained within are also destroyed!\n        //\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of Material conforming tokens\nNFT is a resource type with a UInt64 ID field"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an Material from the Collection and moves it to the caller\n\nParameters: withdrawID: The ID of the NFT\nthat is to be removed from the Collection\n\nreturns: @NonFungibleToken.NFT the token that was withdrawn"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Material does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchWithdraw withdraws multiple tokens and returns them as a Collection\n\nParameters: ids: An array of IDs to withdraw\n\nReturns: @NonFungibleToken.Collection: A collection that contains\nthe withdrawn Material\n"}, {"role": "assistant", "content": "pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a Material and adds it to the Collections dictionary\n\nParameters: token: the NFT to be deposited in the collection\n"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            // Cast the deposited token as NFT to make sure\n            // it is the correct type\n            let token <- token as! @TheFabricantS1MaterialNFT.NFT\n\n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token tMaterial was \"removed\"\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT Returns a borrowed reference to a Material in the Collection\nso tMaterial the caller can read its ID\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT\n\nNote: This only allows the caller to read the ID of the NFT,\nnot an specific data. Please use borrowMaterial to\nread Material data.\n"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Parameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT"}, {"role": "assistant", "content": "pub fun borrowMaterial(id: UInt64): &TheFabricantS1MaterialNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TheFabricantS1MaterialNFT.NFT\n            } else {\n                return nil\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyCollection creates a new, empty Collection object so that\na user can store it in their account storage.\nOnce they have a Collection in their storage, they are able to receive\nMaterial in transactions.\n"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <-create TheFabricantS1MaterialNFT.Collection()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get dictionary of numberMintedPerMaterial"}, {"role": "assistant", "content": "pub fun getNumberMintedPerMaterial(): {UInt32: UInt32} {\n        return TheFabricantS1MaterialNFT.numberMintedPerMaterial\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get how many Materials with materialDataID are minted"}, {"role": "assistant", "content": "pub fun getMaterialNumberMinted(id: UInt32): UInt32 {\n        let numberMinted = TheFabricantS1MaterialNFT.numberMintedPerMaterial[id]??\n            panic(\"materialDataID not found\")\n        return numberMinted\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the materialData of a specific id"}, {"role": "assistant", "content": "pub fun getMaterialData(id: UInt32): MaterialData {\n        let materialData = TheFabricantS1MaterialNFT.materialDatas[id]??\n            panic(\"materialDataID not found\")\n        return materialData\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get all materialDatas created"}, {"role": "assistant", "content": "pub fun getMaterialDatas(): {UInt32: MaterialData} {\n        return TheFabricantS1MaterialNFT.materialDatas\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\ninitialization function\n-----------------------------------------------------------------------\n"}, {"role": "assistant", "content": "init() {\n        // Initialize contract fields\n        self.materialDatas = {}\n        self.numberMintedPerMaterial = {}\n        self.nextMaterialDataID = 1\n        self.isMaterialDataRetired = {}\n        self.totalSupply = 0\n        self.CollectionPublicPath = /public/S1MaterialCollection0021\n        self.CollectionStoragePath = /storage/S1MaterialCollection0021\n        self.AdminStoragePath = /storage/S1MaterialAdmin0021\n\n        // Put a new Collection in storage\n        self.account.save<@Collection>(<- create Collection(), to: self.CollectionStoragePath)\n\n        // Create a public capability for the Collection\n        self.account.link<&{MaterialCollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)\n\n        // Put the Minter in storage\n        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)\n\n        emit ContractInitialized()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: dictionary of addresses and how many items they have minted"}, {"role": "assistant", "content": "access(self) var addressMintCount: {Address: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: is the contract closed"}, {"role": "assistant", "content": "pub var closed: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: prevent minting"}, {"role": "assistant", "content": "pub fun closeClaim() {\n            TheFabricantS1MintTransferClaim.closed = true\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: call S1ItemNFT's mintItem function\neach address can only mint 2 times"}, {"role": "assistant", "content": "pub fun mintAndTransferItem(\n            name: String, \n            recipientAddr: Address,\n            royalty: TheFabricantS1ItemNFT.Royalty,\n            garment: @TheFabricantS1GarmentNFT.NFT, \n            material: @TheFabricantS1MaterialNFT.NFT,\n            primaryColor: String,\n            secondaryColor: String): @TheFabricantS1ItemNFT.NFT {\n    \n            pre {\n                !TheFabricantS1MintTransferClaim.closed:\n                    \"Minting is closed\"\n                TheFabricantS1MintTransferClaim.addressMintCount[recipientAddr] != TheFabricantS1MintTransferClaim.maxMintAmount:\n                    \"Address has minted max amount of items already\"\n            }\n\n            let garmentDataID = garment.garment.garmentDataID\n            let materialDataID = material.material.materialDataID\n\n            // we check using the itemdataallocation using the garment/material dataid and primary/secondary color\n            let itemDataID = TheFabricantS1ItemNFT.getItemDataAllocation(\n                garmentDataID: garmentDataID,\n                materialDataID: materialDataID,\n                primaryColor: primaryColor,\n                secondaryColor: secondaryColor)\n\n            //set mint count of transacter as 1 if first time, else 2\n            if(TheFabricantS1MintTransferClaim.addressMintCount[recipientAddr] == nil) {\n                TheFabricantS1MintTransferClaim.addressMintCount[recipientAddr] = 1\n            } else {\n                TheFabricantS1MintTransferClaim.addressMintCount[recipientAddr] = TheFabricantS1MintTransferClaim.addressMintCount[recipientAddr]! + 1\n            }\n\n            let garmentID = garment.id\n\n            let materialID = material.id\n            \n            //admin mints the item\n            let item <- TheFabricantS1ItemNFT.mintNFT(\n                name: name, \n                royaltyVault: royalty, \n                garment: <- garment, \n                material: <- material,\n                primaryColor: primaryColor,\n                secondaryColor: secondaryColor)\n\n            emit ItemMintedAndTransferred(garmentDataID: garmentDataID, materialDataID: materialDataID, primaryColor: primaryColor, secondaryColor: secondaryColor, itemID: item.id, itemDataID: item.item.itemDataID, name: name)\n\n            return <- item\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\nFlowFestAccess contract Events\n-----------------------------------------------------------------------"}, {"role": "assistant", "content": "pub event AccountVerified(address: Address, id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\nFlowFestAccess contract Events\n-----------------------------------------------------------------------"}, {"role": "assistant", "content": "(address: Address, id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: redeem a flowfest nft by adding it into accountsVerified mapping if not already"}, {"role": "assistant", "content": "pub fun giveAccess(id: UInt64, collectionCap: Capability<&{TheFabricantMysteryBox_FF1.FabricantCollectionPublic}>){\n        pre {\n            FlowFestAccess.isAccountVerified(address: collectionCap.address) == false:\n            \"account already has access\"\n            !FlowFestAccess.accountsVerified.values.contains(id):\n            \"id is already used\"\n        }\n        let collection = collectionCap.borrow()!\n        // get the ids of the flowfest nfts that the collection contains\n        let ids = collection.getIDs()\n        // check that collection actually contains nft with that id\n        if ids.contains(id) {\n            //verify account and store in dictionary\n            FlowFestAccess.accountsVerified[collectionCap.address] = id\n            emit AccountVerified(address: collectionCap.address, id: id)\n        } else {\n            panic(\"user does not have nft with this id\")\n        }\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get dictionary of accounts that are verified and the id\nof the flowfest nft that it used"}, {"role": "assistant", "content": "pub fun getAccountsVerified(): {Address: UInt64} {\n        return FlowFestAccess.accountsVerified\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: check if account is already verified"}, {"role": "assistant", "content": "pub fun isAccountVerified(address: Address): Bool {\n        for key in FlowFestAccess.accountsVerified.keys {\n            if key == address {\n                return true\n            }\n        }\n        return false\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\ninitialization function\n-----------------------------------------------------------------------\n"}, {"role": "assistant", "content": "init() {\n        self.accountsVerified = {}\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when contract has been deployed. Acts as a start marker for historical event indexing."}, {"role": "assistant", "content": "pub event TheFabricantMarketplaceContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when contract has been deployed. Acts as a start marker for historical event indexing."}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when Admin changes/sets the channel fee capability where a proportion of sale amounts will be sent to"}, {"role": "assistant", "content": "pub event ChannelFeeCapSet(channelFeeCapAddress: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when Admin changes/sets the channel fee capability where a proportion of sale amounts will be sent to"}, {"role": "assistant", "content": "(channelFeeCapAddress: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when listings/offers are initialized and destroyed. Acts as start and end markers for historical event indexing"}, {"role": "assistant", "content": "pub event ListingsInitialized(listingsResourceID: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when listings/offers are initialized and destroyed. Acts as start and end markers for historical event indexing"}, {"role": "assistant", "content": "(listingsResourceID: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an nft is listed"}, {"role": "assistant", "content": "pub event NFTListed(listingID: String, nftType: Type, nftID: UInt64, ftVaultType: Type, price: UFix64, seller: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an nft is listed"}, {"role": "assistant", "content": "(listingID: String, nftType: Type, nftID: UInt64, ftVaultType: Type, price: UFix64, seller: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an nft listing is delisted"}, {"role": "assistant", "content": "pub event NFTDelisted(listingID: String, seller: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an nft listing is delisted"}, {"role": "assistant", "content": "(listingID: String, seller: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an nft is purchased"}, {"role": "assistant", "content": "pub event NFTPurchased(listingID: String, seller: Address, buyer: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an nft is purchased"}, {"role": "assistant", "content": "(listingID: String, seller: Address, buyer: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an offer is made for an nft"}, {"role": "assistant", "content": "pub event NFTOfferMade(offerID: String, nftType: Type, nftID: UInt64, price: UFix64, ftVaultType: Type, offerer: Address, initialNFTOwner: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an offer is made for an nft"}, {"role": "assistant", "content": "(offerID: String, nftType: Type, nftID: UInt64, price: UFix64, ftVaultType: Type, offerer: Address, initialNFTOwner: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an offer is removed"}, {"role": "assistant", "content": "pub event NFTOfferRemoved(offerID: String, offerer: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an offer is removed"}, {"role": "assistant", "content": "(offerID: String, offerer: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an offer is accepted"}, {"role": "assistant", "content": "pub event NFTOfferAccepted(offerID: String, offerer: Address, accepter: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when an offer is accepted"}, {"role": "assistant", "content": "(offerID: String, offerer: Address, accepter: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when royalty is deposited for a listing/offer"}, {"role": "assistant", "content": "pub event RoyaltyDeposited(listingID: String, nftType: Type, nftID: UInt64, name: String, amount: UFix64, to: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when royalty is deposited for a listing/offer"}, {"role": "assistant", "content": "(listingID: String, nftType: Type, nftID: UInt64, name: String, amount: UFix64, to: Address)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when admin changes offer duration"}, {"role": "assistant", "content": "pub event OfferDurationChanged(duration: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: emitted when admin changes offer duration"}, {"role": "assistant", "content": "(duration: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\ncontract-level fields.\nThese contain actual values that are stored in the smart contract.\n-----------------------------------------------------------------------"}, {"role": "assistant", "content": "pub let ListingsStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the FungibleToken capability that channel fee royalties will be transferred to"}, {"role": "assistant", "content": "access(self) var channelFeeCap: Capability<&{FungibleToken.Receiver}>?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: dictionary of listing/offerIDs and how many times each has been sold through a listing or offer"}, {"role": "assistant", "content": "access(self) var nftSaleCount: {String: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the duration of an offer until it expires"}, {"role": "assistant", "content": "pub var offerDuration: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: SaleCut\nA struct representing a recipient that must be sent a certain amount\nof the payment when a token is sold.\n"}, {"role": "assistant", "content": "pub struct SaleCut {\n        // The name of the receiver\n        pub let name: String\n        // The receiver capability for the payment.\n        pub let receiver: Capability<&{FungibleToken.Receiver}>\n        // Royalty amounts are percentages\n        // Initial sales will use initialAmount, secondary sales will use amount\n        pub let initialAmount: UFix64\n        pub let amount: UFix64\n\n        init(name: String, receiver: Capability<&{FungibleToken.Receiver}>, initialAmount: UFix64, amount: UFix64) {\n            self.name = name\n            self.receiver = receiver\n            self.initialAmount = initialAmount\n            self.amount = amount\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The name of the receiver"}, {"role": "assistant", "content": "pub let name: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The receiver capability for the payment."}, {"role": "assistant", "content": "pub let receiver: Capability<&{FungibleToken.Receiver}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Royalty amounts are percentages\nInitial sales will use initialAmount, secondary sales will use amount"}, {"role": "assistant", "content": "pub let initialAmount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ListingDetails\nA struct containing a Listing's data.\n"}, {"role": "assistant", "content": "pub struct ListingDetails {\n        // The id of the listing which is the concat of the nftype and nftid\n        pub let listingID: String\n        // The Type of the NonFungibleToken.NFT that is being listed.\n        pub let nftType: Type\n        // The ID of the NFT within that type.\n        pub let nftID: UInt64\n        // The Type of the FungibleToken that payments must be made in.\n        pub let salePaymentVaultType: Type\n        // The amount that must be paid in the specified FungibleToken.\n        pub let price: UFix64\n        // This specifies the division of payment between recipients.\n        pub let saleCuts: [SaleCut]\n\n        init (\n            listingID: String,\n            nftType: Type,\n            nftID: UInt64,\n            salePaymentVaultType: Type,\n            price: UFix64,\n            saleCuts: [SaleCut]\n        ) {\n            self.listingID = listingID\n            self.nftType = nftType\n            self.nftID = nftID\n            self.salePaymentVaultType = salePaymentVaultType\n            self.price = price\n            self.saleCuts = saleCuts\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The id of the listing which is the concat of the nftype and nftid"}, {"role": "assistant", "content": "pub let listingID: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Type of the NonFungibleToken.NFT that is being listed."}, {"role": "assistant", "content": "pub let nftType: Type"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID of the NFT within that type."}, {"role": "assistant", "content": "pub let nftID: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Type of the FungibleToken that payments must be made in."}, {"role": "assistant", "content": "pub let salePaymentVaultType: Type"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The amount that must be paid in the specified FungibleToken."}, {"role": "assistant", "content": "pub let price: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This specifies the division of payment between recipients."}, {"role": "assistant", "content": "pub let saleCuts: [SaleCut]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ListingsPublic\n\nThe interface that a user can publish a capability to their listing\nto allow others to access their listing"}, {"role": "assistant", "content": "pub resource interface ListingPublic {\n        pub fun getListingDetails(): TheFabricantMarketplace.ListingDetails\n        pub fun borrowNFT(): &NonFungibleToken.NFT\n        pub fun containsNFT(): Bool\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Listing\nA resource that allows an NFT to be sold for an amount of a given FungibleToken,\nand for the proceeds of that sale to be split between several recipients.\n"}, {"role": "assistant", "content": "pub resource Listing: ListingPublic {\n\n        // The simple (non-Capability, non-complex) details of the listing\n        access(self) let listingDetails: ListingDetails\n\n        // A capability allowing this resource to withdraw the NFT with the given ID from its collection.\n        // This capability allows the resource to withdraw *any* NFT\n        access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n\n        // the capability allowing this resource to have FungibleToken deposited into once nft is purchased\n        access(self) let paymentCapability: Capability<&{FungibleToken.Receiver}>\n\n        // borrowNFT\n        // This will assert in the same way as the NFT standard borrowNFT()\n        // if the NFT is absent, for example if it has been sold via another listing.\n        pub fun borrowNFT(): &NonFungibleToken.NFT {\n            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.getListingDetails().nftID)\n            assert(ref.isInstance(self.getListingDetails().nftType), message: \"token has wrong type\")\n            assert(ref.id == self.getListingDetails().nftID, message: \"token has wrong ID\")\n            return ref\n        }\n\n        // getListingDetails\n        // Get the details of the current state of the Listing as a struct.\n        pub fun getListingDetails(): ListingDetails {\n            return self.listingDetails\n        }\n\n        // checks whether owner of listing contains the nft for cleanUp\n        pub fun containsNFT(): Bool {\n            return self.nftProviderCapability.borrow()!.getIDs().contains(self.listingDetails.nftID)\n        }\n\n        // purchase\n        // Purchase the listing, buying the token.\n        // This pays the beneficiaries and returns the token to the buyer.\n        // can only be called through the Listings resource\n        pub fun purchase(payment: @FungibleToken.Vault): @NonFungibleToken.NFT {\n            pre {\n                payment.isInstance(self.listingDetails.salePaymentVaultType): \"payment vault is not requested fungible token\"\n                payment.balance == self.listingDetails.price: \"payment vault does not contain requested price\"\n            }\n\n            // Fetch the token to return to the purchaser.\n            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.listingDetails.nftID)\n\n            // check the NFT resource such that it gives us the correct type and id\n            assert(nft.isInstance(self.listingDetails.nftType), message: \"withdrawn NFT is not of specified type\")\n            assert(nft.id == self.listingDetails.nftID, message: \"withdrawn NFT does not have specified ID\")\n            \n            // get the listingID \n            let listingID = self.listingDetails.listingID\n\n            // Pay each beneficiary their amount of the payment, depending on whether that specific token has been sold before\n            for cut in self.listingDetails.saleCuts {\n                let cutAmount = TheFabricantMarketplace.nftSaleCount.containsKey(listingID) ? self.listingDetails.price * cut.amount : self.listingDetails.price * cut.initialAmount\n                if let receiver = cut.receiver.borrow() {\n                   let paymentCut <- payment.withdraw(amount: cutAmount)\n                   receiver.deposit(from: <-paymentCut)\n                   emit RoyaltyDeposited(listingID: listingID, nftType: self.listingDetails.nftType, nftID: self.listingDetails.nftID, name: cut.name, amount: cutAmount, to: receiver.owner!.address)\n                }\n            }\n\n            // Then pay the rest to seller\n            self.paymentCapability.borrow()!.deposit(from: <-payment)\n\n            // Increment saleCount for the nft\n            if(TheFabricantMarketplace.nftSaleCount.containsKey(listingID)){\n                TheFabricantMarketplace.nftSaleCount[listingID] = TheFabricantMarketplace.nftSaleCount[listingID]! + 1\n            } else {\n                TheFabricantMarketplace.nftSaleCount[listingID] = 1\n            }\n\n            return <-nft\n        }\n\n        // destructor\n        //\n        destroy () {}\n\n        // initializer\n        //\n        init (\n            listingID: String,\n            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n            nftType: Type,\n            nftID: UInt64,\n            paymentCapability: Capability<&{FungibleToken.Receiver}>,\n            salePaymentVaultType: Type,\n            price: UFix64,\n            saleCuts: [SaleCut]\n        ) {\n\n            // Store the listing information\n            self.listingDetails = ListingDetails(\n                listingID: listingID,\n                nftType: nftType,\n                nftID: nftID,\n                salePaymentVaultType: salePaymentVaultType,\n                price: price,\n                saleCuts: saleCuts\n            )\n\n            // Store the NFT provider\n            self.nftProviderCapability = nftProviderCapability\n\n            // Store the FungibleToken receiver capability\n            self.paymentCapability = paymentCapability\n\n            // This precondition will assert if the token is not available.\n            let nft = nftProviderCapability.borrow()!.borrowNFT(id: self.listingDetails.nftID)\n            assert(nft.isInstance(self.listingDetails.nftType), message: \"token is not of specified type\")\n            assert(nft.id == self.listingDetails.nftID, message: \"token does not have specified ID\")\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The simple (non-Capability, non-complex) details of the listing"}, {"role": "assistant", "content": "access(self) let listingDetails: ListingDetails"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A capability allowing this resource to withdraw the NFT with the given ID from its collection.\nThis capability allows the resource to withdraw *any* NFT"}, {"role": "assistant", "content": "access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: the capability allowing this resource to have FungibleToken deposited into once nft is purchased"}, {"role": "assistant", "content": "access(self) let paymentCapability: Capability<&{FungibleToken.Receiver}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT\nThis will assert in the same way as the NFT standard borrowNFT()\nif the NFT is absent, for example if it has been sold via another listing."}, {"role": "assistant", "content": "pub fun borrowNFT(): &NonFungibleToken.NFT {\n            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.getListingDetails().nftID)\n            assert(ref.isInstance(self.getListingDetails().nftType), message: \"token has wrong type\")\n            assert(ref.id == self.getListingDetails().nftID, message: \"token has wrong ID\")\n            return ref\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getListingDetails\nGet the details of the current state of the Listing as a struct."}, {"role": "assistant", "content": "pub fun getListingDetails(): ListingDetails {\n            return self.listingDetails\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: checks whether owner of listing contains the nft for cleanUp"}, {"role": "assistant", "content": "pub fun containsNFT(): Bool {\n            return self.nftProviderCapability.borrow()!.getIDs().contains(self.listingDetails.nftID)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: purchase\nPurchase the listing, buying the token.\nThis pays the beneficiaries and returns the token to the buyer.\ncan only be called through the Listings resource"}, {"role": "assistant", "content": "pub fun purchase(payment: @FungibleToken.Vault): @NonFungibleToken.NFT {\n            pre {\n                payment.isInstance(self.listingDetails.salePaymentVaultType): \"payment vault is not requested fungible token\"\n                payment.balance == self.listingDetails.price: \"payment vault does not contain requested price\"\n            }\n\n            // Fetch the token to return to the purchaser.\n            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.listingDetails.nftID)\n\n            // check the NFT resource such that it gives us the correct type and id\n            assert(nft.isInstance(self.listingDetails.nftType), message: \"withdrawn NFT is not of specified type\")\n            assert(nft.id == self.listingDetails.nftID, message: \"withdrawn NFT does not have specified ID\")\n            \n            // get the listingID \n            let listingID = self.listingDetails.listingID\n\n            // Pay each beneficiary their amount of the payment, depending on whether that specific token has been sold before\n            for cut in self.listingDetails.saleCuts {\n                let cutAmount = TheFabricantMarketplace.nftSaleCount.containsKey(listingID) ? self.listingDetails.price * cut.amount : self.listingDetails.price * cut.initialAmount\n                if let receiver = cut.receiver.borrow() {\n                   let paymentCut <- payment.withdraw(amount: cutAmount)\n                   receiver.deposit(from: <-paymentCut)\n                   emit RoyaltyDeposited(listingID: listingID, nftType: self.listingDetails.nftType, nftID: self.listingDetails.nftID, name: cut.name, amount: cutAmount, to: receiver.owner!.address)\n                }\n            }\n\n            // Then pay the rest to seller\n            self.paymentCapability.borrow()!.deposit(from: <-payment)\n\n            // Increment saleCount for the nft\n            if(TheFabricantMarketplace.nftSaleCount.containsKey(listingID)){\n                TheFabricantMarketplace.nftSaleCount[listingID] = TheFabricantMarketplace.nftSaleCount[listingID]! + 1\n            } else {\n                TheFabricantMarketplace.nftSaleCount[listingID] = 1\n            }\n\n            return <-nft\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: destructor\n"}, {"role": "assistant", "content": "destroy () {}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (\n            listingID: String,\n            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n            nftType: Type,\n            nftID: UInt64,\n            paymentCapability: Capability<&{FungibleToken.Receiver}>,\n            salePaymentVaultType: Type,\n            price: UFix64,\n            saleCuts: [SaleCut]\n        ) {\n\n            // Store the listing information\n            self.listingDetails = ListingDetails(\n                listingID: listingID,\n                nftType: nftType,\n                nftID: nftID,\n                salePaymentVaultType: salePaymentVaultType,\n                price: price,\n                saleCuts: saleCuts\n            )\n\n            // Store the NFT provider\n            self.nftProviderCapability = nftProviderCapability\n\n            // Store the FungibleToken receiver capability\n            self.paymentCapability = paymentCapability\n\n            // This precondition will assert if the token is not available.\n            let nft = nftProviderCapability.borrow()!.borrowNFT(id: self.listingDetails.nftID)\n            assert(nft.isInstance(self.listingDetails.nftType), message: \"token is not of specified type\")\n            assert(nft.id == self.listingDetails.nftID, message: \"token does not have specified ID\")\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ListingsPublic\nAn interface to allow borrowing Listings, cleanup and purchasing items via Listings\n"}, {"role": "assistant", "content": "pub resource interface ListingsPublic {\n        pub fun getListingIDs(): [String]\n        pub fun borrowListing(listingID: String): &Listing{ListingPublic}?\n        pub fun cleanUp(listingID: String)\n        pub fun purchaseListing(listingID: String, recipientCap: &{NonFungibleToken.Receiver}, payment: @FungibleToken.Vault)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Listings\nresource that contains listings"}, {"role": "assistant", "content": "pub resource Listings: ListingsPublic, ListingsManager {\n\n        // Dictionary of the listing details for each nft by listing id\n        access(self) var listings: @{String: Listing}\n\n        init () {\n            // listings dictionary is empty at start\n            self.listings <- {}\n\n            emit ListingsInitialized(listingsResourceID: self.uuid)\n        }\n\n        // destructor\n        //\n        destroy () {\n            destroy self.listings\n\n            emit ListingsDestroyed(listingsResourceID: self.uuid)\n        }\n\n         // createListing\n         // Create a listing if the nft is not already listed\n         pub fun createListing(\n            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n            nftType: Type,\n            nftID: UInt64,\n            paymentCapability: Capability<&{FungibleToken.Receiver}>,\n            salePaymentVaultType: Type,\n            price: UFix64,\n            saleCuts: [SaleCut]\n         ): String {\n            pre {\n                nftProviderCapability.check(): \n                \"Owner's NFT provider capability is invalid\" \n                paymentCapability.check():\n                \"Owner's Payment capability is invalid\" \n                self.listings[TheFabricantMarketplace.typeID(type: nftType, id: nftID)] == nil:\n                \"NFT is already listed\"\n            }\n\n            // create the listing id using the nftType and nftID\n            let listingID = TheFabricantMarketplace.typeID(type: nftType, id: nftID)\n\n            // create the listing\n            let listing <- create Listing(\n                listingID: listingID,\n                nftProviderCapability: nftProviderCapability,\n                nftType: nftType,\n                nftID: nftID,\n                paymentCapability: paymentCapability,\n                salePaymentVaultType: salePaymentVaultType,\n                price: price,\n                saleCuts: saleCuts\n            )\n\n            // Add the new listing to the dictionary.\n            let oldListing <- self.listings[listingID] <- listing\n            // Note that oldListing will always be nil, but we have to handle it.\n            destroy oldListing\n\n            emit NFTListed(listingID: listingID, nftType: nftType, nftID: nftID, ftVaultType: salePaymentVaultType, price: price, seller: self.owner?.address!)\n\n            return listingID\n        }\n\n        // removeListing\n        // Remove a Listing that has not yet been purchased from the collection and destroy it.\n        //\n        pub fun removeListing(listingID: String) {\n            let listing <- self.listings.remove(key: listingID)\n                ?? panic(\"missing Listing\")\n\n            emit NFTDelisted(listingID: listingID, seller: self.owner?.address!) \n            \n            destroy listing\n        }\n\n        // purchaseListing\n        // purchase an availableListing\n        // deposits the nft from seller to buyer,\n        // deposits FungibleToken from buyer to seller\n        pub fun purchaseListing(listingID: String, recipientCap: &{NonFungibleToken.Receiver}, payment: @FungibleToken.Vault) {\n            pre {\n                self.listings[listingID] != nil:\n                \"No token matching this listingID for sale!\"\n            }\n\n            let listing <- self.listings.remove(key: listingID)\n                ?? panic(\"missing Listing\")\n\n            let nft <- listing.purchase(payment: <- payment)\n\n            // deposit the NFT into the buyers collection\n            recipientCap.deposit(token: <- nft)\n\n            emit NFTPurchased(listingID: listingID, seller: self.owner?.address!, buyer: recipientCap.owner?.address!)\n            destroy listing\n        }\n\n        // removes a listing if the owner of listing does not own the nft \n        // mainly used to prevent ghost listing in 2 cases\n        // 1) when user transfers nft to another account \n        // 2) when user accepts an offer for the nft when there is still a listing available\n        pub fun cleanUp(listingID: String) {\n            let ref = self.borrowListing(listingID: listingID)\n            if(ref != nil){\n                if(!ref!.containsNFT()) {\n                    self.removeListing(listingID: listingID)\n                }\n            }\n        }\n\n        // borrowListing\n        // Returns a read-only view of the Listing for the given listingID if it is contained by this collection.\n        //\n        pub fun borrowListing(listingID: String): &Listing{ListingPublic}? {\n            return (&self.listings[listingID] as! &Listing{ListingPublic}?)\n        }\n\n        // getListingIDs\n        // Returns an array of the Listing IDs that are in the collection\n        //\n        pub fun getListingIDs(): [String] {\n            return self.listings.keys\n        }\n \n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of the listing details for each nft by listing id"}, {"role": "assistant", "content": "access(self) var listings: @{String: Listing}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: destructor\n"}, {"role": "assistant", "content": "destroy () {\n            destroy self.listings\n\n            emit ListingsDestroyed(listingsResourceID: self.uuid)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createListing\nCreate a listing if the nft is not already listed"}, {"role": "assistant", "content": "pub fun createListing(\n            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n            nftType: Type,\n            nftID: UInt64,\n            paymentCapability: Capability<&{FungibleToken.Receiver}>,\n            salePaymentVaultType: Type,\n            price: UFix64,\n            saleCuts: [SaleCut]\n         ): String {\n            pre {\n                nftProviderCapability.check(): \n                \"Owner's NFT provider capability is invalid\" \n                paymentCapability.check():\n                \"Owner's Payment capability is invalid\" \n                self.listings[TheFabricantMarketplace.typeID(type: nftType, id: nftID)] == nil:\n                \"NFT is already listed\"\n            }\n\n            // create the listing id using the nftType and nftID\n            let listingID = TheFabricantMarketplace.typeID(type: nftType, id: nftID)\n\n            // create the listing\n            let listing <- create Listing(\n                listingID: listingID,\n                nftProviderCapability: nftProviderCapability,\n                nftType: nftType,\n                nftID: nftID,\n                paymentCapability: paymentCapability,\n                salePaymentVaultType: salePaymentVaultType,\n                price: price,\n                saleCuts: saleCuts\n            )\n\n            // Add the new listing to the dictionary.\n            let oldListing <- self.listings[listingID] <- listing\n            // Note that oldListing will always be nil, but we have to handle it.\n            destroy oldListing\n\n            emit NFTListed(listingID: listingID, nftType: nftType, nftID: nftID, ftVaultType: salePaymentVaultType, price: price, seller: self.owner?.address!)\n\n            return listingID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: removeListing\nRemove a Listing that has not yet been purchased from the collection and destroy it.\n"}, {"role": "assistant", "content": "pub fun removeListing(listingID: String) {\n            let listing <- self.listings.remove(key: listingID)\n                ?? panic(\"missing Listing\")\n\n            emit NFTDelisted(listingID: listingID, seller: self.owner?.address!) \n            \n            destroy listing\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: purchaseListing\npurchase an availableListing\ndeposits the nft from seller to buyer,\ndeposits FungibleToken from buyer to seller"}, {"role": "assistant", "content": "pub fun purchaseListing(listingID: String, recipientCap: &{NonFungibleToken.Receiver}, payment: @FungibleToken.Vault) {\n            pre {\n                self.listings[listingID] != nil:\n                \"No token matching this listingID for sale!\"\n            }\n\n            let listing <- self.listings.remove(key: listingID)\n                ?? panic(\"missing Listing\")\n\n            let nft <- listing.purchase(payment: <- payment)\n\n            // deposit the NFT into the buyers collection\n            recipientCap.deposit(token: <- nft)\n\n            emit NFTPurchased(listingID: listingID, seller: self.owner?.address!, buyer: recipientCap.owner?.address!)\n            destroy listing\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: removes a listing if the owner of listing does not own the nft\nmainly used to prevent ghost listing in 2 cases\n1) when user transfers nft to another account\n2) when user accepts an offer for the nft when there is still a listing available"}, {"role": "assistant", "content": "pub fun cleanUp(listingID: String) {\n            let ref = self.borrowListing(listingID: listingID)\n            if(ref != nil){\n                if(!ref!.containsNFT()) {\n                    self.removeListing(listingID: listingID)\n                }\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowListing\nReturns a read-only view of the Listing for the given listingID if it is contained by this collection.\n"}, {"role": "assistant", "content": "pub fun borrowListing(listingID: String): &Listing{ListingPublic}? {\n            return (&self.listings[listingID] as! &Listing{ListingPublic}?)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getListingIDs\nReturns an array of the Listing IDs that are in the collection\n"}, {"role": "assistant", "content": "pub fun getListingIDs(): [String] {\n            return self.listings.keys\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OfferDetails\nA struct containing an Offer's data.\n"}, {"role": "assistant", "content": "pub struct OfferDetails {\n        // The id of the offer which is the concat of the nftype and nftid\n        pub let offerID: String\n        // The Type of the NonFungibleToken.NFT that is being listed.\n        pub let nftType: Type\n        // The ID of the NFT within that type.\n        pub let nftID: UInt64\n        // The Type of the FungibleToken that payments must be made in.\n        pub let offerPaymentVaultType: Type\n        // The amount that will be paid in the specified FungibleToken.\n        pub let price: UFix64\n        // This specifies the division of payment between recipients.\n        pub let saleCuts: [SaleCut]\n        // This specifies the start time of the offer\n        pub let startTime: UFix64\n        // This specifies the end time of the offer, after which offer cannot be accepted\n        pub let endTime: UFix64\n\n        init (\n            offerID: String,\n            nftType: Type,\n            nftID: UInt64,\n            offerPaymentVaultType: Type,\n            price: UFix64,\n            saleCuts: [SaleCut],\n            startTime: UFix64,\n            endTime: UFix64\n        ) {\n            self.offerID = offerID\n            self.nftType = nftType\n            self.nftID = nftID\n            self.offerPaymentVaultType = offerPaymentVaultType\n            self.price = price\n            self.saleCuts = saleCuts\n            self.startTime = startTime\n            self.endTime = endTime\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The id of the offer which is the concat of the nftype and nftid"}, {"role": "assistant", "content": "pub let offerID: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Type of the FungibleToken that payments must be made in."}, {"role": "assistant", "content": "pub let offerPaymentVaultType: Type"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The amount that will be paid in the specified FungibleToken."}, {"role": "assistant", "content": "pub let price: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This specifies the start time of the offer"}, {"role": "assistant", "content": "pub let startTime: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This specifies the end time of the offer, after which offer cannot be accepted"}, {"role": "assistant", "content": "pub let endTime: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OfferPublic\n\nThe interface that a user can publish a capability to their offer\nto allow others to access their offer"}, {"role": "assistant", "content": "pub resource interface OfferPublic {\n        pub fun getOfferDetails(): TheFabricantMarketplace.OfferDetails\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Offer\nA resource that allows an an offer to be made for an NFT for an amount of a given FungibleToken,\nand for the proceeds of that offer to be split between several recipients.\n"}, {"role": "assistant", "content": "pub resource Offer: OfferPublic {\n        // The simple (non-Capability, non-complex) details of the offer\n        access(self) let offerDetails: OfferDetails\n\n        // A capability allowing this resource to withdraw the FungibleToken with the given amount\n        // This capability allows the resource to withdraw *any* FungibleToken\n        access(contract) var ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>\n\n        // The NonFungibleToken capability of the user who made the offer that the nft will be deposited into\n        pub let nftReceiverCapability: Capability<&{NonFungibleToken.CollectionPublic}>\n\n        // getOfferDetails\n        // Get the details of the current state of the Offer as a struct.\n        //\n        pub fun getOfferDetails(): OfferDetails {\n            return self.offerDetails\n        }\n\n        // accept\n        // function that accepts an offer, returning the nft\n        // This pays the beneficiaries and transfers the nft to the user who made the offer\n        // can only be called through the Offers resource\n        pub fun accept(nft: @NonFungibleToken.NFT): @FungibleToken.Vault {\n            pre {\n                nft.isInstance(self.offerDetails.nftType): \"payment vault is not requested fungible token\"\n                self.ftProviderCapability.borrow()!.balance >= self.offerDetails.price: \"payment vault does not have enough fungibletoken\"\n            }\n\n            // Withdraw the payment amount from offer's FungibleToken capability\n            let payment <-self.ftProviderCapability.borrow()!.withdraw(amount: self.offerDetails.price)\n\n            // check the NFT resource such that it gives us the correct type and id\n            assert(nft.isInstance(self.offerDetails.nftType), message: \"withdrawn NFT is not of specified type\")\n            assert(nft.id == self.offerDetails.nftID, message: \"withdrawn NFT does not have specified ID\")\n\n            // get the offerID of the offer\n            let offerID = self.offerDetails.offerID\n\n            // Pay each beneficiary their amount of the payment.\n            for cut in self.offerDetails.saleCuts {\n                let cutAmount = TheFabricantMarketplace.nftSaleCount.containsKey(offerID) ? self.offerDetails.price * cut.amount : self.offerDetails.price * cut.initialAmount\n                if let receiver = cut.receiver.borrow() {\n                   let paymentCut <- payment.withdraw(amount: cutAmount)\n                   receiver.deposit(from: <-paymentCut)\n                   emit RoyaltyDeposited(listingID: offerID, nftType: self.offerDetails.nftType, nftID: self.offerDetails.nftID, name: cut.name, amount: cutAmount, to: receiver.owner!.address)\n                }\n            }\n\n            // Send the nft to user that made the offer\n            self.nftReceiverCapability.borrow()!.deposit(token: <- nft)\n\n            // Increment saleCount for the nft\n            if(TheFabricantMarketplace.nftSaleCount.containsKey(offerID)){\n                TheFabricantMarketplace.nftSaleCount[offerID] = TheFabricantMarketplace.nftSaleCount[offerID]! + 1\n            } else {\n                TheFabricantMarketplace.nftSaleCount[offerID] = 1\n            }\n\n            // return the rest of the paymenet\n            return <- payment\n        }\n\n        // destructor\n        //\n        destroy () {}\n\n        // initializer\n        //\n        init (\n            offerID: String,\n            ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n            offerPaymentVaultType: Type,\n            nftReceiverCapability: Capability<&{NonFungibleToken.CollectionPublic}>,\n            nftType: Type,\n            nftID: UInt64,\n            price: UFix64,\n            saleCuts: [SaleCut],\n            startTime: UFix64,\n            endTime: UFix64\n        ) {\n\n            // Store the offer information\n            self.offerDetails = OfferDetails(\n                offerID: offerID,\n                nftType: nftType,\n                nftID: nftID,\n                offerPaymentVaultType: offerPaymentVaultType,\n                price: price,\n                saleCuts: saleCuts,\n                startTime: startTime,\n                endTime: endTime\n            )\n\n            // Store the FungibleToken provider\n            self.ftProviderCapability = ftProviderCapability\n\n            // Store the nft receiver capability\n            self.nftReceiverCapability = nftReceiverCapability\n\n            // This precondition will assert if the fungibletoken is not available.\n            let ft = ftProviderCapability.borrow()!\n            assert(ft.isInstance(self.offerDetails.offerPaymentVaultType), message: \"token is not of specified type\")\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The simple (non-Capability, non-complex) details of the offer"}, {"role": "assistant", "content": "access(self) let offerDetails: OfferDetails"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A capability allowing this resource to withdraw the FungibleToken with the given amount\nThis capability allows the resource to withdraw *any* FungibleToken"}, {"role": "assistant", "content": "access(contract) var ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The NonFungibleToken capability of the user who made the offer that the nft will be deposited into"}, {"role": "assistant", "content": "pub let nftReceiverCapability: Capability<&{NonFungibleToken.CollectionPublic}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getOfferDetails\nGet the details of the current state of the Offer as a struct.\n"}, {"role": "assistant", "content": "pub fun getOfferDetails(): OfferDetails {\n            return self.offerDetails\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: accept\nfunction that accepts an offer, returning the nft\nThis pays the beneficiaries and transfers the nft to the user who made the offer\ncan only be called through the Offers resource"}, {"role": "assistant", "content": "pub fun accept(nft: @NonFungibleToken.NFT): @FungibleToken.Vault {\n            pre {\n                nft.isInstance(self.offerDetails.nftType): \"payment vault is not requested fungible token\"\n                self.ftProviderCapability.borrow()!.balance >= self.offerDetails.price: \"payment vault does not have enough fungibletoken\"\n            }\n\n            // Withdraw the payment amount from offer's FungibleToken capability\n            let payment <-self.ftProviderCapability.borrow()!.withdraw(amount: self.offerDetails.price)\n\n            // check the NFT resource such that it gives us the correct type and id\n            assert(nft.isInstance(self.offerDetails.nftType), message: \"withdrawn NFT is not of specified type\")\n            assert(nft.id == self.offerDetails.nftID, message: \"withdrawn NFT does not have specified ID\")\n\n            // get the offerID of the offer\n            let offerID = self.offerDetails.offerID\n\n            // Pay each beneficiary their amount of the payment.\n            for cut in self.offerDetails.saleCuts {\n                let cutAmount = TheFabricantMarketplace.nftSaleCount.containsKey(offerID) ? self.offerDetails.price * cut.amount : self.offerDetails.price * cut.initialAmount\n                if let receiver = cut.receiver.borrow() {\n                   let paymentCut <- payment.withdraw(amount: cutAmount)\n                   receiver.deposit(from: <-paymentCut)\n                   emit RoyaltyDeposited(listingID: offerID, nftType: self.offerDetails.nftType, nftID: self.offerDetails.nftID, name: cut.name, amount: cutAmount, to: receiver.owner!.address)\n                }\n            }\n\n            // Send the nft to user that made the offer\n            self.nftReceiverCapability.borrow()!.deposit(token: <- nft)\n\n            // Increment saleCount for the nft\n            if(TheFabricantMarketplace.nftSaleCount.containsKey(offerID)){\n                TheFabricantMarketplace.nftSaleCount[offerID] = TheFabricantMarketplace.nftSaleCount[offerID]! + 1\n            } else {\n                TheFabricantMarketplace.nftSaleCount[offerID] = 1\n            }\n\n            // return the rest of the paymenet\n            return <- payment\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (\n            offerID: String,\n            ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n            offerPaymentVaultType: Type,\n            nftReceiverCapability: Capability<&{NonFungibleToken.CollectionPublic}>,\n            nftType: Type,\n            nftID: UInt64,\n            price: UFix64,\n            saleCuts: [SaleCut],\n            startTime: UFix64,\n            endTime: UFix64\n        ) {\n\n            // Store the offer information\n            self.offerDetails = OfferDetails(\n                offerID: offerID,\n                nftType: nftType,\n                nftID: nftID,\n                offerPaymentVaultType: offerPaymentVaultType,\n                price: price,\n                saleCuts: saleCuts,\n                startTime: startTime,\n                endTime: endTime\n            )\n\n            // Store the FungibleToken provider\n            self.ftProviderCapability = ftProviderCapability\n\n            // Store the nft receiver capability\n            self.nftReceiverCapability = nftReceiverCapability\n\n            // This precondition will assert if the fungibletoken is not available.\n            let ft = ftProviderCapability.borrow()!\n            assert(ft.isInstance(self.offerDetails.offerPaymentVaultType), message: \"token is not of specified type\")\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: OffersPublic\nAn interface to allow other users to get offers' details, and accept offers\n"}, {"role": "assistant", "content": "pub resource interface OffersPublic {\n        pub fun getOfferIDs(): [String]\n        pub fun borrowOffer(offerID: String): &Offer{OfferPublic}?\n        pub fun acceptOffer(offerID: String, recipientCap: Capability<&{FungibleToken.Receiver}>, nft: @NonFungibleToken.NFT)\n        pub fun timeRemaining(offerID: String) : Fix64 \n        pub fun removeExpiredOffers()\n        pub fun isOfferExpired(offerID: String): Bool\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Offers\nresource that contains offers"}, {"role": "assistant", "content": "pub resource Offers: OffersPublic, OffersManager {\n\n        // Dictionary of the offer details for each ItemNFT by offerID\n        access(self) var offers: @{String: Offer}\n\n        init () {\n            self.offers <- {}\n\n            emit OffersInitialized(offersResourceID: self.uuid)\n        }\n\n        // destructor\n        //\n        destroy () {\n            destroy self.offers\n\n            emit OffersDestroyed(offersResourceID: self.uuid)\n        }\n\n         // makeOffer\n         // Create an offer for an nft if user has not already made an offer\n         pub fun makeOffer(\n            initialNFTOwner: Address,\n            ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n            offerPaymentVaultType: Type,\n            nftType: Type,\n            nftID: UInt64,\n            nftReceiverCapability: Capability<&{NonFungibleToken.CollectionPublic}>,\n            price: UFix64,\n            saleCuts: [SaleCut]\n         ): String {\n            pre {\n                ftProviderCapability.check(): \n                \"Offerer's FungibleToken provider capability is invalid\" \n                nftReceiverCapability.check():\n                \"Offerer's NFT Receiver capability is invalid\" \n                self.offers[TheFabricantMarketplace.typeID(type: nftType, id: nftID)] == nil:\n                \"Offer for nft already made\"\n                ftProviderCapability.borrow()!.balance >= price:\n                \"Offerer has insufficient FungibleToken balance\"\n            }\n\n            // create the offerID for the offer\n            let offerID = TheFabricantMarketplace.typeID(type: nftType, id: nftID)\n\n            // create the offer\n            let offer <- create Offer(\n                offerID: offerID,\n                ftProviderCapability: ftProviderCapability,\n                offerPaymentVaultType: offerPaymentVaultType,\n                nftReceiverCapability:nftReceiverCapability,\n                nftType: nftType,\n                nftID: nftID,\n                price: price,\n                saleCuts: saleCuts,\n                startTime: getCurrentBlock().timestamp, \n                endTime: getCurrentBlock().timestamp + TheFabricantMarketplace.offerDuration\n            )\n\n            // Add the new offer to the dictionary.\n            let oldOffer <- self.offers[offerID] <- offer\n            // Note that oldOffer will always be nil, but we have to handle it.\n            destroy oldOffer\n\n            emit NFTOfferMade(offerID: offerID, nftType: nftType, nftID: nftID, price: price, ftVaultType: offerPaymentVaultType, offerer: self.owner?.address!, initialNFTOwner: initialNFTOwner)\n\n            return offerID\n        }\n\n        // Removes an offer from offer dictionary\n        //\n        // Parameters: offerID: the ID of the token to be removed\n        pub fun removeOffer(offerID: String) {\n            let offer <- self.offers.remove(key: offerID)\n                ?? panic(\"missing Offer\")   \n\n            // Emit the event for remove an offer\n            emit NFTOfferRemoved(offerID: offerID, offerer: self.owner?.address!)\n\n            destroy offer\n        }\n\n        // acceptOffer lets a user transfer nft to user who made the offer, and be sent FungibleToken based on price\n        // only if offer has not expired\n        pub fun acceptOffer(offerID: String, recipientCap: Capability<&{FungibleToken.Receiver}>, nft: @NonFungibleToken.NFT) {\n            pre {\n                self.offers[offerID] != nil:\n                \"No token matching this offerID is being offered!\"\n                self.isOfferExpired(offerID: offerID) == false:\n                \"Offer has expired\"\n            }\n\n            // remove offer from offer dictionary\n            let offer <- self.offers.remove(key: offerID)\n                ?? panic(\"missing Offer\")\n\n            // call accept from Offer resource, return the remaining FungibleToken amount to be transferred to user\n            let ft <- offer.accept(nft: <- nft)\n\n            // deposit FungibleToken amount to user\n            recipientCap.borrow()!.deposit(from: <- ft)\n\n            emit NFTOfferAccepted(offerID: offerID, offerer: self.owner?.address!, accepter: recipientCap.address)\n\n            destroy offer\n        }\n\n        // borrowOffer\n        // Returns a read-only view of the Offer for the given offerID if it is contained by this collection.\n        //\n        pub fun borrowOffer(offerID: String): &Offer{OfferPublic}? {\n            return (&self.offers[offerID] as! &Offer{OfferPublic}?)\n\n        }\n\n        // getOfferIDs\n        // Returns an array of the Offer IDs that are in the collection\n        //\n        pub fun getOfferIDs(): [String] {\n            return self.offers.keys\n        }\n\n        // public function that anyone can call to remove offers that have expired \n        pub fun removeExpiredOffers() {\n            for offerID in self.offers.keys {\n                if (self.isOfferExpired(offerID: offerID)){\n                    self.removeOffer(offerID: offerID) \n                }\n            }\n        }\n\n        // get the time remaining of an NFT's offer\n        pub fun timeRemaining(offerID: String) : Fix64 {\n            let offerDuration = TheFabricantMarketplace.offerDuration\n\n            let offer = self.borrowOffer(offerID: offerID)!.getOfferDetails()\n            let endTime = offer.endTime\n            let currentTime = getCurrentBlock().timestamp\n\n            let remaining= Fix64(endTime) - Fix64(currentTime)\n            return remaining\n        }\n\n        // check if offer of NFT has expired\n        pub fun isOfferExpired(offerID: String): Bool {\n            let timeRemaining = self.timeRemaining(offerID: offerID)\n            return timeRemaining <= Fix64(0.0)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of the offer details for each ItemNFT by offerID"}, {"role": "assistant", "content": "access(self) var offers: @{String: Offer}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: destructor\n"}, {"role": "assistant", "content": "destroy () {\n            destroy self.offers\n\n            emit OffersDestroyed(offersResourceID: self.uuid)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: makeOffer\nCreate an offer for an nft if user has not already made an offer"}, {"role": "assistant", "content": "pub fun makeOffer(\n            initialNFTOwner: Address,\n            ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n            offerPaymentVaultType: Type,\n            nftType: Type,\n            nftID: UInt64,\n            nftReceiverCapability: Capability<&{NonFungibleToken.CollectionPublic}>,\n            price: UFix64,\n            saleCuts: [SaleCut]\n         ): String {\n            pre {\n                ftProviderCapability.check(): \n                \"Offerer's FungibleToken provider capability is invalid\" \n                nftReceiverCapability.check():\n                \"Offerer's NFT Receiver capability is invalid\" \n                self.offers[TheFabricantMarketplace.typeID(type: nftType, id: nftID)] == nil:\n                \"Offer for nft already made\"\n                ftProviderCapability.borrow()!.balance >= price:\n                \"Offerer has insufficient FungibleToken balance\"\n            }\n\n            // create the offerID for the offer\n            let offerID = TheFabricantMarketplace.typeID(type: nftType, id: nftID)\n\n            // create the offer\n            let offer <- create Offer(\n                offerID: offerID,\n                ftProviderCapability: ftProviderCapability,\n                offerPaymentVaultType: offerPaymentVaultType,\n                nftReceiverCapability:nftReceiverCapability,\n                nftType: nftType,\n                nftID: nftID,\n                price: price,\n                saleCuts: saleCuts,\n                startTime: getCurrentBlock().timestamp, \n                endTime: getCurrentBlock().timestamp + TheFabricantMarketplace.offerDuration\n            )\n\n            // Add the new offer to the dictionary.\n            let oldOffer <- self.offers[offerID] <- offer\n            // Note that oldOffer will always be nil, but we have to handle it.\n            destroy oldOffer\n\n            emit NFTOfferMade(offerID: offerID, nftType: nftType, nftID: nftID, price: price, ftVaultType: offerPaymentVaultType, offerer: self.owner?.address!, initialNFTOwner: initialNFTOwner)\n\n            return offerID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Removes an offer from offer dictionary\n\nParameters: offerID: the ID of the token to be removed"}, {"role": "assistant", "content": "pub fun removeOffer(offerID: String) {\n            let offer <- self.offers.remove(key: offerID)\n                ?? panic(\"missing Offer\")   \n\n            // Emit the event for remove an offer\n            emit NFTOfferRemoved(offerID: offerID, offerer: self.owner?.address!)\n\n            destroy offer\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: acceptOffer lets a user transfer nft to user who made the offer, and be sent FungibleToken based on price\nonly if offer has not expired"}, {"role": "assistant", "content": "pub fun acceptOffer(offerID: String, recipientCap: Capability<&{FungibleToken.Receiver}>, nft: @NonFungibleToken.NFT) {\n            pre {\n                self.offers[offerID] != nil:\n                \"No token matching this offerID is being offered!\"\n                self.isOfferExpired(offerID: offerID) == false:\n                \"Offer has expired\"\n            }\n\n            // remove offer from offer dictionary\n            let offer <- self.offers.remove(key: offerID)\n                ?? panic(\"missing Offer\")\n\n            // call accept from Offer resource, return the remaining FungibleToken amount to be transferred to user\n            let ft <- offer.accept(nft: <- nft)\n\n            // deposit FungibleToken amount to user\n            recipientCap.borrow()!.deposit(from: <- ft)\n\n            emit NFTOfferAccepted(offerID: offerID, offerer: self.owner?.address!, accepter: recipientCap.address)\n\n            destroy offer\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowOffer\nReturns a read-only view of the Offer for the given offerID if it is contained by this collection.\n"}, {"role": "assistant", "content": "pub fun borrowOffer(offerID: String): &Offer{OfferPublic}? {\n            return (&self.offers[offerID] as! &Offer{OfferPublic}?)\n\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getOfferIDs\nReturns an array of the Offer IDs that are in the collection\n"}, {"role": "assistant", "content": "pub fun getOfferIDs(): [String] {\n            return self.offers.keys\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: public function that anyone can call to remove offers that have expired"}, {"role": "assistant", "content": "pub fun removeExpiredOffers() {\n            for offerID in self.offers.keys {\n                if (self.isOfferExpired(offerID: offerID)){\n                    self.removeOffer(offerID: offerID) \n                }\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the time remaining of an NFT's offer"}, {"role": "assistant", "content": "pub fun timeRemaining(offerID: String) : Fix64 {\n            let offerDuration = TheFabricantMarketplace.offerDuration\n\n            let offer = self.borrowOffer(offerID: offerID)!.getOfferDetails()\n            let endTime = offer.endTime\n            let currentTime = getCurrentBlock().timestamp\n\n            let remaining= Fix64(endTime) - Fix64(currentTime)\n            return remaining\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: check if offer of NFT has expired"}, {"role": "assistant", "content": "pub fun isOfferExpired(offerID: String): Bool {\n            let timeRemaining = self.timeRemaining(offerID: offerID)\n            return timeRemaining <= Fix64(0.0)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createCollection returns a new collection resource to the caller"}, {"role": "assistant", "content": "pub fun createOffers(): @Offers {\n        return <- create Offers()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin\nAdmin can change the marketplace's channelfees capability or change offers' duration"}, {"role": "assistant", "content": "pub resource Admin{\n        \n        // change contract royalty address\n        pub fun setChannelFeeCap(channelFeeCap: Capability<&{FungibleToken.Receiver}>) {\n            pre {\n                channelFeeCap.check(): \n                    \"Channel Fee FungibleToken Receiver Capability invalid\"\n            }\n            TheFabricantMarketplace.channelFeeCap = channelFeeCap\n            emit ChannelFeeCapSet(channelFeeCapAddress: channelFeeCap.address)\n        }\n\n        // change the duration of offers before they expire\n        pub fun setOfferDuration(duration: UFix64) {\n            TheFabricantMarketplace.offerDuration = duration\n            emit OfferDurationChanged(duration: duration)\n        }\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change contract royalty address"}, {"role": "assistant", "content": "pub fun setChannelFeeCap(channelFeeCap: Capability<&{FungibleToken.Receiver}>) {\n            pre {\n                channelFeeCap.check(): \n                    \"Channel Fee FungibleToken Receiver Capability invalid\"\n            }\n            TheFabricantMarketplace.channelFeeCap = channelFeeCap\n            emit ChannelFeeCapSet(channelFeeCapAddress: channelFeeCap.address)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change the duration of offers before they expire"}, {"role": "assistant", "content": "pub fun setOfferDuration(duration: UFix64) {\n            TheFabricantMarketplace.offerDuration = duration\n            emit OfferDurationChanged(duration: duration)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the amount of times each nft is sold/accepted by listing/offerID"}, {"role": "assistant", "content": "pub fun getNFTSaleCounts(): {String: UInt32} {\n        return TheFabricantMarketplace.nftSaleCount\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: get the amount of times an nft is sold/accepted by listing/offerID"}, {"role": "assistant", "content": "pub fun getNFTSaleCount(typeID: String): UInt32{\n        return TheFabricantMarketplace.nftSaleCount[typeID]!\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: return the channelFeeCapability of the marketplace"}, {"role": "assistant", "content": "pub fun getChannelFeeCap(): Capability<&{FungibleToken.Receiver}>? {\n        return TheFabricantMarketplace.channelFeeCap\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: concat an nft's type and id into a single stirng"}, {"role": "assistant", "content": "pub fun typeID(type: Type, id: UInt64): String {\n        return type.identifier.concat(\"_\").concat(id.toString())\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: events emitted when an nft is listed or an offer is made for an nft"}, {"role": "assistant", "content": "pub event S0ItemListed(listingID: String, nftType: Type, nftID: UInt64, ftVaultType: Type, price: UFix64, seller: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: events emitted when an nft is listed or an offer is made for an nft"}, {"role": "assistant", "content": "(listingID: String, nftType: Type, nftID: UInt64, ftVaultType: Type, price: UFix64, seller: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: dictionary of name of royalty recipient to their salecut amounts"}, {"role": "assistant", "content": "access(self) var saleCuts: {String: SaleCutValues}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: list an s0Item from ItemNFT contract, calling TheFabricantMarketplace's Listings' createListing function"}, {"role": "assistant", "content": "pub fun s0ListItem(        \n        itemRef: &ItemNFT.NFT,\n        listingRef: &TheFabricantMarketplace.Listings,\n        nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftID: UInt64,\n        paymentCapability: Capability<&{FungibleToken.Receiver}>,\n        salePaymentVaultType: Type,\n        price: UFix64) {\n\n        //get the flowToken capabilities for each component of the item (garment, item, material)\n        let itemCap = getAccount(itemRef.royaltyVault.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)    \n        let garmentCap = getAccount(itemRef.borrowGarment()!.royaltyVault.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        let materialCap = getAccount(itemRef.borrowMaterial()!.royaltyVault.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\n        // initialize sale cuts for item, garment, material and contract\n        let saleCutArray: [TheFabricantMarketplace.SaleCut] =\n        [TheFabricantMarketplace.SaleCut(name: \"Season 0 Item Creator\", receiver: itemCap,  initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"item\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"item\"]!.amount),\n        TheFabricantMarketplace.SaleCut(name: \"Season 0 Garment Creator\", receiver: garmentCap, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"garment\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"garment\"]!.amount),\n        TheFabricantMarketplace.SaleCut(name: \"Season 0 Material Creator\", receiver: materialCap, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"material\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"material\"]!.amount),\n        TheFabricantMarketplace.SaleCut(name: \"Channel Fee Royalty\", receiver: TheFabricantMarketplace.getChannelFeeCap()!, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.amount)]\n \n        let listingID = listingRef.createListing(\n            nftProviderCapability: nftProviderCapability, \n            nftType: nftType, \n            nftID: nftID, \n            paymentCapability: paymentCapability, \n            salePaymentVaultType: salePaymentVaultType, \n            price: price, \n            saleCuts: saleCutArray)\n\n        emit S0ItemListed(listingID: listingID, nftType: nftType, nftID: nftID, ftVaultType: salePaymentVaultType, price: price, seller: listingRef.owner?.address)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: make an offer for an s0Item from ItemNFT contract, calling TheFabricantMarketplace's Offers' makeOffer function"}, {"role": "assistant", "content": "pub fun s0ItemMakeOffer(       \n        initialNFTOwner: Address, \n        itemRef: &ItemNFT.NFT,\n        offerRef: &TheFabricantMarketplace.Offers,\n        ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n        nftType: Type,\n        nftID: UInt64,\n        nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>,\n        offerPaymentVaultType: Type,\n        price: UFix64) {\n\n        // get the flowToken capabilities for each component of the item (garment, item, material)\n        let itemCap = getAccount(itemRef.royaltyVault.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)    \n        let garmentCap = getAccount(itemRef.borrowGarment()!.royaltyVault.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        let materialCap = getAccount(itemRef.borrowMaterial()!.royaltyVault.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n\n        // initialize sale cuts for item, garment, material and channelFee\n        let saleCutArray: [TheFabricantMarketplace.SaleCut] =\n        [TheFabricantMarketplace.SaleCut(name: \"Season 0 Item Creator\", receiver: itemCap,  initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"item\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"item\"]!.amount),\n        TheFabricantMarketplace.SaleCut(name: \"Season 0 Garment Creator\", receiver: garmentCap, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"garment\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"garment\"]!.amount),\n        TheFabricantMarketplace.SaleCut(name: \"Season 0 Material Creator\", receiver: materialCap, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"material\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"material\"]!.amount),\n        TheFabricantMarketplace.SaleCut(name: \"Channel Fee Royalty\", receiver: TheFabricantMarketplace.getChannelFeeCap()!, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.amount)]\n\n        let offerID = offerRef.makeOffer(\n            initialNFTOwner: initialNFTOwner,\n            ftProviderCapability: ftProviderCapability,\n            offerPaymentVaultType: offerPaymentVaultType,\n            nftType: nftType, \n            nftID: nftID, \n            nftReceiverCapability: nftReceiver,\n            price: price, \n            saleCuts: saleCutArray)\n\n        emit S0ItemOfferMade(offerID: offerID, nftType: nftType, nftID: nftID,  ftVaultType: offerPaymentVaultType, price: price, offerer: offerRef.owner?.address, initialNFTOwner: initialNFTOwner)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: list an s1Item from TheFabricantS1ItemNFT contract, calling TheFabricantMarketplace's Listings' createListing function"}, {"role": "assistant", "content": "pub fun s1ListItem(        \n        itemRef: &TheFabricantS1ItemNFT.NFT,\n        listingRef: &TheFabricantMarketplace.Listings,\n        nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftID: UInt64,\n        paymentCapability: Capability<&{FungibleToken.Receiver}>,\n        salePaymentVaultType: Type,\n        price: UFix64) {\n\n        // get the flowToken capabilities for each component of the item (garment, item, material)\n        let itemCap = getAccount(itemRef.royaltyVault.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        let garmentData = itemRef.borrowGarment()!.garment.garmentDataID\n        let garmentRoyalties = TheFabricantS1GarmentNFT.getGarmentData(id: garmentData).getRoyalty()\n        let materialData = itemRef.borrowMaterial()!.material.materialDataID\n        let materialRoyalties = TheFabricantS1MaterialNFT.getMaterialData(id: materialData).getRoyalty()\n\n        var saleCutArray: [TheFabricantMarketplace.SaleCut] = []\n        // initialize sale cuts for item, garment, material and contract\n        // add all flowToken capabilities for garment creators\n        for key in garmentRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 1 Garment Creator\", \n                receiver: garmentRoyalties[key]!.wallet,\n                //receiver: getAccount(garmentRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: garmentRoyalties[key]!.initialCut, \n                amount: garmentRoyalties[key]!.cut))\n        }\n        // add all flowToken capabilities for material creators\n        for key in materialRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 1 Material Creator\",\n                receiver: materialRoyalties[key]!.wallet,\n                //receiver: getAccount(materialRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: materialRoyalties[key]!.initialCut, \n                amount: materialRoyalties[key]!.cut))\n        }\n\n        // add the flowToken capabilities for item creator and channel fee\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Season 1 Item Creator\", receiver: itemCap, initialAmount: itemRef.royaltyVault.initialCut, amount: itemRef.royaltyVault.cut))\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Channel Fee Royalty\", receiver: TheFabricantMarketplace.getChannelFeeCap()!, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.amount))\n          \n        let listingID = listingRef.createListing(\n            nftProviderCapability: nftProviderCapability, \n            nftType: nftType, \n            nftID: nftID, \n            paymentCapability: paymentCapability, \n            salePaymentVaultType: salePaymentVaultType, \n            price: price, \n            saleCuts: saleCutArray)\n\n        emit S1ItemListed(listingID: listingID, nftType: nftType, nftID: nftID, ftVaultType: salePaymentVaultType, price: price, seller: listingRef.owner?.address)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: make an offer for an s1Item from TheFabricantS1ItemNFT contract, calling TheFabricantMarketplace's Offers' makeOffer function"}, {"role": "assistant", "content": "pub fun s1ItemMakeOffer(       \n        initialNFTOwner: Address, \n        itemRef: &TheFabricantS1ItemNFT.NFT,\n        offerRef: &TheFabricantMarketplace.Offers,\n        ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n        nftType: Type,\n        nftID: UInt64,\n        nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>,\n        offerPaymentVaultType: Type,\n        price: UFix64) {\n\n        // get all FlowToken royalty capabilities\n        let itemCap = getAccount(itemRef.royaltyVault.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        let garmentData = itemRef.borrowGarment()!.garment.garmentDataID\n        let garmentRoyalties = TheFabricantS1GarmentNFT.getGarmentData(id: garmentData).getRoyalty()\n        let materialData = itemRef.borrowMaterial()!.material.materialDataID\n        let materialRoyalties = TheFabricantS1MaterialNFT.getMaterialData(id: materialData).getRoyalty()\n\n        var saleCutArray: [TheFabricantMarketplace.SaleCut] = []\n\n        // initialize sale cuts for item, garment, material and contract\n\n        // add all flowToken capabilities for garment creators\n        for key in garmentRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 1 Garment Creator\", \n                receiver: garmentRoyalties[key]!.wallet,\n                //receiver: getAccount(garmentRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: garmentRoyalties[key]!.initialCut, \n                amount: garmentRoyalties[key]!.cut))\n        }\n            \n        // add all flowToken capabilities for material creators\n        for key in materialRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 1 Material Creator\",\n                receiver: materialRoyalties[key]!.wallet,\n                //receiver: getAccount(materialRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: materialRoyalties[key]!.initialCut, \n                amount: materialRoyalties[key]!.cut))\n        }\n\n        // add the flowToken capabilities for item creator and channel fee\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Season 1 Item Creator\", receiver: itemCap, initialAmount: itemRef.royaltyVault.initialCut, amount: itemRef.royaltyVault.cut))\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Channel Fee Royalty\", receiver: TheFabricantMarketplace.getChannelFeeCap()!, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.amount))\n\n        let offerID = offerRef.makeOffer(\n            initialNFTOwner: initialNFTOwner,\n            ftProviderCapability: ftProviderCapability,\n            offerPaymentVaultType: offerPaymentVaultType,\n            nftType: nftType, \n            nftID: nftID, \n            nftReceiverCapability: nftReceiver,\n            price: price, \n            saleCuts: saleCutArray)\n\n        emit S1ItemOfferMade(offerID: offerID, nftType: nftType, nftID: nftID, ftVaultType: offerPaymentVaultType, price: price, offerer: offerRef.owner?.address, initialNFTOwner: initialNFTOwner)\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: list an s2Item from TheFabricantS2ItemNFT contract, calling TheFabricantMarketplace's Listings' createListing function"}, {"role": "assistant", "content": "pub fun s2ListItem(        \n        itemRef: &TheFabricantS2ItemNFT.NFT,\n        listingRef: &TheFabricantMarketplace.Listings,\n        nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,\n        nftType: Type,\n        nftID: UInt64,\n        paymentCapability: Capability<&{FungibleToken.Receiver}>,\n        salePaymentVaultType: Type,\n        price: UFix64) {\n\n        // get the flowToken capabilities for each component of the item (garment, item, material)\n        let itemCap = getAccount(itemRef.royaltyVault.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        let garmentData = itemRef.borrowGarment()!.garment.garmentDataID\n        let garmentRoyalties = TheFabricantS2GarmentNFT.getGarmentData(id: garmentData).getRoyalty()\n        let materialData = itemRef.borrowMaterial()!.material.materialDataID\n        let materialRoyalties = TheFabricantS2MaterialNFT.getMaterialData(id: materialData).getRoyalty()\n\n        var saleCutArray: [TheFabricantMarketplace.SaleCut] = []\n        // initialize sale cuts for item, garment, material and contract\n        // add all flowToken capabilities for garment creators\n        for key in garmentRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 2 Garment Creator\", \n                receiver: garmentRoyalties[key]!.wallet,\n                //receiver: getAccount(garmentRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: garmentRoyalties[key]!.initialCut, \n                amount: garmentRoyalties[key]!.cut))\n        }\n        // add all flowToken capabilities for material creators\n        for key in materialRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 2 Material Creator\",\n                receiver: materialRoyalties[key]!.wallet,\n                //receiver: getAccount(materialRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: materialRoyalties[key]!.initialCut, \n                amount: materialRoyalties[key]!.cut))\n        }\n\n        // add the flowToken capabilities for item creator and channel fee\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Season 2 Item Creator\", receiver: itemCap, initialAmount: itemRef.royaltyVault.initialCut, amount: itemRef.royaltyVault.cut))\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Channel Fee Royalty\", receiver: TheFabricantMarketplace.getChannelFeeCap()!, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.amount))\n          \n        let listingID = listingRef.createListing(\n            nftProviderCapability: nftProviderCapability, \n            nftType: nftType, \n            nftID: nftID, \n            paymentCapability: paymentCapability, \n            salePaymentVaultType: salePaymentVaultType, \n            price: price, \n            saleCuts: saleCutArray)\n\n        emit S2ItemListed(listingID: listingID, nftType: nftType, nftID: nftID, ftVaultType: salePaymentVaultType, price: price, seller: listingRef.owner?.address)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: make an offer for an s1Item from TheFabricantS1ItemNFT contract, calling TheFabricantMarketplace's Offers' makeOffer function"}, {"role": "assistant", "content": "pub fun s2ItemMakeOffer(       \n        initialNFTOwner: Address, \n        itemRef: &TheFabricantS2ItemNFT.NFT,\n        offerRef: &TheFabricantMarketplace.Offers,\n        ftProviderCapability: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>,\n        nftType: Type,\n        nftID: UInt64,\n        nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>,\n        offerPaymentVaultType: Type,\n        price: UFix64) {\n\n        // get all FlowToken royalty capabilities\n        let itemCap = getAccount(itemRef.royaltyVault.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)\n        let garmentData = itemRef.borrowGarment()!.garment.garmentDataID\n        let garmentRoyalties = TheFabricantS2GarmentNFT.getGarmentData(id: garmentData).getRoyalty()\n        let materialData = itemRef.borrowMaterial()!.material.materialDataID\n        let materialRoyalties = TheFabricantS2MaterialNFT.getMaterialData(id: materialData).getRoyalty()\n\n        var saleCutArray: [TheFabricantMarketplace.SaleCut] = []\n\n        // initialize sale cuts for item, garment, material and contract\n\n        // add all flowToken capabilities for garment creators\n        for key in garmentRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 2 Garment Creator\", \n                receiver: garmentRoyalties[key]!.wallet,\n                //receiver: getAccount(garmentRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: garmentRoyalties[key]!.initialCut, \n                amount: garmentRoyalties[key]!.cut))\n        }\n            \n        // add all flowToken capabilities for material creators\n        for key in materialRoyalties.keys {\n            saleCutArray.append(TheFabricantMarketplace.SaleCut(\n                name: \"Season 2 Material Creator\",\n                receiver: materialRoyalties[key]!.wallet,\n                //receiver: getAccount(materialRoyalties[key]!.wallet.address).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),\n                initialAmount: materialRoyalties[key]!.initialCut, \n                amount: materialRoyalties[key]!.cut))\n        }\n\n        // add the flowToken capabilities for item creator and channel fee\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Season 2 Item Creator\", receiver: itemCap, initialAmount: itemRef.royaltyVault.initialCut, amount: itemRef.royaltyVault.cut))\n        saleCutArray.append(TheFabricantMarketplace.SaleCut(name: \"Channel Fee Royalty\", receiver: TheFabricantMarketplace.getChannelFeeCap()!, initialAmount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.initialAmount, amount: TheFabricantMarketplaceHelper.saleCuts[\"channelFee\"]!.amount))\n\n        let offerID = offerRef.makeOffer(\n            initialNFTOwner: initialNFTOwner,\n            ftProviderCapability: ftProviderCapability,\n            offerPaymentVaultType: offerPaymentVaultType,\n            nftType: nftType, \n            nftID: nftID, \n            nftReceiverCapability: nftReceiver,\n            price: price, \n            saleCuts: saleCutArray)\n\n        emit S2ItemOfferMade(offerID: offerID, nftType: nftType, nftID: nftID, ftVaultType: offerPaymentVaultType, price: price, offerer: offerRef.owner?.address, initialNFTOwner: initialNFTOwner)\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin\nAdmin can add salecutvalues"}, {"role": "assistant", "content": "pub resource Admin{\n        \n        // change contract royalty address\n        pub fun addSaleCutValues(royaltyName: String, initialAmount: UFix64, amount: UFix64){\n            TheFabricantMarketplaceHelper.saleCuts[royaltyName] = \n                TheFabricantMarketplaceHelper.SaleCutValues(initialAmount: initialAmount, amount: amount)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: change contract royalty address"}, {"role": "assistant", "content": "pub fun addSaleCutValues(royaltyName: String, initialAmount: UFix64, amount: UFix64){\n            TheFabricantMarketplaceHelper.saleCuts[royaltyName] = \n                TheFabricantMarketplaceHelper.SaleCutValues(initialAmount: initialAmount, amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: toAddressType: SOL, SPL"}, {"role": "assistant", "content": "pub fun lock(from: @FungibleToken.Vault, to: [UInt8], toAddressType: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: toAddressType: SOL, SPL"}, {"role": "assistant", "content": "pub fun lock(from: @FungibleToken.Vault, to: [UInt8], toAddressType: String) {\n      pre {\n        !TeleportCustodySolana.isFrozen: \"Teleport service is frozen\"\n        to.length == TeleportCustodySolana.teleportAddressLength: \"Teleport address should be teleportAddressLength bytes\"\n      }\n\n      let vault <- from as! @BloctoToken.Vault\n      let fee <- vault.withdraw(amount: self.lockFee)\n\n      self.feeCollector.deposit(from: <-fee)\n\n      let amount = vault.balance\n      TeleportCustodySolana.lockVault.deposit(from: <-vault)\n\n      emit Locked(amount: amount, to: to, toAddressType: toAddressType)\n      emit FeeCollected(amount: self.lockFee, type: 0)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the TopShot contract is created"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the TopShot contract is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Play struct is created"}, {"role": "assistant", "content": "pub event PlayCreated(id: UInt32, metadata: {String:String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Play struct is created"}, {"role": "assistant", "content": "(id: UInt32, metadata: {String:String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new series has been triggered by an admin"}, {"role": "assistant", "content": "pub event NewSeriesStarted(newCurrentSeries: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new series has been triggered by an admin"}, {"role": "assistant", "content": "(newCurrentSeries: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Set-Related actions\n\nEmitted when a new Set is created"}, {"role": "assistant", "content": "pub event SetCreated(setID: UInt32, series: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Set-Related actions\n\nEmitted when a new Set is created"}, {"role": "assistant", "content": "(setID: UInt32, series: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Play is added to a Set"}, {"role": "assistant", "content": "pub event PlayAddedToSet(setID: UInt32, playID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Play is added to a Set"}, {"role": "assistant", "content": "(setID: UInt32, playID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Play is retired from a Set and cannot be used to mint"}, {"role": "assistant", "content": "pub event PlayRetiredFromSet(setID: UInt32, playID: UInt32, numMoments: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Play is retired from a Set and cannot be used to mint"}, {"role": "assistant", "content": "(setID: UInt32, playID: UInt32, numMoments: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Set is locked, meaning Plays cannot be added"}, {"role": "assistant", "content": "pub event SetLocked(setID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Set is locked, meaning Plays cannot be added"}, {"role": "assistant", "content": "(setID: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Moment is minted from a Set"}, {"role": "assistant", "content": "pub event MomentMinted(momentID: UInt64, playID: UInt32, setID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Moment is minted from a Set"}, {"role": "assistant", "content": "(momentID: UInt64, playID: UInt32, setID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a moment is withdrawn from a Collection"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a moment is withdrawn from a Collection"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a moment is deposited into a Collection"}, {"role": "assistant", "content": "pub event Deposit(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a moment is deposited into a Collection"}, {"role": "assistant", "content": "(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Moment is destroyed"}, {"role": "assistant", "content": "pub event MomentDestroyed(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Moment is destroyed"}, {"role": "assistant", "content": "(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Series that this Set belongs to.\nSeries is a concept that indicates a group of Sets through time.\nMany Sets can exist at a time, but only one series."}, {"role": "assistant", "content": "pub var currentSeries: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of Play structs"}, {"role": "assistant", "content": "access(self) var playDatas: {UInt32: Play}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of SetData structs"}, {"role": "assistant", "content": "access(self) var setDatas: {UInt32: SetData}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of Set resources"}, {"role": "assistant", "content": "access(self) var sets: @{UInt32: Set}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID that is used to create Plays.\nEvery time a Play is created, playID is assigned\nto the new Play's ID and then is incremented by 1."}, {"role": "assistant", "content": "pub var nextPlayID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID that is used to create Sets. Every time a Set is created\nsetID is assigned to the new set's ID and then is incremented by 1."}, {"role": "assistant", "content": "pub var nextSetID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The total number of Top shot Moment NFTs that have been created\nBecause NFTs can be destroyed, it doesn't necessarily mean that this\nreflects the total number of NFTs in existence, just the number that\nhave been minted to date. Also used as global moment IDs for minting."}, {"role": "assistant", "content": "pub var totalSupply: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Play is a Struct that holds metadata associated\nwith a specific NBA play, like the legendary moment when\nRay Allen hit the 3 to tie the Heat and Spurs in the 2013 finals game 6\nor when Lance Stephenson blew in the ear of Lebron James.\n\nMoment NFTs will all reference a single play as the owner of\nits metadata. The plays are publicly accessible, so anyone can\nread the metadata associated with a specific play ID\n"}, {"role": "assistant", "content": "pub struct Play {\n\n        // The unique ID for the Play\n        pub let playID: UInt32\n\n        // Stores all the metadata about the play as a string mapping\n        // This is not the long term way NFT metadata will be stored. It's a temporary\n        // construct while we figure out a better way to do metadata.\n        //\n        pub let metadata: {String: String}\n\n        init(metadata: {String: String}) {\n            pre {\n                metadata.length != 0: \"New Play metadata cannot be empty\"\n            }\n            self.playID = TopShot.nextPlayID\n            self.metadata = metadata\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The unique ID for the Play"}, {"role": "assistant", "content": "pub let playID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Stores all the metadata about the play as a string mapping\nThis is not the long term way NFT metadata will be stored. It's a temporary\nconstruct while we figure out a better way to do metadata.\n"}, {"role": "assistant", "content": "pub let metadata: {String: String}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Set is a grouping of Plays that have occured in the real world\nthat make up a related group of collectibles, like sets of baseball\nor Magic cards. A Play can exist in multiple different sets.\n\nSetData is a struct that is stored in a field of the contract.\nAnyone can query the constant information\nabout a set by calling various getters located\nat the end of the contract. Only the admin has the ability\nto modify any data in the private Set resource.\n"}, {"role": "assistant", "content": "pub struct SetData {\n\n        // Unique ID for the Set\n        pub let setID: UInt32\n\n        // Name of the Set\n        // ex. \"Times when the Toronto Raptors choked in the playoffs\"\n        pub let name: String\n\n        // Series that this Set belongs to.\n        // Series is a concept that indicates a group of Sets through time.\n        // Many Sets can exist at a time, but only one series.\n        pub let series: UInt32\n\n        init(name: String) {\n            pre {\n                name.length > 0: \"New Set name cannot be empty\"\n            }\n            self.setID = TopShot.nextSetID\n            self.name = name\n            self.series = TopShot.currentSeries\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Unique ID for the Set"}, {"role": "assistant", "content": "pub let setID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Name of the Set\nex. \"Times when the Toronto Raptors choked in the playoffs\""}, {"role": "assistant", "content": "pub let name: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Series that this Set belongs to.\nSeries is a concept that indicates a group of Sets through time.\nMany Sets can exist at a time, but only one series."}, {"role": "assistant", "content": "pub let series: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Set is a resource type that contains the functions to add and remove\nPlays from a set and mint Moments.\n\nIt is stored in a private field in the contract so that\nthe admin resource can call its methods.\n\nThe admin can add Plays to a Set so that the set can mint Moments\nthat reference that playdata.\nThe Moments that are minted by a Set will be listed as belonging to\nthe Set that minted it, as well as the Play it references.\n\nAdmin can also retire Plays from the Set, meaning that the retired\nPlay can no longer have Moments minted from it.\n\nIf the admin locks the Set, no more Plays can be added to it, but\nMoments can still be minted.\n\nIf retireAll() and lock() are called back-to-back,\nthe Set is closed off forever and nothing more can be done with it."}, {"role": "assistant", "content": "pub resource Set {\n\n        // Unique ID for the set\n        pub let setID: UInt32\n\n        // Array of plays that are a part of this set.\n        // When a play is added to the set, its ID gets appended here.\n        // The ID does not get removed from this array when a Play is retired.\n        access(contract) var plays: [UInt32]\n\n        // Map of Play IDs that Indicates if a Play in this Set can be minted.\n        // When a Play is added to a Set, it is mapped to false (not retired).\n        // When a Play is retired, this is set to true and cannot be changed.\n        access(contract) var retired: {UInt32: Bool}\n\n        // Indicates if the Set is currently locked.\n        // When a Set is created, it is unlocked \n        // and Plays are allowed to be added to it.\n        // When a set is locked, Plays cannot be added.\n        // A Set can never be changed from locked to unlocked,\n        // the decision to lock a Set it is final.\n        // If a Set is locked, Plays cannot be added, but\n        // Moments can still be minted from Plays\n        // that exist in the Set.\n        pub var locked: Bool\n\n        // Mapping of Play IDs that indicates the number of Moments \n        // that have been minted for specific Plays in this Set.\n        // When a Moment is minted, this value is stored in the Moment to\n        // show its place in the Set, eg. 13 of 60.\n        access(contract) var numberMintedPerPlay: {UInt32: UInt32}\n\n        init(name: String) {\n            self.setID = TopShot.nextSetID\n            self.plays = []\n            self.retired = {}\n            self.locked = false\n            self.numberMintedPerPlay = {}\n\n            // Create a new SetData for this Set and store it in contract storage\n            TopShot.setDatas[self.setID] = SetData(name: name)\n        }\n\n        // addPlay adds a play to the set\n        //\n        // Parameters: playID: The ID of the Play that is being added\n        //\n        // Pre-Conditions:\n        // The Play needs to be an existing play\n        // The Set needs to be not locked\n        // The Play can't have already been added to the Set\n        //\n        pub fun addPlay(playID: UInt32) {\n            pre {\n                TopShot.playDatas[playID] != nil: \"Cannot add the Play to Set: Play doesn't exist.\"\n                !self.locked: \"Cannot add the play to the Set after the set has been locked.\"\n                self.numberMintedPerPlay[playID] == nil: \"The play has already beed added to the set.\"\n            }\n\n            // Add the Play to the array of Plays\n            self.plays.append(playID)\n\n            // Open the Play up for minting\n            self.retired[playID] = false\n\n            // Initialize the Moment count to zero\n            self.numberMintedPerPlay[playID] = 0\n\n            emit PlayAddedToSet(setID: self.setID, playID: playID)\n        }\n\n        // addPlays adds multiple Plays to the Set\n        //\n        // Parameters: playIDs: The IDs of the Plays that are being added\n        //                      as an array\n        //\n        pub fun addPlays(playIDs: [UInt32]) {\n            for play in playIDs {\n                self.addPlay(playID: play)\n            }\n        }\n\n        // retirePlay retires a Play from the Set so that it can't mint new Moments\n        //\n        // Parameters: playID: The ID of the Play that is being retired\n        //\n        // Pre-Conditions:\n        // The Play is part of the Set and not retired (available for minting).\n        // \n        pub fun retirePlay(playID: UInt32) {\n            pre {\n                self.retired[playID] != nil: \"Cannot retire the Play: Play doesn't exist in this set!\"\n            }\n\n            if !self.retired[playID]! {\n                self.retired[playID] = true\n\n                emit PlayRetiredFromSet(setID: self.setID, playID: playID, numMoments: self.numberMintedPerPlay[playID]!)\n            }\n        }\n\n        // retireAll retires all the plays in the Set\n        // Afterwards, none of the retired Plays will be able to mint new Moments\n        //\n        pub fun retireAll() {\n            for play in self.plays {\n                self.retirePlay(playID: play)\n            }\n        }\n\n        // lock() locks the Set so that no more Plays can be added to it\n        //\n        // Pre-Conditions:\n        // The Set should not be locked\n        pub fun lock() {\n            if !self.locked {\n                self.locked = true\n                emit SetLocked(setID: self.setID)\n            }\n        }\n\n        // mintMoment mints a new Moment and returns the newly minted Moment\n        // \n        // Parameters: playID: The ID of the Play that the Moment references\n        //\n        // Pre-Conditions:\n        // The Play must exist in the Set and be allowed to mint new Moments\n        //\n        // Returns: The NFT that was minted\n        // \n        pub fun mintMoment(playID: UInt32): @NFT {\n            pre {\n                self.retired[playID] != nil: \"Cannot mint the moment: This play doesn't exist.\"\n                !self.retired[playID]!: \"Cannot mint the moment from this play: This play has been retired.\"\n            }\n\n            // Gets the number of Moments that have been minted for this Play\n            // to use as this Moment's serial number\n            let numInPlay = self.numberMintedPerPlay[playID]!\n\n            // Mint the new moment\n            let newMoment: @NFT <- create NFT(serialNumber: numInPlay + UInt32(1),\n                                              playID: playID,\n                                              setID: self.setID)\n\n            // Increment the count of Moments minted for this Play\n            self.numberMintedPerPlay[playID] = numInPlay + UInt32(1)\n\n            return <-newMoment\n        }\n\n        // batchMintMoment mints an arbitrary quantity of Moments \n        // and returns them as a Collection\n        //\n        // Parameters: playID: the ID of the Play that the Moments are minted for\n        //             quantity: The quantity of Moments to be minted\n        //\n        // Returns: Collection object that contains all the Moments that were minted\n        //\n        pub fun batchMintMoment(playID: UInt32, quantity: UInt64): @Collection {\n            let newCollection <- create Collection()\n\n            var i: UInt64 = 0\n            while i < quantity {\n                newCollection.deposit(token: <-self.mintMoment(playID: playID))\n                i = i + UInt64(1)\n            }\n\n            return <-newCollection\n        }\n\n        pub fun getPlays(): [UInt32] {\n            return self.plays\n        }\n\n        pub fun getRetired(): {UInt32: Bool} {\n            return self.retired\n        }\n\n        pub fun getNumMintedPerPlay(): {UInt32: UInt32} {\n            return self.numberMintedPerPlay\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Unique ID for the set"}, {"role": "assistant", "content": "pub let setID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Array of plays that are a part of this set.\nWhen a play is added to the set, its ID gets appended here.\nThe ID does not get removed from this array when a Play is retired."}, {"role": "assistant", "content": "access(contract) var plays: [UInt32]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Map of Play IDs that Indicates if a Play in this Set can be minted.\nWhen a Play is added to a Set, it is mapped to false (not retired).\nWhen a Play is retired, this is set to true and cannot be changed."}, {"role": "assistant", "content": "access(contract) var retired: {UInt32: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Indicates if the Set is currently locked.\nWhen a Set is created, it is unlocked\nand Plays are allowed to be added to it.\nWhen a set is locked, Plays cannot be added.\nA Set can never be changed from locked to unlocked,\nthe decision to lock a Set it is final.\nIf a Set is locked, Plays cannot be added, but\nMoments can still be minted from Plays\nthat exist in the Set."}, {"role": "assistant", "content": "pub var locked: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mapping of Play IDs that indicates the number of Moments\nthat have been minted for specific Plays in this Set.\nWhen a Moment is minted, this value is stored in the Moment to\nshow its place in the Set, eg. 13 of 60."}, {"role": "assistant", "content": "access(contract) var numberMintedPerPlay: {UInt32: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: addPlay adds a play to the set\n\nParameters: playID: The ID of the Play that is being added\n\nPre-Conditions:\nThe Play needs to be an existing play\nThe Set needs to be not locked\nThe Play can't have already been added to the Set\n"}, {"role": "assistant", "content": "pub fun addPlay(playID: UInt32) {\n            pre {\n                TopShot.playDatas[playID] != nil: \"Cannot add the Play to Set: Play doesn't exist.\"\n                !self.locked: \"Cannot add the play to the Set after the set has been locked.\"\n                self.numberMintedPerPlay[playID] == nil: \"The play has already beed added to the set.\"\n            }\n\n            // Add the Play to the array of Plays\n            self.plays.append(playID)\n\n            // Open the Play up for minting\n            self.retired[playID] = false\n\n            // Initialize the Moment count to zero\n            self.numberMintedPerPlay[playID] = 0\n\n            emit PlayAddedToSet(setID: self.setID, playID: playID)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: addPlays adds multiple Plays to the Set\n\nParameters: playIDs: The IDs of the Plays that are being added\nas an array\n"}, {"role": "assistant", "content": "pub fun addPlays(playIDs: [UInt32]) {\n            for play in playIDs {\n                self.addPlay(playID: play)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: retirePlay retires a Play from the Set so that it can't mint new Moments\n\nParameters: playID: The ID of the Play that is being retired\n\nPre-Conditions:\nThe Play is part of the Set and not retired (available for minting).\n"}, {"role": "assistant", "content": "pub fun retirePlay(playID: UInt32) {\n            pre {\n                self.retired[playID] != nil: \"Cannot retire the Play: Play doesn't exist in this set!\"\n            }\n\n            if !self.retired[playID]! {\n                self.retired[playID] = true\n\n                emit PlayRetiredFromSet(setID: self.setID, playID: playID, numMoments: self.numberMintedPerPlay[playID]!)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: retireAll retires all the plays in the Set\nAfterwards, none of the retired Plays will be able to mint new Moments\n"}, {"role": "assistant", "content": "pub fun retireAll() {\n            for play in self.plays {\n                self.retirePlay(playID: play)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: lock() locks the Set so that no more Plays can be added to it\n\nPre-Conditions:\nThe Set should not be locked"}, {"role": "assistant", "content": "pub fun lock() {\n            if !self.locked {\n                self.locked = true\n                emit SetLocked(setID: self.setID)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintMoment mints a new Moment and returns the newly minted Moment\n\nParameters: playID: The ID of the Play that the Moment references\n\nPre-Conditions:\nThe Play must exist in the Set and be allowed to mint new Moments\n\nReturns: The NFT that was minted\n"}, {"role": "assistant", "content": "pub fun mintMoment(playID: UInt32): @NFT {\n            pre {\n                self.retired[playID] != nil: \"Cannot mint the moment: This play doesn't exist.\"\n                !self.retired[playID]!: \"Cannot mint the moment from this play: This play has been retired.\"\n            }\n\n            // Gets the number of Moments that have been minted for this Play\n            // to use as this Moment's serial number\n            let numInPlay = self.numberMintedPerPlay[playID]!\n\n            // Mint the new moment\n            let newMoment: @NFT <- create NFT(serialNumber: numInPlay + UInt32(1),\n                                              playID: playID,\n                                              setID: self.setID)\n\n            // Increment the count of Moments minted for this Play\n            self.numberMintedPerPlay[playID] = numInPlay + UInt32(1)\n\n            return <-newMoment\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchMintMoment mints an arbitrary quantity of Moments\nand returns them as a Collection\n\nParameters: playID: the ID of the Play that the Moments are minted for\nquantity: The quantity of Moments to be minted\n\nReturns: Collection object that contains all the Moments that were minted\n"}, {"role": "assistant", "content": "pub fun batchMintMoment(playID: UInt32, quantity: UInt64): @Collection {\n            let newCollection <- create Collection()\n\n            var i: UInt64 = 0\n            while i < quantity {\n                newCollection.deposit(token: <-self.mintMoment(playID: playID))\n                i = i + UInt64(1)\n            }\n\n            return <-newCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Struct that contains all of the important data about a set\nCan be easily queried by instantiating the `QuerySetData` object\nwith the desired set ID\nlet setData = TopShot.QuerySetData(setID: 12)\n"}, {"role": "assistant", "content": "pub struct QuerySetData {\n        pub let setID: UInt32\n        pub let name: String\n        pub let series: UInt32\n        access(self) var plays: [UInt32]\n        access(self) var retired: {UInt32: Bool}\n        pub var locked: Bool\n        access(self) var numberMintedPerPlay: {UInt32: UInt32}\n\n        init(setID: UInt32) {\n            pre {\n                TopShot.sets[setID] != nil: \"The set with the provided ID does not exist\"\n            }\n\n            let set = (&TopShot.sets[setID] as &Set?)!\n            let setData = TopShot.setDatas[setID]!\n\n            self.setID = setID\n            self.name = setData.name\n            self.series = setData.series\n            self.plays = set.plays\n            self.retired = set.retired\n            self.locked = set.locked\n            self.numberMintedPerPlay = set.numberMintedPerPlay\n        }\n\n        pub fun getPlays(): [UInt32] {\n            return self.plays\n        }\n\n        pub fun getRetired(): {UInt32: Bool} {\n            return self.retired\n        }\n\n        pub fun getNumberMintedPerPlay(): {UInt32: UInt32} {\n            return self.numberMintedPerPlay\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID of the Set that the Moment comes from"}, {"role": "assistant", "content": "pub let setID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The ID of the Play that the Moment references"}, {"role": "assistant", "content": "pub let playID: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The place in the edition that this Moment was minted\nOtherwise know as the serial number"}, {"role": "assistant", "content": "pub let serialNumber: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This is an implementation of a custom metadata view for Top Shot.\nThis view contains the play metadata.\n"}, {"role": "assistant", "content": "pub struct TopShotMomentMetadataView {\n\n        pub let fullName: String?\n        pub let firstName: String?\n        pub let lastName: String?\n        pub let birthdate: String?\n        pub let birthplace: String?\n        pub let jerseyNumber: String?\n        pub let draftTeam: String?\n        pub let draftYear: String?\n        pub let draftSelection: String?\n        pub let draftRound: String?\n        pub let teamAtMomentNBAID: String?\n        pub let teamAtMoment: String?\n        pub let primaryPosition: String?\n        pub let height: String?\n        pub let weight: String?\n        pub let totalYearsExperience: String?\n        pub let nbaSeason: String?\n        pub let dateOfMoment: String?\n        pub let playCategory: String?\n        pub let playType: String?\n        pub let homeTeamName: String?\n        pub let awayTeamName: String?\n        pub let homeTeamScore: String?\n        pub let awayTeamScore: String?\n        pub let seriesNumber: UInt32?\n        pub let setName: String?\n        pub let serialNumber: UInt32\n        pub let playID: UInt32\n        pub let setID: UInt32\n        pub let numMomentsInEdition: UInt32?\n\n        init(\n            fullName: String?,\n            firstName: String?,\n            lastName: String?,\n            birthdate: String?,\n            birthplace: String?,\n            jerseyNumber: String?,\n            draftTeam: String?,\n            draftYear: String?,\n            draftSelection: String?,\n            draftRound: String?,\n            teamAtMomentNBAID: String?,\n            teamAtMoment: String?,\n            primaryPosition: String?,\n            height: String?,\n            weight: String?,\n            totalYearsExperience: String?,\n            nbaSeason: String?,\n            dateOfMoment: String?,\n            playCategory: String?,\n            playType: String?,\n            homeTeamName: String?,\n            awayTeamName: String?,\n            homeTeamScore: String?,\n            awayTeamScore: String?,\n            seriesNumber: UInt32?,\n            setName: String?,\n            serialNumber: UInt32,\n            playID: UInt32,\n            setID: UInt32,\n            numMomentsInEdition: UInt32?\n        ) {\n            self.fullName = fullName\n            self.firstName = firstName\n            self.lastName = lastName\n            self.birthdate = birthdate\n            self.birthplace = birthplace\n            self.jerseyNumber = jerseyNumber\n            self.draftTeam = draftTeam\n            self.draftYear = draftYear\n            self.draftSelection = draftSelection\n            self.draftRound = draftRound\n            self.teamAtMomentNBAID = teamAtMomentNBAID\n            self.teamAtMoment = teamAtMoment\n            self.primaryPosition = primaryPosition\n            self.height = height\n            self.weight = weight\n            self.totalYearsExperience = totalYearsExperience\n            self.nbaSeason = nbaSeason\n            self.dateOfMoment= dateOfMoment\n            self.playCategory = playCategory\n            self.playType = playType\n            self.homeTeamName = homeTeamName\n            self.awayTeamName = awayTeamName\n            self.homeTeamScore = homeTeamScore\n            self.awayTeamScore = awayTeamScore\n            self.seriesNumber = seriesNumber\n            self.setName = setName\n            self.serialNumber = serialNumber\n            self.playID = playID\n            self.setID = setID\n            self.numMomentsInEdition = numMomentsInEdition\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The resource that represents the Moment NFTs\n"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {\n\n        // Global unique moment ID\n        pub let id: UInt64\n        \n        // Struct of Moment metadata\n        pub let data: MomentData\n\n        init(serialNumber: UInt32, playID: UInt32, setID: UInt32) {\n            // Increment the global Moment IDs\n            TopShot.totalSupply = TopShot.totalSupply + UInt64(1)\n\n            self.id = TopShot.totalSupply\n\n            // Set the metadata struct\n            self.data = MomentData(setID: setID, playID: playID, serialNumber: serialNumber)\n\n            emit MomentMinted(momentID: self.id, playID: playID, setID: self.data.setID, serialNumber: self.data.serialNumber)\n        }\n\n        // If the Moment is destroyed, emit an event to indicate \n        // to outside ovbservers that it has been destroyed\n        destroy() {\n            emit MomentDestroyed(id: self.id)\n        }\n\n        pub fun name(): String {\n            let fullName: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"FullName\") ?? \"\"\n            let playType: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"PlayType\") ?? \"\"\n            return fullName\n                .concat(\" \")\n                .concat(playType)\n        }\n\n        pub fun description(): String {\n            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? \"\"\n            let serialNumber: String = self.data.serialNumber.toString()\n            let seriesNumber: String = TopShot.getSetSeries(setID: self.data.setID)?.toString() ?? \"\"\n            return \"A series \"\n                .concat(seriesNumber)\n                .concat(\" \")\n                .concat(setName)\n                .concat(\" moment with serial number \")\n                .concat(serialNumber)\n        }\n\n        pub fun getViews(): [Type] {\n            return [\n                Type<MetadataViews.Display>(),\n                Type<TopShotMomentMetadataView>()\n            ]\n        }\n\n        pub fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: self.name(),\n                        description: self.description(),\n                        thumbnail: MetadataViews.HTTPFile(url:\"https://ipfs.dapperlabs.com/ipfs/Qmbdj1agtbzpPWZ81wCGaDiMKRFaRN3TU6cfztVCu6nh4o\")\n                    )\n                case Type<TopShotMomentMetadataView>():\n                    return TopShotMomentMetadataView(\n                        fullName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"FullName\"),\n                        firstName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"FirstName\"),\n                        lastName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"LastName\"),\n                        birthdate: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"Birthdate\"),\n                        birthplace: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"Birthplace\"),\n                        jerseyNumber: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"JerseyNumber\"),\n                        draftTeam: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"DraftTeam\"),\n                        draftYear: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"DraftYear\"),\n                        draftSelection: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"DraftSelection\"),\n                        draftRound: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"DraftRound\"),\n                        teamAtMomentNBAID: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"TeamAtMomentNBAID\"),\n                        teamAtMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"TeamAtMoment\"),\n                        primaryPosition: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"PrimaryPosition\"),\n                        height: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"Height\"),\n                        weight: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"Weight\"),\n                        totalYearsExperience: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"TotalYearsExperience\"),\n                        nbaSeason: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"NbaSeason\"),\n                        dateOfMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"DateOfMoment\"),\n                        playCategory: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"PlayCategory\"),\n                        playType: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"PlayType\"),\n                        homeTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"HomeTeamName\"),\n                        awayTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"AwayTeamName\"),\n                        homeTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"HomeTeamScore\"),\n                        awayTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: \"AwayTeamScore\"),\n                        seriesNumber: TopShot.getSetSeries(setID: self.data.setID),\n                        setName: TopShot.getSetName(setID: self.data.setID),\n                        serialNumber: self.data.serialNumber,\n                        playID: self.data.playID,\n                        setID: self.data.setID,\n                        numMomentsInEdition: TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID)\n                    )\n            }\n\n            return nil\n        }   \n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Global unique moment ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Struct of Moment metadata"}, {"role": "assistant", "content": "pub let data: MomentData"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: If the Moment is destroyed, emit an event to indicate\nto outside ovbservers that it has been destroyed"}, {"role": "assistant", "content": "destroy() {\n            emit MomentDestroyed(id: self.id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is a special authorization resource that\nallows the owner to perform important functions to modify the\nvarious aspects of the Plays, Sets, and Moments\n"}, {"role": "assistant", "content": "pub resource Admin {\n\n        // createPlay creates a new Play struct \n        // and stores it in the Plays dictionary in the TopShot smart contract\n        //\n        // Parameters: metadata: A dictionary mapping metadata titles to their data\n        //                       example: {\"Player Name\": \"Kevin Durant\", \"Height\": \"7 feet\"}\n        //                               (because we all know Kevin Durant is not 6'9\")\n        //\n        // Returns: the ID of the new Play object\n        //\n        pub fun createPlay(metadata: {String: String}): UInt32 {\n            // Create the new Play\n            var newPlay = Play(metadata: metadata)\n            let newID = newPlay.playID\n\n            // Increment the ID so that it isn't used again\n            TopShot.nextPlayID = TopShot.nextPlayID + UInt32(1)\n\n            emit PlayCreated(id: newPlay.playID, metadata: metadata)\n\n            // Store it in the contract storage\n            TopShot.playDatas[newID] = newPlay\n\n            return newID\n        }\n\n        // createSet creates a new Set resource and stores it\n        // in the sets mapping in the TopShot contract\n        //\n        // Parameters: name: The name of the Set\n        //\n        // Returns: The ID of the created set\n        pub fun createSet(name: String): UInt32 {\n\n            // Create the new Set\n            var newSet <- create Set(name: name)\n\n            // Increment the setID so that it isn't used again\n            TopShot.nextSetID = TopShot.nextSetID + UInt32(1)\n\n            let newID = newSet.setID\n\n            emit SetCreated(setID: newSet.setID, series: TopShot.currentSeries)\n\n            // Store it in the sets mapping field\n            TopShot.sets[newID] <-! newSet\n\n            return newID\n        }\n\n        // borrowSet returns a reference to a set in the TopShot\n        // contract so that the admin can call methods on it\n        //\n        // Parameters: setID: The ID of the Set that you want to\n        // get a reference to\n        //\n        // Returns: A reference to the Set with all of the fields\n        // and methods exposed\n        //\n        pub fun borrowSet(setID: UInt32): &Set {\n            pre {\n                TopShot.sets[setID] != nil: \"Cannot borrow Set: The Set doesn't exist\"\n            }\n            \n            // Get a reference to the Set and return it\n            // use `&` to indicate the reference to the object and type\n            return (&TopShot.sets[setID] as &Set?)!\n        }\n\n        // startNewSeries ends the current series by incrementing\n        // the series number, meaning that Moments minted after this\n        // will use the new series number\n        //\n        // Returns: The new series number\n        //\n        pub fun startNewSeries(): UInt32 {\n            // End the current series and start a new one\n            // by incrementing the TopShot series number\n            TopShot.currentSeries = TopShot.currentSeries + UInt32(1)\n\n            emit NewSeriesStarted(newCurrentSeries: TopShot.currentSeries)\n\n            return TopShot.currentSeries\n        }\n\n        // createNewAdmin creates a new Admin resource\n        //\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createPlay creates a new Play struct\nand stores it in the Plays dictionary in the TopShot smart contract\n\nParameters: metadata: A dictionary mapping metadata titles to their data\nexample: {\"Player Name\": \"Kevin Durant\", \"Height\": \"7 feet\"}\n(because we all know Kevin Durant is not 6'9\")\n\nReturns: the ID of the new Play object\n"}, {"role": "assistant", "content": "pub fun createPlay(metadata: {String: String}): UInt32 {\n            // Create the new Play\n            var newPlay = Play(metadata: metadata)\n            let newID = newPlay.playID\n\n            // Increment the ID so that it isn't used again\n            TopShot.nextPlayID = TopShot.nextPlayID + UInt32(1)\n\n            emit PlayCreated(id: newPlay.playID, metadata: metadata)\n\n            // Store it in the contract storage\n            TopShot.playDatas[newID] = newPlay\n\n            return newID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createSet creates a new Set resource and stores it\nin the sets mapping in the TopShot contract\n\nParameters: name: The name of the Set\n\nReturns: The ID of the created set"}, {"role": "assistant", "content": "pub fun createSet(name: String): UInt32 {\n\n            // Create the new Set\n            var newSet <- create Set(name: name)\n\n            // Increment the setID so that it isn't used again\n            TopShot.nextSetID = TopShot.nextSetID + UInt32(1)\n\n            let newID = newSet.setID\n\n            emit SetCreated(setID: newSet.setID, series: TopShot.currentSeries)\n\n            // Store it in the sets mapping field\n            TopShot.sets[newID] <-! newSet\n\n            return newID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowSet returns a reference to a set in the TopShot\ncontract so that the admin can call methods on it\n\nParameters: setID: The ID of the Set that you want to\nget a reference to\n\nReturns: A reference to the Set with all of the fields\nand methods exposed\n"}, {"role": "assistant", "content": "pub fun borrowSet(setID: UInt32): &Set {\n            pre {\n                TopShot.sets[setID] != nil: \"Cannot borrow Set: The Set doesn't exist\"\n            }\n            \n            // Get a reference to the Set and return it\n            // use `&` to indicate the reference to the object and type\n            return (&TopShot.sets[setID] as &Set?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: startNewSeries ends the current series by incrementing\nthe series number, meaning that Moments minted after this\nwill use the new series number\n\nReturns: The new series number\n"}, {"role": "assistant", "content": "pub fun startNewSeries(): UInt32 {\n            // End the current series and start a new one\n            // by incrementing the TopShot series number\n            TopShot.currentSeries = TopShot.currentSeries + UInt32(1)\n\n            emit NewSeriesStarted(newCurrentSeries: TopShot.currentSeries)\n\n            return TopShot.currentSeries\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This is the interface that users can cast their Moment Collection as\nto allow others to deposit Moments into their Collection. It also allows for reading\nthe IDs of Moments in the Collection."}, {"role": "assistant", "content": "pub resource interface MomentCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowMoment(id: UInt64): &TopShot.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id): \n                    \"Cannot borrow Moment reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection is a resource that every user who owns NFTs\nwill store in their account to manage their NFTS\n"}, {"role": "assistant", "content": "pub resource Collection: MomentCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection { \n        // Dictionary of Moment conforming tokens\n        // NFT is a resource type with a UInt64 ID field\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        // withdraw removes an Moment from the Collection and moves it to the caller\n        //\n        // Parameters: withdrawID: The ID of the NFT \n        // that is to be removed from the Collection\n        //\n        // returns: @NonFungibleToken.NFT the token that was withdrawn\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Moment does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }\n\n        // batchWithdraw withdraws multiple tokens and returns them as a Collection\n        //\n        // Parameters: ids: An array of IDs to withdraw\n        //\n        // Returns: @NonFungibleToken.Collection: A collection that contains\n        //                                        the withdrawn moments\n        //\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }\n\n        // deposit takes a Moment and adds it to the Collections dictionary\n        //\n        // Paramters: token: the NFT to be deposited in the collection\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            \n            // Cast the deposited token as a TopShot NFT to make sure\n            // it is the correct type\n            let token <- token as! @TopShot.NFT\n\n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token that was \"removed\"\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs returns an array of the IDs that are in the Collection\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT Returns a borrowed reference to a Moment in the Collection\n        // so that the caller can read its ID\n        //\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        //\n        // Note: This only allows the caller to read the ID of the NFT,\n        // not any topshot specific data. Please use borrowMoment to \n        // read Moment data.\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // borrowMoment returns a borrowed reference to a Moment\n        // so that the caller can read data and call methods from it.\n        // They can use this to read its setID, playID, serialNumber,\n        // or any of the setData or Play data associated with it by\n        // getting the setID or playID and reading those fields from\n        // the smart contract.\n        //\n        // Parameters: id: The ID of the NFT to get the reference for\n        //\n        // Returns: A reference to the NFT\n        pub fun borrowMoment(id: UInt64): &TopShot.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TopShot.NFT\n            } else {\n                return nil\n            }\n        }\n\n        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {\n            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)! \n            let topShotNFT = nft as! &TopShot.NFT\n            return topShotNFT as &AnyResource{MetadataViews.Resolver}\n        }\n\n        // If a transaction destroys the Collection object,\n        // All the NFTs contained within are also destroyed!\n        // Much like when Damian Lillard destroys the hopes and\n        // dreams of the entire city of Houston.\n        //\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of Moment conforming tokens\nNFT is a resource type with a UInt64 ID field"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an Moment from the Collection and moves it to the caller\n\nParameters: withdrawID: The ID of the NFT\nthat is to be removed from the Collection\n\nreturns: @NonFungibleToken.NFT the token that was withdrawn"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\n            // Remove the nft from the Collection\n            let token <- self.ownedNFTs.remove(key: withdrawID) \n                ?? panic(\"Cannot withdraw: Moment does not exist in the collection\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            \n            // Return the withdrawn token\n            return <-token\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchWithdraw withdraws multiple tokens and returns them as a Collection\n\nParameters: ids: An array of IDs to withdraw\n\nReturns: @NonFungibleToken.Collection: A collection that contains\nthe withdrawn moments\n"}, {"role": "assistant", "content": "pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            // Create a new empty Collection\n            var batchCollection <- create Collection()\n            \n            // Iterate through the ids and withdraw them from the Collection\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n            \n            // Return the withdrawn tokens\n            return <-batchCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a Moment and adds it to the Collections dictionary\n\nParamters: token: the NFT to be deposited in the collection\n"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            \n            // Cast the deposited token as a TopShot NFT to make sure\n            // it is the correct type\n            let token <- token as! @TopShot.NFT\n\n            // Get the token's ID\n            let id = token.id\n\n            // Add the new token to the dictionary\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Only emit a deposit event if the Collection \n            // is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty old token that was \"removed\"\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchDeposit takes a Collection object as an argument\nand deposits each contained NFT into this Collection"}, {"role": "assistant", "content": "pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT Returns a borrowed reference to a Moment in the Collection\nso that the caller can read its ID\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT\n\nNote: This only allows the caller to read the ID of the NFT,\nnot any topshot specific data. Please use borrowMoment to\nread Moment data.\n"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowMoment returns a borrowed reference to a Moment\nso that the caller can read data and call methods from it.\nThey can use this to read its setID, playID, serialNumber,\nor any of the setData or Play data associated with it by\ngetting the setID or playID and reading those fields from\nthe smart contract.\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT"}, {"role": "assistant", "content": "pub fun borrowMoment(id: UInt64): &TopShot.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TopShot.NFT\n            } else {\n                return nil\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: If a transaction destroys the Collection object,\nAll the NFTs contained within are also destroyed!\nMuch like when Damian Lillard destroys the hopes and\ndreams of the entire city of Houston.\n"}, {"role": "assistant", "content": "destroy() {\n            destroy self.ownedNFTs\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyCollection creates a new, empty Collection object so that\na user can store it in their account storage.\nOnce they have a Collection in their storage, they are able to receive\nMoments in transactions.\n"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <-create TopShot.Collection()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getAllPlays returns all the plays in topshot\n\nReturns: An array of all the plays that have been created"}, {"role": "assistant", "content": "pub fun getAllPlays(): [TopShot.Play] {\n        return TopShot.playDatas.values\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getPlayMetaData returns all the metadata associated with a specific Play\n\nParameters: playID: The id of the Play that is being searched\n\nReturns: The metadata as a String to String mapping optional"}, {"role": "assistant", "content": "pub fun getPlayMetaData(playID: UInt32): {String: String}? {\n        return self.playDatas[playID]?.metadata\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getPlayMetaDataByField returns the metadata associated with a\nspecific field of the metadata\nEx: field: \"Team\" will return something\nlike \"Memphis Grizzlies\"\n\nParameters: playID: The id of the Play that is being searched\nfield: The field to search for\n\nReturns: The metadata field as a String Optional"}, {"role": "assistant", "content": "pub fun getPlayMetaDataByField(playID: UInt32, field: String): String? {\n        // Don't force a revert if the playID or field is invalid\n        if let play = TopShot.playDatas[playID] {\n            return play.metadata[field]\n        } else {\n            return nil\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getSetData returns the data that the specified Set\nis associated with.\n\nParameters: setID: The id of the Set that is being searched\n\nReturns: The QuerySetData struct that has all the important information about the set"}, {"role": "assistant", "content": "pub fun getSetData(setID: UInt32): QuerySetData? {\n        if TopShot.sets[setID] == nil {\n            return nil\n        } else {\n            return QuerySetData(setID: setID)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getSetName returns the name that the specified Set\nis associated with.\n\nParameters: setID: The id of the Set that is being searched\n\nReturns: The name of the Set"}, {"role": "assistant", "content": "pub fun getSetName(setID: UInt32): String? {\n        // Don't force a revert if the setID is invalid\n        return TopShot.setDatas[setID]?.name\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getSetSeries returns the series that the specified Set\nis associated with.\n\nParameters: setID: The id of the Set that is being searched\n\nReturns: The series that the Set belongs to"}, {"role": "assistant", "content": "pub fun getSetSeries(setID: UInt32): UInt32? {\n        // Don't force a revert if the setID is invalid\n        return TopShot.setDatas[setID]?.series\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getSetIDsByName returns the IDs that the specified Set name\nis associated with.\n\nParameters: setName: The name of the Set that is being searched\n\nReturns: An array of the IDs of the Set if it exists, or nil if doesn't"}, {"role": "assistant", "content": "pub fun getSetIDsByName(setName: String): [UInt32]? {\n        var setIDs: [UInt32] = []\n\n        // Iterate through all the setDatas and search for the name\n        for setData in TopShot.setDatas.values {\n            if setName == setData.name {\n                // If the name is found, return the ID\n                setIDs.append(setData.setID)\n            }\n        }\n\n        // If the name isn't found, return nil\n        // Don't force a revert if the setName is invalid\n        if setIDs.length == 0 {\n            return nil\n        } else {\n            return setIDs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getPlaysInSet returns the list of Play IDs that are in the Set\n\nParameters: setID: The id of the Set that is being searched\n\nReturns: An array of Play IDs"}, {"role": "assistant", "content": "pub fun getPlaysInSet(setID: UInt32): [UInt32]? {\n        // Don't force a revert if the setID is invalid\n        return TopShot.sets[setID]?.plays\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: isEditionRetired returns a boolean that indicates if a Set/Play combo\n(otherwise known as an edition) is retired.\nIf an edition is retired, it still remains in the Set,\nbut Moments can no longer be minted from it.\n\nParameters: setID: The id of the Set that is being searched\nplayID: The id of the Play that is being searched\n\nReturns: Boolean indicating if the edition is retired or not"}, {"role": "assistant", "content": "pub fun isEditionRetired(setID: UInt32, playID: UInt32): Bool? {\n\n        if let setdata = self.getSetData(setID: setID) {\n\n            // See if the Play is retired from this Set\n            let retired = setdata.getRetired()[playID]\n\n            // Return the retired status\n            return retired\n        } else {\n\n            // If the Set wasn't found, return nil\n            return nil\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: isSetLocked returns a boolean that indicates if a Set\nis locked. If it's locked,\nnew Plays can no longer be added to it,\nbut Moments can still be minted from Plays the set contains.\n\nParameters: setID: The id of the Set that is being searched\n\nReturns: Boolean indicating if the Set is locked or not"}, {"role": "assistant", "content": "pub fun isSetLocked(setID: UInt32): Bool? {\n        // Don't force a revert if the setID is invalid\n        return TopShot.sets[setID]?.locked\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getNumMomentsInEdition return the number of Moments that have been\nminted from a certain edition.\n\nParameters: setID: The id of the Set that is being searched\nplayID: The id of the Play that is being searched\n\nReturns: The total number of Moments\nthat have been minted from an edition"}, {"role": "assistant", "content": "pub fun getNumMomentsInEdition(setID: UInt32, playID: UInt32): UInt32? {\n        if let setdata = self.getSetData(setID: setID) {\n\n            // Read the numMintedPerPlay\n            let amount = setdata.getNumberMintedPerPlay()[playID]\n\n            return amount\n        } else {\n            // If the set wasn't found return nil\n            return nil\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: -----------------------------------------------------------------------\nTopShot initialization function\n-----------------------------------------------------------------------\n"}, {"role": "assistant", "content": "init() {\n        // Initialize contract fields\n        self.currentSeries = 0\n        self.playDatas = {}\n        self.setDatas = {}\n        self.sets <- {}\n        self.nextPlayID = 1\n        self.nextSetID = 1\n        self.totalSupply = 0\n\n        // Put a new Collection in storage\n        self.account.save<@Collection>(<- create Collection(), to: /storage/MomentCollection)\n\n        // Create a public capability for the Collection\n        self.account.link<&{MomentCollectionPublic}>(/public/MomentCollection, target: /storage/MomentCollection)\n\n        // Put the Minter in storage\n        self.account.save<@Admin>(<- create Admin(), to: /storage/TopShotAdmin)\n\n        emit ContractInitialized()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Fired once this contract is deployed."}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Fired once this contract is deployed."}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Storefront resource has been created.\nEvent consumers can now expect events from this Storefront.\n"}, {"role": "assistant", "content": "pub event StorefrontInitialized(storefrontResourceId: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Storefront resource has been created.\nEvent consumers can now expect events from this Storefront.\n"}, {"role": "assistant", "content": "(storefrontResourceId: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Storefront has been destroyed.\nEvent consumers can now stop processing events from this Storefront.\nNote that we do not specify an address.\n"}, {"role": "assistant", "content": "pub event StorefrontDestroyed(storefrontResourceId: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Storefront has been destroyed.\nEvent consumers can now stop processing events from this Storefront.\nNote that we do not specify an address.\n"}, {"role": "assistant", "content": "(storefrontResourceId: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A sale offer has been created and added to a Storefront resource.\nThe Address values here are valid when the event is emitted, but\nthe state of the accounts they refer to may be changed outside of the\nFrontRowStorefront workflow, so be careful to check when using them."}, {"role": "assistant", "content": "pub event SaleOfferAvailable(\n    storefrontAddress: Address,\n    blueprintId: UInt32,\n    price: UFix64\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A sale offer has been created and added to a Storefront resource.\nThe Address values here are valid when the event is emitted, but\nthe state of the accounts they refer to may be changed outside of the\nFrontRowStorefront workflow, so be careful to check when using them."}, {"role": "assistant", "content": "(\n    storefrontAddress: Address,\n    blueprintId: UInt32,\n    price: UFix64\n  )"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A sale offer has been removed.\n\nParameters:  blueprintId: ID of the blueprint that was removed from sale\nserialNumber: the place in the edition that this NFT was minted\nIt also represents the total number of NFTs sold for\nthe blueprint so far\nsoldOut: a boolean flag showing if all NFTs were completely sold out\n"}, {"role": "assistant", "content": "pub event SaleOfferRemoved(blueprintId: UInt32, serialNumber: UInt32, soldOut: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A sale offer has been removed.\n\nParameters:  blueprintId: ID of the blueprint that was removed from sale\nserialNumber: the place in the edition that this NFT was minted\nIt also represents the total number of NFTs sold for\nthe blueprint so far\nsoldOut: a boolean flag showing if all NFTs were completely sold out\n"}, {"role": "assistant", "content": "(blueprintId: UInt32, serialNumber: UInt32, soldOut: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A purchase has been made.\n\nParameters:  blueprintId: ID of the blueprint that was purchased\nserialNumber: the place in the edition that this NFT was minted\nIt also represents the total number of NFTs sold for\nthe blueprint so far\nsoldOut: a boolean flag showing if all NFTs are completely sold out now\n"}, {"role": "assistant", "content": "pub event Purchase(blueprintId: UInt32, serialNumber: UInt32, soldOut: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A purchase has been made.\n\nParameters:  blueprintId: ID of the blueprint that was purchased\nserialNumber: the place in the edition that this NFT was minted\nIt also represents the total number of NFTs sold for\nthe blueprint so far\nsoldOut: a boolean flag showing if all NFTs are completely sold out now\n"}, {"role": "assistant", "content": "(blueprintId: UInt32, serialNumber: UInt32, soldOut: Bool)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The public location for a Storefront link."}, {"role": "assistant", "content": "pub let StorefrontPublicPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A struct containing a SaleOffer's data."}, {"role": "assistant", "content": "pub struct SaleOfferDetails {\n\n    // Number of NFTs this offer has sold.\n    pub var sold: UInt32\n\n    // Sale price\n    pub var price: UFix64\n\n    // The Blueprint ID\n    pub let blueprintId: UInt32\n\n    // The beneficiary of the sale\n    pub let beneficiary: Capability<&{FungibleToken.Receiver}>\n\n    // Increment the number of sold NFTs\n    access(contract) fun recordPurchase() {\n      self.sold = self.sold + 1\n    }\n\n    init (\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n    ) {\n      // Check if blueprint exists\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n\n      // Initialize struct fields\n      self.sold = 0\n      self.blueprintId = blueprintId\n      self.price = price\n      self.beneficiary = beneficiary\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Number of NFTs this offer has sold."}, {"role": "assistant", "content": "pub var sold: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Sale price"}, {"role": "assistant", "content": "pub var price: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Blueprint ID"}, {"role": "assistant", "content": "pub let blueprintId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The beneficiary of the sale"}, {"role": "assistant", "content": "pub let beneficiary: Capability<&{FungibleToken.Receiver}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Increment the number of sold NFTs"}, {"role": "assistant", "content": "access(contract) fun recordPurchase() {\n      self.sold = self.sold + 1\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: An interface providing a useful public interface to a SaleOffer.\n"}, {"role": "assistant", "content": "pub resource interface SaleOfferPublic {\n\n    // purchase allows users to buy NFTs\n    // It pays the beneficiary and returns the token to the buyer.\n    //\n    // Parameters:  payment: the FUSD payment for the NFT purchase\n    //\n    // Returns: purchased @FrontRow.NFT token\n    //\n    pub fun purchase(payment: @FUSD.Vault): @FrontRow.NFT\n\n    // getDetails returns detailed information about a sale offer\n    //\n    // Returns: sale offer details\n    //\n    pub fun getDetails(): SaleOfferDetails\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: purchase allows users to buy NFTs\nIt pays the beneficiary and returns the token to the buyer.\n\nParameters:  payment: the FUSD payment for the NFT purchase\n\nReturns: purchased @FrontRow.NFT token\n"}, {"role": "assistant", "content": "pub fun purchase(payment: @FUSD.Vault): @FrontRow.NFT"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getDetails returns detailed information about a sale offer\n\nReturns: sale offer details\n"}, {"role": "assistant", "content": "pub fun getDetails(): SaleOfferDetails"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: SaleOffer is a resource that allows an NFT to be sold for a specified\nFungibleToken amount."}, {"role": "assistant", "content": "pub resource SaleOffer: SaleOfferPublic {\n\n    // The simple (non-Capability, non-complex) details of the sale\n    access(self) let details: SaleOfferDetails\n\n    // The capability to mint NFTs\n    access(contract) let minterCapability: Capability<&{FrontRow.Minter}>\n\n    // A capability allowing this resource to withdraw the NFT with the given ID\n    // from its collection. This capability allows the resource to withdraw *any* NFT,\n    // so be careful when giving such a capability to a resource and\n    // always check its code to make sure it will use it in the way that it claims.\n    access(contract) let nftProviderCapability:\n      Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>\n\n    // Get the details of the current state of the SaleOffer as a struct.\n    // This avoids having more public variables and getter methods for them, and plays\n    // nicely with scripts (which cannot return resources).\n    //\n    // Returns: sale offer details such as blueprint id, price, etc\n    //\n    pub fun getDetails(): SaleOfferDetails {\n        return self.details\n    }\n\n    // purchase allows users to buy NFTs\n    // It pays the beneficiary and returns the token to the buyer.\n    //\n    // Parameters: payment: the FUSD payment for the NFT purchase\n    //\n    // Returns: purchased @FrontRow.NFT token\n    //\n    pub fun purchase(payment: @FUSD.Vault): @FrontRow.NFT {\n      //\n      let blueprint = FrontRow.getBlueprint(id: self.details.blueprintId)!\n\n      // Check if the payment has sufficient balance to cover the purchase\n      assert(\n        payment.balance == self.details.price,\n        message: \"Payment vault doesn't have enough funds.\"\n      )\n\n      // Borrow minting capability for on demand minting\n      let minter: &{FrontRow.Minter} = self.minterCapability.borrow()!\n      assert(minter != nil, message: \"Can't borrow minter capability.\")\n\n      // Get serial number of the NFT that's about to be purchased.\n      // The serial number based on a particular blueprint.\n      let nftSerialNumber : UInt32 = blueprint.getMintCount() + 1\n\n      // Check if NFTs are sold out\n      assert(nftSerialNumber <= blueprint.maxQuantity, message: \"NFTs are sold out.\")\n\n      let nft: @FrontRow.NFT <- self.minterCapability\n        .borrow()!\n        .mintNFT(blueprintId: blueprint.id)\n\n      // Neither receivers nor providers are trustworthy, they must implement the correct\n      // interface but beyond complying with its pre/post conditions they are not\n      // guaranteed to implement interface's functionality.\n      // Therefore we cannot trust the Collection resource behind the interface,\n      // and must check the NFT resource it gives us to make sure that it correct.\n      assert(\n        nft.isInstance(Type<@FrontRow.NFT>()),\n        message: \"Withdrawn NFT is not of FrontRow.NFT type.\"\n      )\n\n      // NFT minted: check the blueprint ID and the serial number\n      assert(nft.blueprintId == blueprint.id && nft.serialNumber == nftSerialNumber,\n        message: \"Selling incorrect NFT: serial number or/and blueprint are incorrect.\"\n      )\n\n       // Send payment to the beneficiary\n      let beneficiary = self.details.beneficiary.borrow()\n      beneficiary!.deposit(from: <-payment)\n\n      // Increment the purchase amount\n      self.details.recordPurchase()\n\n      // Emit the Purchase event\n      emit Purchase(\n        blueprintId: self.details.blueprintId,\n        serialNumber: nftSerialNumber,\n        // If all minted NFTs for a bluprint are purchased, the offer is soldOut.\n        soldOut: nftSerialNumber == blueprint.maxQuantity\n      )\n      return <- nft\n    }\n\n    // Initialize resource fields\n    init (\n      nftProviderCapability: Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>,\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n      minterCapability: Capability<&{FrontRow.Minter}>\n    ) {\n      //\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n\n      // Check if blueprint exists\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n\n      // Store the sale information\n      self.details = SaleOfferDetails(\n        blueprintId: blueprintId,\n        price: price,\n        beneficiary: beneficiary,\n      )\n\n      // Store capabilities\n      self.nftProviderCapability = nftProviderCapability\n      self.minterCapability = minterCapability\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The simple (non-Capability, non-complex) details of the sale"}, {"role": "assistant", "content": "access(self) let details: SaleOfferDetails"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The capability to mint NFTs"}, {"role": "assistant", "content": "access(contract) let minterCapability: Capability<&{FrontRow.Minter}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A capability allowing this resource to withdraw the NFT with the given ID\nfrom its collection. This capability allows the resource to withdraw *any* NFT,\nso be careful when giving such a capability to a resource and\nalways check its code to make sure it will use it in the way that it claims."}, {"role": "assistant", "content": "access(contract) let nftProviderCapability:\n      Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the details of the current state of the SaleOffer as a struct.\nThis avoids having more public variables and getter methods for them, and plays\nnicely with scripts (which cannot return resources).\n\nReturns: sale offer details such as blueprint id, price, etc\n"}, {"role": "assistant", "content": "pub fun getDetails(): SaleOfferDetails {\n        return self.details\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: purchase allows users to buy NFTs\nIt pays the beneficiary and returns the token to the buyer.\n\nParameters: payment: the FUSD payment for the NFT purchase\n\nReturns: purchased @FrontRow.NFT token\n"}, {"role": "assistant", "content": "pub fun purchase(payment: @FUSD.Vault): @FrontRow.NFT {\n      //\n      let blueprint = FrontRow.getBlueprint(id: self.details.blueprintId)!\n\n      // Check if the payment has sufficient balance to cover the purchase\n      assert(\n        payment.balance == self.details.price,\n        message: \"Payment vault doesn't have enough funds.\"\n      )\n\n      // Borrow minting capability for on demand minting\n      let minter: &{FrontRow.Minter} = self.minterCapability.borrow()!\n      assert(minter != nil, message: \"Can't borrow minter capability.\")\n\n      // Get serial number of the NFT that's about to be purchased.\n      // The serial number based on a particular blueprint.\n      let nftSerialNumber : UInt32 = blueprint.getMintCount() + 1\n\n      // Check if NFTs are sold out\n      assert(nftSerialNumber <= blueprint.maxQuantity, message: \"NFTs are sold out.\")\n\n      let nft: @FrontRow.NFT <- self.minterCapability\n        .borrow()!\n        .mintNFT(blueprintId: blueprint.id)\n\n      // Neither receivers nor providers are trustworthy, they must implement the correct\n      // interface but beyond complying with its pre/post conditions they are not\n      // guaranteed to implement interface's functionality.\n      // Therefore we cannot trust the Collection resource behind the interface,\n      // and must check the NFT resource it gives us to make sure that it correct.\n      assert(\n        nft.isInstance(Type<@FrontRow.NFT>()),\n        message: \"Withdrawn NFT is not of FrontRow.NFT type.\"\n      )\n\n      // NFT minted: check the blueprint ID and the serial number\n      assert(nft.blueprintId == blueprint.id && nft.serialNumber == nftSerialNumber,\n        message: \"Selling incorrect NFT: serial number or/and blueprint are incorrect.\"\n      )\n\n       // Send payment to the beneficiary\n      let beneficiary = self.details.beneficiary.borrow()\n      beneficiary!.deposit(from: <-payment)\n\n      // Increment the purchase amount\n      self.details.recordPurchase()\n\n      // Emit the Purchase event\n      emit Purchase(\n        blueprintId: self.details.blueprintId,\n        serialNumber: nftSerialNumber,\n        // If all minted NFTs for a bluprint are purchased, the offer is soldOut.\n        soldOut: nftSerialNumber == blueprint.maxQuantity\n      )\n      return <- nft\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Initialize resource fields"}, {"role": "assistant", "content": "init (\n      nftProviderCapability: Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>,\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n      minterCapability: Capability<&{FrontRow.Minter}>\n    ) {\n      //\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n\n      // Check if blueprint exists\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n\n      // Store the sale information\n      self.details = SaleOfferDetails(\n        blueprintId: blueprintId,\n        price: price,\n        beneficiary: beneficiary,\n      )\n\n      // Store capabilities\n      self.nftProviderCapability = nftProviderCapability\n      self.minterCapability = minterCapability\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: StorefrontManager is the interface for adding and removing SaleOffers within\na Storefront. It is intended for use by the Storefront's owner.\n"}, {"role": "assistant", "content": "pub resource interface StorefrontManager {\n\n    // createSaleOffer allows the Storefront owner to create and insert sale offers\n    // Each sale offer has 1-to-1 relationship to a blueprint and a blueprint ID\n    // uniquely identifies each sale offer.\n    //\n    // Parameters:  nftProviderCapability: capability to borrow NFT\n    //              blueprintId: ID of the blueprint to sell\n    //              price: listing price for each NFT\n    //              beneficiary:  the capability used for depositing the beneficiary's\n    //                            sale proceeds\n    //\n    pub fun createSaleOffer(\n      nftProviderCapability: Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>,\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n      minterCapability: Capability<&{FrontRow.Minter}>\n    )\n\n    // removeSaleOffer removes sales offer from the owner's Storefront, sold out or not.\n    //\n    // Parameters:  blueprintId: ID of the blueprint which is on sale via a sale offer.\n    //                           Since there is 1-to-1 relationship between a blueprint\n    //                           and a sale offer, the blueprint ID uniquely idetifies\n    //                           each sale offer\n    //\n    pub fun removeSaleOffer(blueprintId: UInt32)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createSaleOffer allows the Storefront owner to create and insert sale offers\nEach sale offer has 1-to-1 relationship to a blueprint and a blueprint ID\nuniquely identifies each sale offer.\n\nParameters:  nftProviderCapability: capability to borrow NFT\nblueprintId: ID of the blueprint to sell\nprice: listing price for each NFT\nbeneficiary:  the capability used for depositing the beneficiary's\nsale proceeds\n"}, {"role": "assistant", "content": "pub fun createSaleOffer(\n      nftProviderCapability: Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>,\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n      minterCapability: Capability<&{FrontRow.Minter}>\n    "}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: removeSaleOffer removes sales offer from the owner's Storefront, sold out or not.\n\nParameters:  blueprintId: ID of the blueprint which is on sale via a sale offer.\nSince there is 1-to-1 relationship between a blueprint\nand a sale offer, the blueprint ID uniquely idetifies\neach sale offer\n"}, {"role": "assistant", "content": "pub fun removeSaleOffer(blueprintId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: StorefrontPublic is the interface to allow listing and borrowing SaleOffers,\nand purchasing items via SaleOffers in a Storefront.\n"}, {"role": "assistant", "content": "pub resource interface StorefrontPublic {\n    // getSaleOfferIDs returns an array of all sale offer IDs\n    //\n    // Returns: an array of all sale offers\n    //\n    pub fun getSaleOfferIDs(): [UInt32]\n\n    // borrowSaleOffer returns a reference to the SaleOffer resource\n    //\n    // Parameters: blueprintId: The ID of the blueprint (or a sale offer)\n    //\n    // Returns: A reference to the SaleOffer resource\n    //\n    pub fun borrowSaleOffer(blueprintId: UInt32): &SaleOffer{SaleOfferPublic}?\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getSaleOfferIDs returns an array of all sale offer IDs\n\nReturns: an array of all sale offers\n"}, {"role": "assistant", "content": "pub fun getSaleOfferIDs(): [UInt32]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowSaleOffer returns a reference to the SaleOffer resource\n\nParameters: blueprintId: The ID of the blueprint (or a sale offer)\n\nReturns: A reference to the SaleOffer resource\n"}, {"role": "assistant", "content": "pub fun borrowSaleOffer(blueprintId: UInt32): &SaleOffer{SaleOfferPublic}?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Storefront is a resource that allows its owner to manage a list of SaleOffers,\nand anyone to interact with them in order to query their details and purchase\nthe NFTs that they represent.\n"}, {"role": "assistant", "content": "pub resource Storefront: StorefrontManager, StorefrontPublic {\n\n    // The dictionary of SaleOffers. Blueprint ID to SaleOffer resources.\n    access(self) var saleOffers: @{UInt32: SaleOffer}\n\n    // Create and publish a SaleOffer for an NFT.\n    //\n    // Parameters:  nftProviderCapability: capability to borrow NFT\n    //              blueprintId: ID of the blueprint to sell\n    //              price: listing price for each NFT\n    //              beneficiary: capability used for depositing the beneficiary's\n    //                            sale proceeds\n    //              minterCapability: capability to mint NFTs. Used in on demand minting.\n    //\n    pub fun createSaleOffer(\n      nftProviderCapability: Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>,\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n      minterCapability: Capability<&{FrontRow.Minter}>\n    ) {\n      //\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n\n      // Check if blueprint exists and if the sale offer is not a duplicate\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n      assert(self.saleOffers[blueprintId] == nil, message: \"Sale offer already exists.\")\n\n      // Create a sale offer\n      let saleOffer <- create SaleOffer(\n        nftProviderCapability: nftProviderCapability,\n        blueprintId: blueprintId,\n        price: price,\n        beneficiary: beneficiary,\n        minterCapability: minterCapability,\n      )\n\n      // Add the new sale offer to the dictionary\n      let oldOffer <- self.saleOffers[blueprintId] <- saleOffer\n\n      // Note that oldOffer will always be nil, but we have to handle it\n      destroy oldOffer\n\n      emit SaleOfferAvailable(\n        storefrontAddress: self.owner?.address!,\n        blueprintId: blueprintId,\n        price: price\n      )\n    }\n\n    // removeSaleOffer removes a sale offer from the collection and destroys it.\n    //\n    // Parameters: blueprintId: The ID of the blueprint to remove from sale\n    //\n    pub fun removeSaleOffer(blueprintId: UInt32) {\n\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n\n      let offer <- self.saleOffers.remove(key: blueprintId)\n        ?? panic(\"Missing sale offer.\")\n\n      // Get details of the soon to be removed sale offer\n      let saleOfferDetails: SaleOfferDetails = offer.getDetails()\n\n      // This will emit a SaleOfferRemoved event\n      destroy offer\n\n      // Let event consumers know that the SaleOffer has been removed\n      emit SaleOfferRemoved(\n        blueprintId: blueprintId,\n        serialNumber: saleOfferDetails.sold,\n        soldOut: saleOfferDetails.sold == blueprint!.maxQuantity\n      )\n    }\n\n    // getSaleOfferIDs returns an array of sale offers listed for sale\n    //\n    // Returns: an array of blueprint IDs listed in the Storefront for sale\n    pub fun getSaleOfferIDs(): [UInt32] {\n      return self.saleOffers.keys\n    }\n\n    // borrowSaleOffer returns a reference to the sale offer for the given blueprint ID\n    //\n    // Parameters: blueprintId: The ID of the blueprint of the corresponding sale offer\n    //\n    // Returns: a reference to the &SaleOffer resource limited only to functionality\n    //          outlined in the SaleOfferPublic interface\n    //\n    pub fun borrowSaleOffer(blueprintId: UInt32): &SaleOffer{SaleOfferPublic}? {\n      if self.saleOffers[blueprintId] != nil {\n        return &self.saleOffers[blueprintId] as &SaleOffer{SaleOfferPublic}?\n      } else {\n        return nil\n      }\n    }\n\n    // Removes all sale offers from the Storefront\n    destroy () {\n      destroy self.saleOffers\n\n      // Let event consumers know that this storefront will no longer exist\n      emit StorefrontDestroyed(storefrontResourceId: self.uuid)\n    }\n\n    // Initialize resource fields\n    init () {\n      self.saleOffers <- {}\n\n      // Let event consumers know that now they can expect events from this Storefront\n      emit StorefrontInitialized(storefrontResourceId: self.uuid)\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The dictionary of SaleOffers. Blueprint ID to SaleOffer resources."}, {"role": "assistant", "content": "access(self) var saleOffers: @{UInt32: SaleOffer}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create and publish a SaleOffer for an NFT.\n\nParameters:  nftProviderCapability: capability to borrow NFT\nblueprintId: ID of the blueprint to sell\nprice: listing price for each NFT\nbeneficiary: capability used for depositing the beneficiary's\nsale proceeds\nminterCapability: capability to mint NFTs. Used in on demand minting.\n"}, {"role": "assistant", "content": "pub fun createSaleOffer(\n      nftProviderCapability: Capability<&{NonFungibleToken.Provider, FrontRow.CollectionPublic}>,\n      blueprintId: UInt32,\n      price: UFix64,\n      beneficiary: Capability<&{FungibleToken.Receiver}>,\n      minterCapability: Capability<&{FrontRow.Minter}>\n    ) {\n      //\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n\n      // Check if blueprint exists and if the sale offer is not a duplicate\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n      assert(self.saleOffers[blueprintId] == nil, message: \"Sale offer already exists.\")\n\n      // Create a sale offer\n      let saleOffer <- create SaleOffer(\n        nftProviderCapability: nftProviderCapability,\n        blueprintId: blueprintId,\n        price: price,\n        beneficiary: beneficiary,\n        minterCapability: minterCapability,\n      )\n\n      // Add the new sale offer to the dictionary\n      let oldOffer <- self.saleOffers[blueprintId] <- saleOffer\n\n      // Note that oldOffer will always be nil, but we have to handle it\n      destroy oldOffer\n\n      emit SaleOfferAvailable(\n        storefrontAddress: self.owner?.address!,\n        blueprintId: blueprintId,\n        price: price\n      )\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: removeSaleOffer removes a sale offer from the collection and destroys it.\n\nParameters: blueprintId: The ID of the blueprint to remove from sale\n"}, {"role": "assistant", "content": "pub fun removeSaleOffer(blueprintId: UInt32) {\n\n      let blueprint: FrontRow.Blueprint? = FrontRow.getBlueprint(id: blueprintId)\n      assert(blueprint != nil, message: \"Blueprint doesn't exist.\")\n\n      let offer <- self.saleOffers.remove(key: blueprintId)\n        ?? panic(\"Missing sale offer.\")\n\n      // Get details of the soon to be removed sale offer\n      let saleOfferDetails: SaleOfferDetails = offer.getDetails()\n\n      // This will emit a SaleOfferRemoved event\n      destroy offer\n\n      // Let event consumers know that the SaleOffer has been removed\n      emit SaleOfferRemoved(\n        blueprintId: blueprintId,\n        serialNumber: saleOfferDetails.sold,\n        soldOut: saleOfferDetails.sold == blueprint!.maxQuantity\n      )\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getSaleOfferIDs returns an array of sale offers listed for sale\n\nReturns: an array of blueprint IDs listed in the Storefront for sale"}, {"role": "assistant", "content": "pub fun getSaleOfferIDs(): [UInt32] {\n      return self.saleOffers.keys\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowSaleOffer returns a reference to the sale offer for the given blueprint ID\n\nParameters: blueprintId: The ID of the blueprint of the corresponding sale offer\n\nReturns: a reference to the &SaleOffer resource limited only to functionality\noutlined in the SaleOfferPublic interface\n"}, {"role": "assistant", "content": "pub fun borrowSaleOffer(blueprintId: UInt32): &SaleOffer{SaleOfferPublic}? {\n      if self.saleOffers[blueprintId] != nil {\n        return &self.saleOffers[blueprintId] as &SaleOffer{SaleOfferPublic}?\n      } else {\n        return nil\n      }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Removes all sale offers from the Storefront"}, {"role": "assistant", "content": "destroy () {\n      destroy self.saleOffers\n\n      // Let event consumers know that this storefront will no longer exist\n      emit StorefrontDestroyed(storefrontResourceId: self.uuid)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Initialize resource fields"}, {"role": "assistant", "content": "init () {\n      self.saleOffers <- {}\n\n      // Let event consumers know that now they can expect events from this Storefront\n      emit StorefrontInitialized(storefrontResourceId: self.uuid)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Initialize contract fields."}, {"role": "assistant", "content": "init () {\n    // Set paths aliases\n    self.StorefrontStoragePath = /storage/FrontRowStorefront\n    self.StorefrontPublicPath = /public/FrontRowStorefront\n\n    // Create the Storefront resource and save it to storage\n    self.account.save<@Storefront>(<- create Storefront(), to: self.StorefrontStoragePath)\n\n    // Create a public capability for the FrontRowStorefront\n    self.account.link<&FrontRowStorefront.Storefront{FrontRowStorefront.StorefrontPublic}>\n      (FrontRowStorefront.StorefrontPublicPath,\n      target: FrontRowStorefront.StorefrontStoragePath)\n\n    emit ContractInitialized()\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Fired once this contract is deployed"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Fired once this contract is deployed"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Blueprint"}, {"role": "assistant", "content": "pub event BlueprintPrinted(id: UInt32, maxQuantity: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Blueprint"}, {"role": "assistant", "content": "(id: UInt32, maxQuantity: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for NFTs"}, {"role": "assistant", "content": "pub event Minted(id: UInt64, blueprintId: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for NFTs"}, {"role": "assistant", "content": "(id: UInt64, blueprintId: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of Blueprint structs"}, {"role": "assistant", "content": "access(self) var blueprints: {UInt32: Blueprint}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Global counters for Blueprint and NFT IDs"}, {"role": "assistant", "content": "pub var nextBlueprintId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Storage paths"}, {"role": "assistant", "content": "pub let CollectionStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The struct that represents the NFT type or a template. When NFTs are minted\nthey abide by the following restrictions:\n- can't mint more NFTs than the defined maxQuantity\n- can't mint from a cancelled blueprint"}, {"role": "assistant", "content": "pub struct Blueprint {\n    pub let id: UInt32\n    pub let maxQuantity: UInt32\n    pub let metadata: {String:String}\n    access(self) var cancelled: Bool\n    access(self) var mintCount: UInt32\n    access(self) var nfts: {UInt32: UInt64} // Map of serial numbers to global NFT IDs\n\n    // Initialize struct fields\n    init(id: UInt32, maxQuantity: UInt32, metadata: {String:String}) {\n      pre {\n        id > 0 :\n          \"Couldn't create blueprint: id is required.\"\n        FrontRow.blueprints[FrontRow.nextBlueprintId] == nil :\n          \"Couldn't create blueprint: already exists.\"\n        maxQuantity > 0 :\n          \"Couldn't create blueprint: maxiumum quantity is required.\"\n      }\n\n      // Initialize struct fields\n      self.id = id\n      self.maxQuantity = maxQuantity\n      self.metadata = metadata\n      self.cancelled = false\n      self.mintCount = 0\n      self.nfts = {}\n    }\n\n    // Check if blueprint is cancelled\n    pub fun isCancelled(): Bool {\n      return self.cancelled\n    }\n\n    // Cancel a blueprint (no more NFTs can be printed fron it)\n    // This operation is irreversible\n    pub fun cancel() {\n      if !self.cancelled {\n        self.cancelled = true\n      }\n    }\n\n    // Get mint count\n    pub fun getMintCount(): UInt32 {\n      return self.mintCount\n    }\n\n    // Set mint count\n    pub fun setMintCount(_ mintCount: UInt32) {\n      self.mintCount = mintCount\n    }\n\n    // Set map entry of serial number to the new global NFT ID\n    pub fun setNftId(_ serialNumber: UInt32, nftId: UInt64) {\n      self.nfts[serialNumber] = nftId\n    }\n\n    // Get the NFT ID corresponding to a serial number\n    pub fun getNftId(_ serialNumber: UInt32): UInt64? {\n      return self.nfts[serialNumber]\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Initialize struct fields"}, {"role": "assistant", "content": "init(id: UInt32, maxQuantity: UInt32, metadata: {String:String}) {\n      pre {\n        id > 0 :\n          \"Couldn't create blueprint: id is required.\"\n        FrontRow.blueprints[FrontRow.nextBlueprintId] == nil :\n          \"Couldn't create blueprint: already exists.\"\n        maxQuantity > 0 :\n          \"Couldn't create blueprint: maxiumum quantity is required.\"\n      }\n\n      // Initialize struct fields\n      self.id = id\n      self.maxQuantity = maxQuantity\n      self.metadata = metadata\n      self.cancelled = false\n      self.mintCount = 0\n      self.nfts = {}\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Check if blueprint is cancelled"}, {"role": "assistant", "content": "pub fun isCancelled(): Bool {\n      return self.cancelled\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Cancel a blueprint (no more NFTs can be printed fron it)\nThis operation is irreversible"}, {"role": "assistant", "content": "pub fun cancel() {\n      if !self.cancelled {\n        self.cancelled = true\n      }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get mint count"}, {"role": "assistant", "content": "pub fun getMintCount(): UInt32 {\n      return self.mintCount\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Set mint count"}, {"role": "assistant", "content": "pub fun setMintCount(_ mintCount: UInt32) {\n      self.mintCount = mintCount\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Set map entry of serial number to the new global NFT ID"}, {"role": "assistant", "content": "pub fun setNftId(_ serialNumber: UInt32, nftId: UInt64) {\n      self.nfts[serialNumber] = nftId\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the NFT ID corresponding to a serial number"}, {"role": "assistant", "content": "pub fun getNftId(_ serialNumber: UInt32): UInt64? {\n      return self.nfts[serialNumber]\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The resource that represents FrontRow NFT (based on a blueprint)"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT {\n    pub let id: UInt64 // Global unique NFT ID\n    pub let blueprintId: UInt32\n    pub let serialNumber: UInt32\n\n    init(blueprintId: UInt32, serialNumber: UInt32) {\n      //\n      pre {\n        //\n        FrontRow.blueprints[blueprintId] != nil :\n          \"Couldn't mint NFT: blueprint doesn't exist.\"\n        //\n        FrontRow.blueprints[blueprintId]!.getMintCount() + 1 <=\n            FrontRow.blueprints[blueprintId]!.maxQuantity :\n          \"Couldn't mint NFT: maximum quantity limit is reached.\"\n        //\n        !FrontRow.blueprints[blueprintId]!.isCancelled() :\n          \"Couldn't mint NFT: blueprint is cancelled.\"\n      }\n\n      // Increment the global supply counter\n      FrontRow.totalSupply = FrontRow.totalSupply + 1\n\n      self.id = FrontRow.totalSupply\n      self.blueprintId = blueprintId\n      self.serialNumber = serialNumber\n\n      emit Minted(\n        id: self.id,\n        blueprintId: self.blueprintId,\n        serialNumber: serialNumber\n      )\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Minter\n\nThe interface that allows owner to mint new NFTs\n"}, {"role": "assistant", "content": "pub resource interface Minter {\n\n    // mintNFT mints one NFT from a blueprint\n    //\n    // Parameters: blueprintId: the ID of the blueprint used for minting\n    //\n    // Returns: @FrontRow.NFT token that was minted\n    //\n    pub fun mintNFT(blueprintId: UInt32): @NFT\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintNFT mints one NFT from a blueprint\n\nParameters: blueprintId: the ID of the blueprint used for minting\n\nReturns: @FrontRow.NFT token that was minted\n"}, {"role": "assistant", "content": "pub fun mintNFT(blueprintId: UInt32): @NFT"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is a special authorization resource that\nallows the owner to perform important functions such as\nmanage blueprints and mint NFTs\n"}, {"role": "assistant", "content": "pub resource Admin: Minter {\n\n    // printBlueprint creates a new blueprint and stores it in the blueprints dictionary\n    // in the FrontRow smart contract\n    //\n    // Parameters:  maxQuantity: maximum number of NFTs that can be minted\n    //              metadata: A dictionary mapping metadata titles to their data\n    //                       example: {\"artist\": \"BTS\", \"title\": \"Permission to Dance\"}\n    //\n    // Returns: the ID of the new Blueprint object\n    //\n    pub fun printBlueprint(maxQuantity: UInt32,\n        metadata: {String:String}): UInt32 {\n      post {\n        FrontRow.nextBlueprintId == before(FrontRow.nextBlueprintId) + 1 :\n          \"Couldn't create blueprint: the id must be incremented by 1.\"\n      }\n      // Get the new blueprint ID from the global counter\n      let newId = FrontRow.nextBlueprintId\n\n      // Store the newly printed blueprint in the global dictionary\n      FrontRow.blueprints[newId] =\n        Blueprint(id: newId, maxQuantity: maxQuantity, metadata: metadata)\n\n      // Increment the global counter for the next blueprint\n      FrontRow.nextBlueprintId = FrontRow.nextBlueprintId + 1\n\n      // Emit the corresponding event\n      emit BlueprintPrinted(id: newId, maxQuantity: maxQuantity)\n\n      // Return ID of the newly printed blueprint\n      return newId\n    }\n\n    // cancelBlueprint cancels a blueprint so no more NFTs can be minted fron it\n    //\n    // Parameters:  blueprintId: ID of the blueprint to cancel\n    //\n    pub fun cancelBlueprint(_ blueprintId: UInt32) {\n      let blueprint: Blueprint = FrontRow.blueprints[blueprintId]!\n      blueprint.cancel()\n      FrontRow.blueprints[blueprintId] = blueprint\n      emit BlueprintCancelled(id: blueprintId)\n    }\n\n    // mintNFT mints one NFT from a blueprint\n    //\n    // Parameters: blueprintId: the ID of the blueprint used for minting\n    //\n    // Returns: @FrontRow.NFT token that was minted\n    //\n    pub fun mintNFT(blueprintId: UInt32): @NFT {\n\n      // Check if the blueprint with provided ID exists\n      pre {\n        FrontRow.blueprints[blueprintId] != nil :\n          \"Couldn't create nft: blueprint doesn't exist.\"\n      }\n\n      // Check if the serial number has been incremented correctly\n      post {\n        FrontRow.blueprints[blueprintId]!.getMintCount() ==\n            before(FrontRow.blueprints[blueprintId]!.getMintCount()) + 1 :\n          \"Couldn't create nft: the serial number must be incremented by 1.\"\n      }\n\n      // Retrieve the corresponding blueprint from the global dictionary\n      let blueprint: Blueprint = FrontRow.blueprints[blueprintId]!\n\n      // Set the serial number based on the total mintCount value\n      let serialNumber: UInt32 = blueprint.getMintCount() + 1\n\n      // Mint NFT\n      let newNFT: @NFT <- create FrontRow.NFT(\n        blueprintId: blueprintId,\n        serialNumber: serialNumber\n      )\n\n      // Update the corresponding blueprint struct\n      blueprint.setMintCount(serialNumber)\n      blueprint.setNftId(serialNumber, nftId: newNFT.id)\n\n      // Store updated blueprint struct in the dictionary\n      FrontRow.blueprints[blueprintId] = blueprint\n\n      // Return newly minted NFT token\n      return <-newNFT\n    }\n\n    // batchMintNFT mints an arbitrary quantity of FrontRow NFTs and\n    // deposits them into receiver's collection\n    //\n    // Parameters: blueprintId: the ID of the blueprint used for minting\n    //             quantity: number of NFTs to be minted\n    //             receiverRef: reference to the receiver's collection\n    //\n    pub fun batchMintNFT(\n      blueprintId: UInt32,\n      quantity: UInt64,\n      receiverRef: &AnyResource{FrontRow.CollectionPublic}\n    ) {\n      // Mint and deposit NFTs to receiver's collection\n      var i: UInt64 = 0\n      while i < quantity {\n        receiverRef.deposit(token: <-self.mintNFT(blueprintId: blueprintId))\n        i = i + 1\n      }\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: printBlueprint creates a new blueprint and stores it in the blueprints dictionary\nin the FrontRow smart contract\n\nParameters:  maxQuantity: maximum number of NFTs that can be minted\nmetadata: A dictionary mapping metadata titles to their data\nexample: {\"artist\": \"BTS\", \"title\": \"Permission to Dance\"}\n\nReturns: the ID of the new Blueprint object\n"}, {"role": "assistant", "content": "pub fun printBlueprint(maxQuantity: UInt32,\n        metadata: {String:String}): UInt32 {\n      post {\n        FrontRow.nextBlueprintId == before(FrontRow.nextBlueprintId) + 1 :\n          \"Couldn't create blueprint: the id must be incremented by 1.\"\n      }\n      // Get the new blueprint ID from the global counter\n      let newId = FrontRow.nextBlueprintId\n\n      // Store the newly printed blueprint in the global dictionary\n      FrontRow.blueprints[newId] =\n        Blueprint(id: newId, maxQuantity: maxQuantity, metadata: metadata)\n\n      // Increment the global counter for the next blueprint\n      FrontRow.nextBlueprintId = FrontRow.nextBlueprintId + 1\n\n      // Emit the corresponding event\n      emit BlueprintPrinted(id: newId, maxQuantity: maxQuantity)\n\n      // Return ID of the newly printed blueprint\n      return newId\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: cancelBlueprint cancels a blueprint so no more NFTs can be minted fron it\n\nParameters:  blueprintId: ID of the blueprint to cancel\n"}, {"role": "assistant", "content": "pub fun cancelBlueprint(_ blueprintId: UInt32) {\n      let blueprint: Blueprint = FrontRow.blueprints[blueprintId]!\n      blueprint.cancel()\n      FrontRow.blueprints[blueprintId] = blueprint\n      emit BlueprintCancelled(id: blueprintId)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintNFT mints one NFT from a blueprint\n\nParameters: blueprintId: the ID of the blueprint used for minting\n\nReturns: @FrontRow.NFT token that was minted\n"}, {"role": "assistant", "content": "pub fun mintNFT(blueprintId: UInt32): @NFT {\n\n      // Check if the blueprint with provided ID exists\n      pre {\n        FrontRow.blueprints[blueprintId] != nil :\n          \"Couldn't create nft: blueprint doesn't exist.\"\n      }\n\n      // Check if the serial number has been incremented correctly\n      post {\n        FrontRow.blueprints[blueprintId]!.getMintCount() ==\n            before(FrontRow.blueprints[blueprintId]!.getMintCount()) + 1 :\n          \"Couldn't create nft: the serial number must be incremented by 1.\"\n      }\n\n      // Retrieve the corresponding blueprint from the global dictionary\n      let blueprint: Blueprint = FrontRow.blueprints[blueprintId]!\n\n      // Set the serial number based on the total mintCount value\n      let serialNumber: UInt32 = blueprint.getMintCount() + 1\n\n      // Mint NFT\n      let newNFT: @NFT <- create FrontRow.NFT(\n        blueprintId: blueprintId,\n        serialNumber: serialNumber\n      )\n\n      // Update the corresponding blueprint struct\n      blueprint.setMintCount(serialNumber)\n      blueprint.setNftId(serialNumber, nftId: newNFT.id)\n\n      // Store updated blueprint struct in the dictionary\n      FrontRow.blueprints[blueprintId] = blueprint\n\n      // Return newly minted NFT token\n      return <-newNFT\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: batchMintNFT mints an arbitrary quantity of FrontRow NFTs and\ndeposits them into receiver's collection\n\nParameters: blueprintId: the ID of the blueprint used for minting\nquantity: number of NFTs to be minted\nreceiverRef: reference to the receiver's collection\n"}, {"role": "assistant", "content": "pub fun batchMintNFT(\n      blueprintId: UInt32,\n      quantity: UInt64,\n      receiverRef: &AnyResource{FrontRow.CollectionPublic}\n    ) {\n      // Mint and deposit NFTs to receiver's collection\n      var i: UInt64 = 0\n      while i < quantity {\n        receiverRef.deposit(token: <-self.mintNFT(blueprintId: blueprintId))\n        i = i + 1\n      }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The interface that users can cast their NFT Collection as\nto allow others to deposit FrontRow NFTs into their Collection.\nIt also allows for reading the IDs of FrontRow NFTs in the Collection.\n"}, {"role": "assistant", "content": "pub resource interface CollectionPublic {\n    pub fun deposit(token: @NonFungibleToken.NFT)\n    pub fun getIDs(): [UInt64]\n    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n    pub fun borrowFrontRowNFT(id: UInt64): &FrontRow.NFT? {\n      // If the result isn't nil, the id of the returned reference\n      // should be the same as the argument to the function\n      post {\n        (result == nil) || (result?.id == id):\n          \"Can't borrow NFT reference: The ID of the returned reference is incorrect.\"\n      }\n    }\n\n    // borrowNftByBlueprint let users borrow NFTs based on given blueprint id\n    // and a serial number\n    //\n    // Parameters: blueprintId: the ID of the blueprint\n    //             serialNumber: serial number of the NFT with regard to the blueprint\n    //\n    // Returns: the ID of the new Blueprint object\n    //\n    pub fun borrowNftByBlueprint(blueprintId: UInt32, serialNumber: UInt32): &FrontRow.NFT?{\n      // If the result isn't nil, the id of the returned reference\n      // should be the same as the argument to the function\n      post {\n        (result == nil) || (result?.blueprintId == blueprintId) || (result?.serialNumber == serialNumber):\n          \"Can't borrow NFT reference: The ID of the returned reference is incorrect.\"\n      }\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNftByBlueprint let users borrow NFTs based on given blueprint id\nand a serial number\n\nParameters: blueprintId: the ID of the blueprint\nserialNumber: serial number of the NFT with regard to the blueprint\n\nReturns: the ID of the new Blueprint object\n"}, {"role": "assistant", "content": "pub fun borrowNftByBlueprint(blueprintId: UInt32, serialNumber: UInt32): &FrontRow.NFT?{\n      // If the result isn't nil, the id of the returned reference\n      // should be the same as the argument to the function\n      post {\n        (result == nil) || (result?.blueprintId == blueprintId) || (result?.serialNumber == serialNumber):\n          \"Can't borrow NFT reference: The ID of the returned reference is incorrect.\"\n      }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection is a resource that every user who owns NFTs\nwill store in their account to manage their NFTs\n"}, {"role": "assistant", "content": "pub resource Collection: CollectionPublic, NonFungibleToken.Provider,\n      NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n    // Dictionary of NFT conforming tokens\n    // NFT is a resource type with a UInt64 ID field\n    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n    init() {\n      self.ownedNFTs <- {}\n    }\n\n    // withdraw removes an NFT from the Collection and moves it to the caller\n    //\n    // Parameters: withdrawID: the ID of the NFT that is to be removed from the Collection\n    //\n    // Returns: @NonFungibleToken.NFT the token that was withdrawn\n    //\n    pub fun withdraw(withdrawID: UInt64): @NFT {\n\n      // Remove the NFT from the Collection\n      let token <- self.ownedNFTs.remove(key: withdrawID)\n          ?? panic(\"Can't withdraw: NFT does not exist in the collection.\")\n\n      emit Withdraw(id: token.id, from: self.owner?.address)\n\n      // Return the withdrawn token\n      return <-(token as! @FrontRow.NFT)\n    }\n\n    // deposit take an NFT and adds it to the Collections dictionary\n    //\n    // Parameters: token: the NFT to be deposited in the collection\n    //\n    pub fun deposit(token: @NonFungibleToken.NFT) {\n\n      // Cast the deposited token as a FrontRow NFT to make sure\n      // it is the correct type\n      let token <- token as! @FrontRow.NFT\n\n      // Get the token's ID\n      let id = token.id\n\n      // Add the new token to the dictionary\n      let oldToken <- self.ownedNFTs[id] <- token\n\n      // Only emit a deposit event if the Collection\n      // is in an account's storage\n      if self.owner?.address != nil {\n        emit Deposit(id: id, to: self.owner?.address)\n      }\n\n      // Destroy the empty old token that was \"removed\"\n      destroy oldToken\n    }\n\n    // getIDs returns an array of the IDs that are in the Collection\n    //\n    // Returns: an array of NFT IDs in the owner's collection\n    //\n    pub fun getIDs(): [UInt64] {\n      return self.ownedNFTs.keys\n    }\n\n    // borrowNFT returns a borrowed reference to an NFT in the Collection\n    // so that the caller can read its ID\n    //\n    // Parameters: id: The ID of the NFT to get the reference for\n    //\n    // Returns: A reference to the NFT\n    //\n    // Note: This only allows the caller to read the ID of the NFT,\n    // not any specific data. Please use borrowFrontRowNFT to\n    // read NFT data.\n    //\n    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n      pre {\n          self.ownedNFTs[id] != nil: \"NFT does not exist in the collection!\"\n      }\n      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n    }\n\n    // borrowFrontRowNFT returns a borrowed reference to a FrontRow NFT\n    // so that the caller can read data and call methods from it.\n    // They can use this to read its blueprintId, serialNumber,\n    // or any of a Blueprint data associated with it by\n    // getting a blueprintId and reading those fields from\n    // the smart contract.\n    //\n    // Parameters: id: The ID of the NFT to get the reference for\n    //\n    // Returns: &FrontRow.NFT a reference to the FrontRow NFT\n    //\n    pub fun borrowFrontRowNFT(id: UInt64): &FrontRow.NFT? {\n      if self.ownedNFTs[id] != nil {\n        let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n        return ref as! &FrontRow.NFT\n      } else {\n        return nil\n      }\n    }\n\n    // borrowNftByBlueprint returns a borrowed reference to a FrontRow NFT\n    // based on provided blueprint id and a serial number.\n    //\n    // Parameters:  blueprintId: The ID of the blueprint that NFT is associated with\n    //              serialNumber: serial number of the NFT in relation to the blueprint\n    //\n    // Returns: &FrontRow.NFT a reference to the FrontRow NFT\n    //\n    pub fun borrowNftByBlueprint(blueprintId: UInt32, serialNumber: UInt32): &FrontRow.NFT? {\n      let maybeBlueprint = FrontRow.blueprints[blueprintId]\n\n      if let blueprint = maybeBlueprint {\n        let maybeNftId = blueprint.getNftId(serialNumber)\n        if let nftId = maybeNftId {\n          if self.ownedNFTs[nftId] != nil {\n        let ref = (&self.ownedNFTs[nftId] as auth &NonFungibleToken.NFT?)!\n            return ref as! &FrontRow.NFT\n          }\n        }\n      }\n      return nil\n    }\n\n    // If a transaction destroys the Collection object,\n    // all the NFTs contained within are also destroyed!\n    //\n    destroy() {\n      destroy self.ownedNFTs\n    }\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of NFT conforming tokens\nNFT is a resource type with a UInt64 ID field"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an NFT from the Collection and moves it to the caller\n\nParameters: withdrawID: the ID of the NFT that is to be removed from the Collection\n\nReturns: @NonFungibleToken.NFT the token that was withdrawn\n"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NFT {\n\n      // Remove the NFT from the Collection\n      let token <- self.ownedNFTs.remove(key: withdrawID)\n          ?? panic(\"Can't withdraw: NFT does not exist in the collection.\")\n\n      emit Withdraw(id: token.id, from: self.owner?.address)\n\n      // Return the withdrawn token\n      return <-(token as! @FrontRow.NFT)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit take an NFT and adds it to the Collections dictionary\n\nParameters: token: the NFT to be deposited in the collection\n"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n\n      // Cast the deposited token as a FrontRow NFT to make sure\n      // it is the correct type\n      let token <- token as! @FrontRow.NFT\n\n      // Get the token's ID\n      let id = token.id\n\n      // Add the new token to the dictionary\n      let oldToken <- self.ownedNFTs[id] <- token\n\n      // Only emit a deposit event if the Collection\n      // is in an account's storage\n      if self.owner?.address != nil {\n        emit Deposit(id: id, to: self.owner?.address)\n      }\n\n      // Destroy the empty old token that was \"removed\"\n      destroy oldToken\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getIDs returns an array of the IDs that are in the Collection\n\nReturns: an array of NFT IDs in the owner's collection\n"}, {"role": "assistant", "content": "pub fun getIDs(): [UInt64] {\n      return self.ownedNFTs.keys\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT returns a borrowed reference to an NFT in the Collection\nso that the caller can read its ID\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: A reference to the NFT\n\nNote: This only allows the caller to read the ID of the NFT,\nnot any specific data. Please use borrowFrontRowNFT to\nread NFT data.\n"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n      pre {\n          self.ownedNFTs[id] != nil: \"NFT does not exist in the collection!\"\n      }\n      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowFrontRowNFT returns a borrowed reference to a FrontRow NFT\nso that the caller can read data and call methods from it.\nThey can use this to read its blueprintId, serialNumber,\nor any of a Blueprint data associated with it by\ngetting a blueprintId and reading those fields from\nthe smart contract.\n\nParameters: id: The ID of the NFT to get the reference for\n\nReturns: &FrontRow.NFT a reference to the FrontRow NFT\n"}, {"role": "assistant", "content": "pub fun borrowFrontRowNFT(id: UInt64): &FrontRow.NFT? {\n      if self.ownedNFTs[id] != nil {\n        let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n        return ref as! &FrontRow.NFT\n      } else {\n        return nil\n      }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNftByBlueprint returns a borrowed reference to a FrontRow NFT\nbased on provided blueprint id and a serial number.\n\nParameters:  blueprintId: The ID of the blueprint that NFT is associated with\nserialNumber: serial number of the NFT in relation to the blueprint\n\nReturns: &FrontRow.NFT a reference to the FrontRow NFT\n"}, {"role": "assistant", "content": "pub fun borrowNftByBlueprint(blueprintId: UInt32, serialNumber: UInt32): &FrontRow.NFT? {\n      let maybeBlueprint = FrontRow.blueprints[blueprintId]\n\n      if let blueprint = maybeBlueprint {\n        let maybeNftId = blueprint.getNftId(serialNumber)\n        if let nftId = maybeNftId {\n          if self.ownedNFTs[nftId] != nil {\n        let ref = (&self.ownedNFTs[nftId] as auth &NonFungibleToken.NFT?)!\n            return ref as! &FrontRow.NFT\n          }\n        }\n      }\n      return nil\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: If a transaction destroys the Collection object,\nall the NFTs contained within are also destroyed!\n"}, {"role": "assistant", "content": "destroy() {\n      destroy self.ownedNFTs\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: createEmptyCollection creates an empty collection of NFTs\n\nReturns: @NonFungibleToken.Collection newly created empty collection\n"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n    return <-create Collection()\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getBlueprints returns map of blueprint IDs to the corresponding blueprint structs\n\nReturns: a map of blueprint IDs to the corresponding blueprint objects\n"}, {"role": "assistant", "content": "pub fun getBlueprints(): {UInt32: Blueprint} {\n    return FrontRow.blueprints\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getBlueprint returns a single blueprint struct\nbased on provided blueprint id and a serial number.\n\nParameters:  id: ID of the blueprint to return\n\nReturns: a blueprint struct\n"}, {"role": "assistant", "content": "pub fun getBlueprint(id: UInt32): Blueprint? {\n    return FrontRow.blueprints[id]\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getBlueprintsCount returns total number of blueprints in existence\n\nReturns: total number of blueprints printed so far\n"}, {"role": "assistant", "content": "pub fun getBlueprintsCount(): UInt32 {\n    let count = FrontRow.blueprints != nil ? FrontRow.blueprints.length : 0\n    return UInt32(count)\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getBlueprintMintCount returns the total number of NFTs minted for a blueprint\n\nParameters:  id: ID of the blueprint\n\nReturns: the mint count for the given blueprint\n"}, {"role": "assistant", "content": "pub fun getBlueprintMintCount(_ blueprintId: UInt32) : UInt32 {\n    let blueprint: Blueprint = FrontRow.blueprints[blueprintId]!\n    let count = blueprint != nil ? blueprint.getMintCount() : (0 as UInt32)\n    return count\n  }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: PATHS"}, {"role": "assistant", "content": "pub let CollectionStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: EVENTS"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: EVENTS"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The total amount of DOFs that have ever been created"}, {"role": "assistant", "content": "pub var totalSupply: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: All the DOF Series"}, {"role": "assistant", "content": "access(account) var allSeries: @{UInt64: DOFSeries}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Wrapper containing the id of a DOF and its series, and its serial"}, {"role": "assistant", "content": "pub struct TokenIdentifier {\n        pub let id: UInt64\n        pub let seriesId: UInt64\n        pub let serial: UInt64\n\n        init(_id: UInt64, _seriesId: UInt64, _serial: UInt64) {\n            self.id = _id\n            self.seriesId = _seriesId\n            self.serial = _serial\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Represents a DOF item"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {\n        pub let id: UInt64\n        pub let seriesDescription: String\n        pub let seriesId: UInt64\n        pub let seriesImage: String\n        pub let seriesName: String\n        pub let serial: UInt64\n\n        pub fun getViews(): [Type] {\n             return [\n                Type<MetadataViews.Display>(),\n                Type<MetadataViews.Royalties>(),\n                Type<MetadataViews.Editions>(),\n                Type<MetadataViews.ExternalURL>(),\n                Type<MetadataViews.NFTCollectionData>(),\n                Type<MetadataViews.NFTCollectionDisplay>(),\n                Type<MetadataViews.Serial>()\n            ]\n        }\n\n        pub fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: self.seriesName, \n                        description: self.seriesDescription, \n                        file: MetadataViews.IPFSFile(cid: self.seriesImage, path: nil)\n                    )\n\n                case Type<MetadataViews.Editions>():\n                    let editionInfo = MetadataViews.Edition(name: self.seriesName, number: self.serial, max: nil)\n                    let editionList: [MetadataViews.Edition] = [editionInfo]\n                    return MetadataViews.Editions(\n                        editionList\n                    )\n\n                case Type<MetadataViews.Serial>():\n                    return MetadataViews.Serial(\n                        self.serial\n                    )\n\n                case Type<MetadataViews.Royalties>():\n                    let royalty = MetadataViews.Royalty(recepient: DaysOnFlow.account.getCapability<&AnyResource{FungibleToken.Receiver}>(/public/flowTokenReceiver), cut: 0.05, description: \"Default royalty\")\n                    return MetadataViews.Royalties([royalty])\n\n                case Type<MetadataViews.ExternalURL>():\n                    return MetadataViews.ExternalURL(\"https://day-nft.io\")\n\n                case Type<MetadataViews.NFTCollectionData>():\n                    return MetadataViews.NFTCollectionData(\n                        storagePath: DaysOnFlow.CollectionStoragePath,\n                        publicPath: DaysOnFlow.CollectionPublicPath,\n                        providerPath: /private/DOFCollectionProviderPath,\n                        publicCollection: Type<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic}>(),\n                        publicLinkedType: Type<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),\n                        providerLinkedType: Type<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),\n                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {\n                            return <-DaysOnFlow.createEmptyCollection()\n                        })\n                    )\n\n                case Type<MetadataViews.NFTCollectionDisplay>():\n                    let media = MetadataViews.Media(\n                        file: MetadataViews.IPFSFile(cid: self.seriesImage, path: nil),\n                        mediaType: \"ipfs\"\n                    )\n                    return MetadataViews.NFTCollectionDisplay(\n                        name: self.seriesName,\n                        description: self.seriesDescription,\n                        externalURL: MetadataViews.ExternalURL(\"https://day-nft.io\"),\n                        squareImage: media,\n                        bannerImage: media,\n                        socials: {\n                            \"twitter\": MetadataViews.ExternalURL(\"https://twitter.com/day_nft_io\")\n                        }\n                    )\n            }\n            return nil\n        }\n\n        init(_seriesDescription: String, _seriesId: UInt64, _seriesImage: String, _seriesName: String, _serial: UInt64, _saleType: String) {\n            self.id = DaysOnFlow.totalSupply\n            self.seriesDescription = _seriesDescription\n            self.seriesId = _seriesId\n            self.seriesImage = _seriesImage\n            self.seriesName = _seriesName\n            self.serial = _serial\n            \n            emit DOFMinted(\n                id: self.id, \n                seriesId: _seriesId, \n                seriesImage: _seriesImage,\n                serial: _serial,\n                saleType: _saleType\n            )\n\n            DaysOnFlow.totalSupply = DaysOnFlow.totalSupply + 1\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A public interface for people to call into our Collection"}, {"role": "assistant", "content": "pub resource interface CollectionPublic {\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowDOF(id: UInt64): &NFT?\n        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun getIDs(): [UInt64]\n        pub fun ownedIdsFromSeries(seriesId: UInt64): [UInt64]\n        pub fun ownedDOFsFromSeries(seriesId: UInt64): [&NFT]\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Collection that holds all of the users DOFs."}, {"role": "assistant", "content": "pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, CollectionPublic {\n        // Maps a DOF id to the DOF itself\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n        // Maps a seriesId to the ids of DOFs that\n        // this user owns from that series\n        access(account) var series: {UInt64: {UInt64: Bool}}\n\n        // Deposits a DOF into the collection\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let nft <- token as! @NFT\n            let id = nft.id\n            let seriesId = nft.seriesId\n            emit Deposit(id: id, to: self.owner!.address)\n            if self.series[seriesId] == nil {\n                self.series[seriesId] = {id: true}\n            } else {\n                self.series[seriesId]!.insert(key: id, true)\n            }\n            self.ownedNFTs[id] <-! nft\n        }\n\n        // withdraw removes an NFT from the collection and moves it to the caller\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n            let nft <- token as! @NFT\n            let id = nft.id\n            self.series[nft.seriesId]!.remove(key: id)\n            emit Withdraw(id: id, from: self.owner?.address)\n\n            return <-nft\n        }\n\n        // Get all ids\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // Returns an array of ids that belong to\n        // the passed in seriesId\n        pub fun ownedIdsFromSeries(seriesId: UInt64): [UInt64] {\n            if self.series[seriesId] != nil {\n                return self.series[seriesId]!.keys\n            }\n            return []\n        }\n\n        // Returns an array of DOFs that belong to\n        // the passed in seriesId\n        pub fun ownedDOFsFromSeries(seriesId: UInt64): [&NFT] {\n            let answer: [&NFT] = []\n            let ids = self.ownedIdsFromSeries(seriesId: seriesId)\n            for id in ids {\n                answer.append(self.borrowDOF(id: id)!)\n            }\n            return answer\n        }\n\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        pub fun borrowDOF(id: UInt64): &NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?\n                return ref as! &NFT?\n            }\n            return nil\n        }\n\n        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {\n            let tokenRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n            let nftRef = tokenRef as! &NFT\n            return nftRef as &{MetadataViews.Resolver}\n        }\n\n        init() {\n            self.ownedNFTs <- {}\n            self.series = {}\n        }\n\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Maps a DOF id to the DOF itself"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Maps a seriesId to the ids of DOFs that\nthis user owns from that series"}, {"role": "assistant", "content": "access(account) var series: {UInt64: {UInt64: Bool}}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Deposits a DOF into the collection"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            let nft <- token as! @NFT\n            let id = nft.id\n            let seriesId = nft.seriesId\n            emit Deposit(id: id, to: self.owner!.address)\n            if self.series[seriesId] == nil {\n                self.series[seriesId] = {id: true}\n            } else {\n                self.series[seriesId]!.insert(key: id, true)\n            }\n            self.ownedNFTs[id] <-! nft\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an NFT from the collection and moves it to the caller"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n            let nft <- token as! @NFT\n            let id = nft.id\n            self.series[nft.seriesId]!.remove(key: id)\n            emit Withdraw(id: id, from: self.owner?.address)\n\n            return <-nft\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get all ids"}, {"role": "assistant", "content": "pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Returns an array of ids that belong to\nthe passed in seriesId"}, {"role": "assistant", "content": "pub fun ownedIdsFromSeries(seriesId: UInt64): [UInt64] {\n            if self.series[seriesId] != nil {\n                return self.series[seriesId]!.keys\n            }\n            return []\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Returns an array of DOFs that belong to\nthe passed in seriesId"}, {"role": "assistant", "content": "pub fun ownedDOFsFromSeries(seriesId: UInt64): [&NFT] {\n            let answer: [&NFT] = []\n            let ids = self.ownedIdsFromSeries(seriesId: seriesId)\n            for id in ids {\n                answer.append(self.borrowDOF(id: id)!)\n            }\n            return answer\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Represents a DaysOnFlow series\nAn item of this series can be minted in three ways:\n- A list of DayNFT holders have right to mint an item for free\n- A list of WL addresses have right to mint an item for a given price\n- A given quantity is publicly avaiable"}, {"role": "assistant", "content": "pub resource DOFSeries: MetadataViews.Resolver {\n        pub var wlClaimable: Bool\n        pub var publicClaimable: Bool\n        pub let description: String \n        pub let seriesId: UInt64\n        pub let image: String\n        pub let name: String\n        pub var totalSupply: UInt64\n\n        // Keeps track of the DayNFT holders that have already claimed\n        access(self) let dayNFTwlClaimed: {UInt64: Bool}\n        // Keeps track of the WL addresses that have already claimed\n        access(self) let wlClaimed: {Address: Bool}\n        // WL price\n        pub let wlPrice: UFix64\n        // Number of items available for the public sale\n        pub let publicSupply: UInt64\n        // Public price      \n        pub let publicPrice: UFix64\n        // Items already minted on the public sale\n        pub var publicMinted: UInt64\n\n        // Get number of DayNFT WL that have been claimed vs total\n        pub fun dayNFTwlStats(): [Int] {\n            var claimed = 0\n            for wl in self.dayNFTwlClaimed.keys {\n                if self.dayNFTwlClaimed[wl]! {\n                    claimed = claimed + 1\n                }\n            }\n            return [claimed, self.dayNFTwlClaimed.keys.length]\n        }\n\n        // Get number of WL that have been claimed vs total\n        pub fun wlStats(): [Int] {\n            var claimed = 0\n            for wl in self.wlClaimed.keys {\n                if self.wlClaimed[wl]! {\n                    claimed = claimed + 1\n                }\n            }\n            return [claimed, self.wlClaimed.keys.length]\n        }\n\n        // Number of NFT mintable based on holding DayNFTs\n        pub fun nbDayNFTwlToMint(address: Address): Int {\n            // DayNFT collection\n            let holder = getAccount(address)\n                        .getCapability(DayNFT.CollectionPublicPath)\n                        .borrow<&DayNFT.Collection{DayNFT.CollectionPublic}>()\n            \n            if holder == nil || !self.wlClaimable {\n              return 0\n            }\n\n            // Compute amount due based on number of NFTs detained\n            var toMint = 0\n            for id in holder!.getIDs() {\n                if self.dayNFTwlClaimed[id] != nil && !self.dayNFTwlClaimed[id]! {\n                    toMint = toMint + 1\n                }\n            }\n            return toMint\n        }\n\n        // Checks if an address is on the white list\n        pub fun hasWlToMint(address: Address): Bool {\n            return self.wlClaimable && self.wlClaimed[address] != nil && !self.wlClaimed[address]!\n        }\n\n        // Mints items available based on holding DayNFTs\n        pub fun mintDayNFTwl(address: Address) {\n            if !self.wlClaimable {\n                panic(\"Unclaimable series\")\n            }\n            // DayNFT collection\n            let holder = getAccount(address)\n                        .getCapability(DayNFT.CollectionPublicPath)\n                        .borrow<&DayNFT.Collection{DayNFT.CollectionPublic}>()\n                        ?? panic(\"Could not get receiver reference to the DayNFT Collection\")\n\n            for id in holder.getIDs() {\n                if self.dayNFTwlClaimed[id] != nil && !self.dayNFTwlClaimed[id]! {\n                    self.mint(address: address, saleType: \"DayNFT WL\")\n                    self.dayNFTwlClaimed[id] = true\n                }\n            }\n        }\n\n        // Mints an item for a whitelisted address\n        pub fun mintWl(address: Address, vault: @FlowToken.Vault) {\n            if !self.wlClaimable {\n                panic(\"Unclaimable series\")\n            }\n            if vault.balance != self.wlPrice {\n                panic(\"Bad WL price amount\")\n            }\n            if self.wlClaimed[address] == nil {\n                panic(\"Account not whitelisted\")\n            }\n            if self.wlClaimed[address]! {\n                panic(\"Already claimed\")\n            }\n            let rec = DaysOnFlow.account.getCapability(/public/flowTokenReceiver) \n                        .borrow<&FlowToken.Vault{FungibleToken.Receiver}>()\n                        ?? panic(\"Could not borrow a reference to the Flow receiver\")\n            rec.deposit(from: <- vault)\n            self.mint(address: address, saleType: \"WL\")\n            self.wlClaimed[address] = true            \n        }\n\n        // Number of items left for the public sale\n        pub fun nbPublicToMint(): Int {\n            if !self.publicClaimable {\n                return 0\n            }\n            return Int(self.publicSupply - self.publicMinted)\n        }\n\n        // Mint an item on the public sale\n        pub fun mintPublic(address: Address, vault: @FlowToken.Vault) {\n            if !self.publicClaimable {\n                panic(\"Unclaimable series\")\n            }\n            if vault.balance != self.publicPrice {\n                panic(\"Bad public price amount\")\n            }\n            if self.publicMinted >= self.publicSupply {\n                panic(\"Nothing left on public sale\")\n            }\n            let rec = DaysOnFlow.account.getCapability(/public/flowTokenReceiver) \n                        .borrow<&FlowToken.Vault{FungibleToken.Receiver}>()\n                        ?? panic(\"Could not borrow a reference to the Flow receiver\")\n            rec.deposit(from: <- vault)\n            self.mint(address: address, saleType: \"Public\")\n            self.publicMinted = self.publicMinted + 1\n        }\n\n        pub fun getViews(): [Type] {\n             return [\n                Type<MetadataViews.Display>()\n            ]\n        }\n\n        pub fun resolveView(_ view: Type): AnyStruct? {\n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: self.name, \n                        description: self.description, \n                        file: MetadataViews.IPFSFile(cid: self.image, path: nil)\n                    )\n            }\n\n            return nil\n        }\n\n        // Sets whether the series is claimable or not\n        access(contract) fun setClaimable(wlClaimable: Bool, publicClaimable: Bool) {\n            self.wlClaimable = wlClaimable\n            self.publicClaimable = publicClaimable\n        }\n\n        // Mint an item\n        access(contract) fun mint(address: Address, saleType: String): UInt64 {\n            // DOF collection\n            let receiver = getAccount(address)\n                            .getCapability(DaysOnFlow.CollectionPublicPath)\n                            .borrow<&{DaysOnFlow.CollectionPublic}>()\n                            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n            let serial = self.totalSupply\n\n            let token <- create NFT(\n                _seriesDescription: self.description,\n                _seriesId: self.seriesId,\n                _seriesImage: self.image,\n                _seriesName: self.name,\n                _serial: serial,\n                _saleType: saleType,\n            ) \n            let id = token.id\n\n            self.totalSupply = self.totalSupply + 1\n            receiver.deposit(token: <- token)\n            return id\n        }\n        \n        init (\n            _wlClaimable: Bool,\n            _publicClaimable: Bool,\n            _description: String, \n            _image: String,\n            _name: String,\n            _dayNFTwl: [UInt64],    // List of DayNFT ids giving right to an item\n            _wl: [Address],         // List of WL addresses\n            _wlPrice: UFix64,\n            _publicSupply: UInt64,\n            _publicPrice: UFix64,\n        ) {\n            self.wlClaimable = _wlClaimable\n            self.publicClaimable = _publicClaimable\n            self.description = _description\n            self.seriesId = self.uuid\n            self.image = _image\n            self.name = _name\n            self.totalSupply = 0\n            self.wlPrice = _wlPrice\n            self.publicSupply = _publicSupply\n            self.publicPrice = _publicPrice\n            self.publicMinted = 0\n\n\n            self.dayNFTwlClaimed = {}\n            for dwl in _dayNFTwl {\n                self.dayNFTwlClaimed[dwl] = false\n            }\n\n            self.wlClaimed = {}\n            for wl in _wl {\n                self.wlClaimed[wl] = false\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Keeps track of the DayNFT holders that have already claimed"}, {"role": "assistant", "content": "access(self) let dayNFTwlClaimed: {UInt64: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Keeps track of the WL addresses that have already claimed"}, {"role": "assistant", "content": "access(self) let wlClaimed: {Address: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: WL price"}, {"role": "assistant", "content": "pub let wlPrice: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Number of items available for the public sale"}, {"role": "assistant", "content": "pub let publicSupply: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Public price"}, {"role": "assistant", "content": "pub let publicPrice: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Items already minted on the public sale"}, {"role": "assistant", "content": "pub var publicMinted: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get number of DayNFT WL that have been claimed vs total"}, {"role": "assistant", "content": "pub fun dayNFTwlStats(): [Int] {\n            var claimed = 0\n            for wl in self.dayNFTwlClaimed.keys {\n                if self.dayNFTwlClaimed[wl]! {\n                    claimed = claimed + 1\n                }\n            }\n            return [claimed, self.dayNFTwlClaimed.keys.length]\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get number of WL that have been claimed vs total"}, {"role": "assistant", "content": "pub fun wlStats(): [Int] {\n            var claimed = 0\n            for wl in self.wlClaimed.keys {\n                if self.wlClaimed[wl]! {\n                    claimed = claimed + 1\n                }\n            }\n            return [claimed, self.wlClaimed.keys.length]\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Number of NFT mintable based on holding DayNFTs"}, {"role": "assistant", "content": "pub fun nbDayNFTwlToMint(address: Address): Int {\n            // DayNFT collection\n            let holder = getAccount(address)\n                        .getCapability(DayNFT.CollectionPublicPath)\n                        .borrow<&DayNFT.Collection{DayNFT.CollectionPublic}>()\n            \n            if holder == nil || !self.wlClaimable {\n              return 0\n            }\n\n            // Compute amount due based on number of NFTs detained\n            var toMint = 0\n            for id in holder!.getIDs() {\n                if self.dayNFTwlClaimed[id] != nil && !self.dayNFTwlClaimed[id]! {\n                    toMint = toMint + 1\n                }\n            }\n            return toMint\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Checks if an address is on the white list"}, {"role": "assistant", "content": "pub fun hasWlToMint(address: Address): Bool {\n            return self.wlClaimable && self.wlClaimed[address] != nil && !self.wlClaimed[address]!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mints items available based on holding DayNFTs"}, {"role": "assistant", "content": "pub fun mintDayNFTwl(address: Address) {\n            if !self.wlClaimable {\n                panic(\"Unclaimable series\")\n            }\n            // DayNFT collection\n            let holder = getAccount(address)\n                        .getCapability(DayNFT.CollectionPublicPath)\n                        .borrow<&DayNFT.Collection{DayNFT.CollectionPublic}>()\n                        ?? panic(\"Could not get receiver reference to the DayNFT Collection\")\n\n            for id in holder.getIDs() {\n                if self.dayNFTwlClaimed[id] != nil && !self.dayNFTwlClaimed[id]! {\n                    self.mint(address: address, saleType: \"DayNFT WL\")\n                    self.dayNFTwlClaimed[id] = true\n                }\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mints an item for a whitelisted address"}, {"role": "assistant", "content": "pub fun mintWl(address: Address, vault: @FlowToken.Vault) {\n            if !self.wlClaimable {\n                panic(\"Unclaimable series\")\n            }\n            if vault.balance != self.wlPrice {\n                panic(\"Bad WL price amount\")\n            }\n            if self.wlClaimed[address] == nil {\n                panic(\"Account not whitelisted\")\n            }\n            if self.wlClaimed[address]! {\n                panic(\"Already claimed\")\n            }\n            let rec = DaysOnFlow.account.getCapability(/public/flowTokenReceiver) \n                        .borrow<&FlowToken.Vault{FungibleToken.Receiver}>()\n                        ?? panic(\"Could not borrow a reference to the Flow receiver\")\n            rec.deposit(from: <- vault)\n            self.mint(address: address, saleType: \"WL\")\n            self.wlClaimed[address] = true            \n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Number of items left for the public sale"}, {"role": "assistant", "content": "pub fun nbPublicToMint(): Int {\n            if !self.publicClaimable {\n                return 0\n            }\n            return Int(self.publicSupply - self.publicMinted)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint an item on the public sale"}, {"role": "assistant", "content": "pub fun mintPublic(address: Address, vault: @FlowToken.Vault) {\n            if !self.publicClaimable {\n                panic(\"Unclaimable series\")\n            }\n            if vault.balance != self.publicPrice {\n                panic(\"Bad public price amount\")\n            }\n            if self.publicMinted >= self.publicSupply {\n                panic(\"Nothing left on public sale\")\n            }\n            let rec = DaysOnFlow.account.getCapability(/public/flowTokenReceiver) \n                        .borrow<&FlowToken.Vault{FungibleToken.Receiver}>()\n                        ?? panic(\"Could not borrow a reference to the Flow receiver\")\n            rec.deposit(from: <- vault)\n            self.mint(address: address, saleType: \"Public\")\n            self.publicMinted = self.publicMinted + 1\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Sets whether the series is claimable or not"}, {"role": "assistant", "content": "access(contract) fun setClaimable(wlClaimable: Bool, publicClaimable: Bool) {\n            self.wlClaimable = wlClaimable\n            self.publicClaimable = publicClaimable\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint an item"}, {"role": "assistant", "content": "access(contract) fun mint(address: Address, saleType: String): UInt64 {\n            // DOF collection\n            let receiver = getAccount(address)\n                            .getCapability(DaysOnFlow.CollectionPublicPath)\n                            .borrow<&{DaysOnFlow.CollectionPublic}>()\n                            ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n            let serial = self.totalSupply\n\n            let token <- create NFT(\n                _seriesDescription: self.description,\n                _seriesId: self.seriesId,\n                _seriesImage: self.image,\n                _seriesName: self.name,\n                _serial: serial,\n                _saleType: saleType,\n            ) \n            let id = token.id\n\n            self.totalSupply = self.totalSupply + 1\n            receiver.deposit(token: <- token)\n            return id\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin resource used to manage DOF Series"}, {"role": "assistant", "content": "pub resource SeriesMinter {\n\n        // Create a new series\n        pub fun createSeries(\n            _wlClaimable: Bool,\n            _publicClaimable: Bool,\n            _description: String, \n            _image: String, \n            _name: String,\n            _dayNFTwl: [UInt64],           \n            _wl: [Address],\n            _wlPrice: UFix64,\n            _publicSupply: UInt64,\n            _publicPrice: UFix64) {\n\n                let series <- create DOFSeries(\n                    _wlClaimable: _wlClaimable,\n                    _publicClaimable: _publicClaimable,\n                    _description: _description, \n                    _image: _image, \n                    _name: _name,\n                    _dayNFTwl: _dayNFTwl,           \n                    _wl: _wl,\n                    _wlPrice: _wlPrice,\n                    _publicSupply: _publicSupply,\n                    _publicPrice: _publicPrice,\n                )\n\n                let seriesId = series.seriesId\n                DaysOnFlow.allSeries[seriesId] <-! series\n            }\n\n        // Make a series claimable / not claimable\n        pub fun setClaimable(seriesId: UInt64, wlClaimable: Bool, publicClaimable: Bool) {\n            DaysOnFlow.getSeries(seriesId: seriesId).setClaimable(wlClaimable: wlClaimable, publicClaimable: publicClaimable)\n        }\n\n        // Delete a series\n        pub fun removeSeries(seriesId: UInt64) {\n            let series <- DaysOnFlow.allSeries.remove(key: seriesId)\n            destroy series\n        }\n\n        init(){}\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create a new series"}, {"role": "assistant", "content": "pub fun createSeries(\n            _wlClaimable: Bool,\n            _publicClaimable: Bool,\n            _description: String, \n            _image: String, \n            _name: String,\n            _dayNFTwl: [UInt64],           \n            _wl: [Address],\n            _wlPrice: UFix64,\n            _publicSupply: UInt64,\n            _publicPrice: UFix64) {\n\n                let series <- create DOFSeries(\n                    _wlClaimable: _wlClaimable,\n                    _publicClaimable: _publicClaimable,\n                    _description: _description, \n                    _image: _image, \n                    _name: _name,\n                    _dayNFTwl: _dayNFTwl,           \n                    _wl: _wl,\n                    _wlPrice: _wlPrice,\n                    _publicSupply: _publicSupply,\n                    _publicPrice: _publicPrice,\n                )\n\n                let seriesId = series.seriesId\n                DaysOnFlow.allSeries[seriesId] <-! series\n            }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Make a series claimable / not claimable"}, {"role": "assistant", "content": "pub fun setClaimable(seriesId: UInt64, wlClaimable: Bool, publicClaimable: Bool) {\n            DaysOnFlow.getSeries(seriesId: seriesId).setClaimable(wlClaimable: wlClaimable, publicClaimable: publicClaimable)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Delete a series"}, {"role": "assistant", "content": "pub fun removeSeries(seriesId: UInt64) {\n            let series <- DaysOnFlow.allSeries.remove(key: seriesId)\n            destroy series\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get a list of all available series"}, {"role": "assistant", "content": "pub fun getAllSeries(): [&DOFSeries] {\n        let answer: [&DOFSeries] = []\n        for id in self.allSeries.keys {\n            let element = (&self.allSeries[id] as &DOFSeries?)!\n            answer.append(element)\n        }\n        return answer\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get a reference to a specific series"}, {"role": "assistant", "content": "pub fun getSeries(seriesId: UInt64): &DOFSeries {\n        return (&self.allSeries[seriesId] as &DOFSeries?)!\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the TuneGO contract is created"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when the TuneGO contract is created"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Item struct is created"}, {"role": "assistant", "content": "pub event ItemCreated(id: UInt32, metadata: {String:String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Item struct is created"}, {"role": "assistant", "content": "(id: UInt32, metadata: {String:String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new series has been started"}, {"role": "assistant", "content": "pub event NewSeriesStarted(newCurrentSeries: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new series has been started"}, {"role": "assistant", "content": "(newCurrentSeries: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Set-Related actions\n\nEmitted when a new Set is created"}, {"role": "assistant", "content": "pub event SetCreated(setId: UInt32, series: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Set-Related actions\n\nEmitted when a new Set is created"}, {"role": "assistant", "content": "(setId: UInt32, series: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Item is added to a Set"}, {"role": "assistant", "content": "pub event ItemAddedToSet(setId: UInt32, itemId: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a new Item is added to a Set"}, {"role": "assistant", "content": "(setId: UInt32, itemId: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an Item is retired from a Set and cannot be used to mint"}, {"role": "assistant", "content": "pub event ItemRetiredFromSet(setId: UInt32, itemId: UInt32, minted: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when an Item is retired from a Set and cannot be used to mint"}, {"role": "assistant", "content": "(setId: UInt32, itemId: UInt32, minted: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Set is locked, meaning collectibles cannot be added"}, {"role": "assistant", "content": "pub event SetLocked(setId: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a Set is locked, meaning collectibles cannot be added"}, {"role": "assistant", "content": "(setId: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a collectible is minted from a Set"}, {"role": "assistant", "content": "pub event CollectibleMinted(id: UInt64, itemId: UInt32, setId: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a collectible is minted from a Set"}, {"role": "assistant", "content": "(id: UInt64, itemId: UInt32, setId: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a collectible is destroyed"}, {"role": "assistant", "content": "pub event CollectibleDestroyed(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a collectible is destroyed"}, {"role": "assistant", "content": "(id: UInt64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a collectible is withdrawn from a Collection"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Events for Collection-related actions\n\nEmitted when a collectible is withdrawn from a Collection"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a collectible is deposited into a Collection"}, {"role": "assistant", "content": "pub event Deposit(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Emitted when a collectible is deposited into a Collection"}, {"role": "assistant", "content": "(id: UInt64, to: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Series that this Set belongs to.\nMany Sets can exist at a time, but only one series."}, {"role": "assistant", "content": "pub var currentSeries: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Variable size dictionary of Item structs"}, {"role": "assistant", "content": "access(self) var itemDatas: {UInt32: Item}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Id that is used to create Items.\nEvery time an Item is created, nextItemId is assigned\nto the new Item's Id and then is incremented by one."}, {"role": "assistant", "content": "pub var nextItemId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Id that is used to create Sets.\nEvery time a Set is created, nextSetId is assigned\nto the new Set's Id and then is incremented by one."}, {"role": "assistant", "content": "pub var nextSetId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The total number of Collectible NFTs that have been created\nBecause NFTs can be destroyed, it doesn't necessarily mean that this\nreflects the total number of NFTs in existence, just the number that\nhave been minted to date."}, {"role": "assistant", "content": "pub var totalSupply: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Item is a Struct that holds metadata associated with a specific collectible item."}, {"role": "assistant", "content": "pub struct Item {\n\n        // The unique Id for the Item\n        pub let itemId: UInt32\n\n        // Stores all the metadata about the item as a string mapping.\n        pub let metadata: {String: String}\n\n        init(metadata: {String: String}) {\n            pre {\n                metadata.length != 0: \"New Item metadata cannot be empty\"\n            }\n            self.itemId = TuneGO.nextItemId\n            self.metadata = metadata\n\n            // Increment the Id so that it isn't used again\n            TuneGO.nextItemId = TuneGO.nextItemId + UInt32(1)\n\n            emit ItemCreated(id: self.itemId, metadata: metadata)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The unique Id for the Item"}, {"role": "assistant", "content": "pub let itemId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Stores all the metadata about the item as a string mapping."}, {"role": "assistant", "content": "pub let metadata: {String: String}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Set is a grouping of Items that make up a related group of collectibles,\nlike sets of baseball cards.\nAn Item can exist in multiple different sets.\n\nSetData is a struct that is stored in a field of the contract.\nAnyone can query the constant information\nabout a set by calling various getters located\nat the end of the contract. Only the admin has the ability\nto modify any data in the private Set resource."}, {"role": "assistant", "content": "pub struct SetData {\n\n        // Unique Id for the Set\n        pub let setId: UInt32\n\n        // Name of the Set\n        pub let name: String\n\n        // Description of the Set\n        pub let description: String?\n\n        // Series that this Set belongs to\n        pub let series: UInt32\n\n        init(name: String, description: String?) {\n            pre {\n                name.length > 0: \"New Set name cannot be empty\"\n            }\n            self.setId = TuneGO.nextSetId\n            self.name = name\n            self.description = description\n            self.series = TuneGO.currentSeries\n\n            // Increment the setId so that it isn't used again\n            TuneGO.nextSetId = TuneGO.nextSetId + UInt32(1)\n\n            emit SetCreated(setId: self.setId, series: self.series)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Unique Id for the Set"}, {"role": "assistant", "content": "pub let setId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Name of the Set"}, {"role": "assistant", "content": "pub let name: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Description of the Set"}, {"role": "assistant", "content": "pub let description: String?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Series that this Set belongs to"}, {"role": "assistant", "content": "pub let series: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Set is a resource type that contains the functions to add and remove\nItems from a set and mint Collectibles.\n\nIt is stored in a private field in the contract so that\nthe admin resource can call its methods.\n\nThe admin can add Items to a Set so that the set can mint Collectibles.\nThe Collectible that is minted by a Set will be listed as belonging to\nthe Set that minted it, as well as the Item it reference.\n\nAdmin can also retire Items from the Set, meaning that the retired\nItem can no longer have Collectibles minted from it.\n\nIf the admin locks the Set, no more Items can be added to it, but\nCollectibles can still be minted.\n\nIf retireAll() and lock() are called back-to-back,\nthe Set is closed off forever and nothing more can be done with it."}, {"role": "assistant", "content": "pub resource Set {\n\n        // Unique Id for the set\n        pub let setId: UInt32\n\n        // Array of items that are a part of this set.\n        // When an item is added to the set, its Id gets appended here.\n        // The Id does not get removed from this array when an Item is retired.\n        pub var items: [UInt32]\n\n        // Map of Item Ids that indicates if an Item in this Set can be minted.\n        // When an Item is added to a Set, it is mapped to false (not retired).\n        // When an Item is retired, this is set to true and cannot be changed.\n        pub var retired: {UInt32: Bool}\n\n        // Indicates if the Set is currently locked.\n        // When a Set is created, it is unlocked and Items are allowed to be added to it.\n        // When a set is locked, Items cannot be added to it.\n        // A Set can't transition from locked to unlocked. Locking is final.\n        // If a Set is locked, Items cannot be added, but Collectibles can still be minted\n        // from Items that exist in the Set.\n        pub var locked: Bool\n\n        // Mapping of Item Ids that indicates the number of Collectibles\n        // that have been minted for specific Items in this Set.\n        // When a Collectible is minted, this value is stored in the Collectible to\n        // show its place in the Set, eg. 42 of 100.\n        pub var numberMintedPerItem: {UInt32: UInt32}\n\n        init(name: String, description: String?) {\n            self.setId = TuneGO.nextSetId\n            self.items = []\n            self.retired = {}\n            self.locked = false\n            self.numberMintedPerItem = {}\n\n            // Create a new SetData for this Set and store it in contract storage\n            TuneGO.setDatas[self.setId] = SetData(name: name, description: description)\n        }\n\n        // Add an Item to the Set\n        //\n        // Pre-Conditions:\n        // The Item exists.\n        // The Set is unlocked.\n        // The Item is not present in the Set.\n        pub fun addItem(itemId: UInt32) {\n            pre {\n                TuneGO.itemDatas[itemId] != nil: \"Cannot add the Item to Set: Item doesn't exist.\"\n                !self.locked: \"Cannot add the Item to the Set after the set has been locked.\"\n                self.numberMintedPerItem[itemId] == nil: \"The Item has already beed added to the set.\"\n            }\n\n            // Add the Item to the array of Items\n            self.items.append(itemId)\n\n            // Allow minting for Item\n            self.retired[itemId] = false\n\n            // Initialize the Collectible count to zero\n            self.numberMintedPerItem[itemId] = 0\n\n            emit ItemAddedToSet(setId: self.setId, itemId: itemId)\n        }\n\n        // Adds multiple Items to the Set\n        pub fun addItems(itemIds: [UInt32]) {\n            for id in itemIds {\n                self.addItem(itemId: id)\n            }\n        }\n\n        // Retire an Item from the Set. The Set can't mint new Collectibles for the Item.\n        // Pre-Conditions:\n        // The Item is part of the Set and not retired.\n        pub fun retireItem(itemId: UInt32) {\n            pre {\n                self.retired[itemId] != nil: \"Cannot retire the Item: Item doesn't exist in this set!\"\n            }\n\n            if !self.retired[itemId]! {\n                self.retired[itemId] = true\n\n                emit ItemRetiredFromSet(setId: self.setId, itemId: itemId, minted: self.numberMintedPerItem[itemId]!)\n            }\n        }\n\n        // Retire all the Items in the Set\n        pub fun retireAll() {\n            for id in self.items {\n                self.retireItem(itemId: id)\n            }\n        }\n\n        // Lock the Set so that no more Items can be added to it.\n        //\n        // Pre-Conditions:\n        // The Set is unlocked\n        pub fun lock() {\n            if !self.locked {\n                self.locked = true\n                emit SetLocked(setId: self.setId)\n            }\n        }\n\n        // Mint a new Collectible and returns the newly minted Collectible.\n        // Pre-Conditions:\n        // The Item must exist in the Set and be allowed to mint new Collectibles\n        pub fun mintCollectible(itemId: UInt32): @NFT {\n            pre {\n                self.retired[itemId] != nil: \"Cannot mint the collectible: This item doesn't exist.\"\n                !self.retired[itemId]!: \"Cannot mint the collectible from this item: This item has been retired.\"\n            }\n\n            // Gets the number of Collectibles that have been minted for this Item\n            // to use as this Collectibles's serial number\n            let minted = self.numberMintedPerItem[itemId]!\n\n            // Mint the new collectible\n            let newCollectible: @NFT <- create NFT(serialNumber: minted + UInt32(1),\n                                              itemId: itemId,\n                                              setId: self.setId)\n\n            // Increment the count of Collectibles minted for this Item\n            self.numberMintedPerItem[itemId] = minted + UInt32(1)\n\n            return <-newCollectible\n        }\n\n        // Mint an arbitrary quantity of Collectibles and return them as a Collection\n        pub fun batchMintCollectible(itemId: UInt32, quantity: UInt64): @Collection {\n            let newCollection <- create Collection()\n\n            var i: UInt64 = 0\n            while i < quantity {\n                newCollection.deposit(token: <-self.mintCollectible(itemId: itemId))\n                i = i + UInt64(1)\n            }\n\n            return <-newCollection\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Unique Id for the set"}, {"role": "assistant", "content": "pub let setId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Array of items that are a part of this set.\nWhen an item is added to the set, its Id gets appended here.\nThe Id does not get removed from this array when an Item is retired."}, {"role": "assistant", "content": "pub var items: [UInt32]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Map of Item Ids that indicates if an Item in this Set can be minted.\nWhen an Item is added to a Set, it is mapped to false (not retired).\nWhen an Item is retired, this is set to true and cannot be changed."}, {"role": "assistant", "content": "pub var retired: {UInt32: Bool}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Indicates if the Set is currently locked.\nWhen a Set is created, it is unlocked and Items are allowed to be added to it.\nWhen a set is locked, Items cannot be added to it.\nA Set can't transition from locked to unlocked. Locking is final.\nIf a Set is locked, Items cannot be added, but Collectibles can still be minted\nfrom Items that exist in the Set."}, {"role": "assistant", "content": "pub var locked: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mapping of Item Ids that indicates the number of Collectibles\nthat have been minted for specific Items in this Set.\nWhen a Collectible is minted, this value is stored in the Collectible to\nshow its place in the Set, eg. 42 of 100."}, {"role": "assistant", "content": "pub var numberMintedPerItem: {UInt32: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Add an Item to the Set\n\nPre-Conditions:\nThe Item exists.\nThe Set is unlocked.\nThe Item is not present in the Set."}, {"role": "assistant", "content": "pub fun addItem(itemId: UInt32) {\n            pre {\n                TuneGO.itemDatas[itemId] != nil: \"Cannot add the Item to Set: Item doesn't exist.\"\n                !self.locked: \"Cannot add the Item to the Set after the set has been locked.\"\n                self.numberMintedPerItem[itemId] == nil: \"The Item has already beed added to the set.\"\n            }\n\n            // Add the Item to the array of Items\n            self.items.append(itemId)\n\n            // Allow minting for Item\n            self.retired[itemId] = false\n\n            // Initialize the Collectible count to zero\n            self.numberMintedPerItem[itemId] = 0\n\n            emit ItemAddedToSet(setId: self.setId, itemId: itemId)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Adds multiple Items to the Set"}, {"role": "assistant", "content": "pub fun addItems(itemIds: [UInt32]) {\n            for id in itemIds {\n                self.addItem(itemId: id)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire an Item from the Set. The Set can't mint new Collectibles for the Item.\nPre-Conditions:\nThe Item is part of the Set and not retired."}, {"role": "assistant", "content": "pub fun retireItem(itemId: UInt32) {\n            pre {\n                self.retired[itemId] != nil: \"Cannot retire the Item: Item doesn't exist in this set!\"\n            }\n\n            if !self.retired[itemId]! {\n                self.retired[itemId] = true\n\n                emit ItemRetiredFromSet(setId: self.setId, itemId: itemId, minted: self.numberMintedPerItem[itemId]!)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire all the Items in the Set"}, {"role": "assistant", "content": "pub fun retireAll() {\n            for id in self.items {\n                self.retireItem(itemId: id)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Lock the Set so that no more Items can be added to it.\n\nPre-Conditions:\nThe Set is unlocked"}, {"role": "assistant", "content": "pub fun lock() {\n            if !self.locked {\n                self.locked = true\n                emit SetLocked(setId: self.setId)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint a new Collectible and returns the newly minted Collectible.\nPre-Conditions:\nThe Item must exist in the Set and be allowed to mint new Collectibles"}, {"role": "assistant", "content": "pub fun mintCollectible(itemId: UInt32): @NFT {\n            pre {\n                self.retired[itemId] != nil: \"Cannot mint the collectible: This item doesn't exist.\"\n                !self.retired[itemId]!: \"Cannot mint the collectible from this item: This item has been retired.\"\n            }\n\n            // Gets the number of Collectibles that have been minted for this Item\n            // to use as this Collectibles's serial number\n            let minted = self.numberMintedPerItem[itemId]!\n\n            // Mint the new collectible\n            let newCollectible: @NFT <- create NFT(serialNumber: minted + UInt32(1),\n                                              itemId: itemId,\n                                              setId: self.setId)\n\n            // Increment the count of Collectibles minted for this Item\n            self.numberMintedPerItem[itemId] = minted + UInt32(1)\n\n            return <-newCollectible\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint an arbitrary quantity of Collectibles and return them as a Collection"}, {"role": "assistant", "content": "pub fun batchMintCollectible(itemId: UInt32, quantity: UInt64): @Collection {\n            let newCollection <- create Collection()\n\n            var i: UInt64 = 0\n            while i < quantity {\n                newCollection.deposit(token: <-self.mintCollectible(itemId: itemId))\n                i = i + UInt64(1)\n            }\n\n            return <-newCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Struct of Collectible metadata"}, {"role": "assistant", "content": "pub struct CollectibleData {\n\n        // The Id of the Set that the Collectible comes from\n        pub let setId: UInt32\n\n        // The Id of the Item that the Collectible references\n        pub let itemId: UInt32\n\n        // The place in the edition that this Collectible was minted\n        pub let serialNumber: UInt32\n\n        init(setId: UInt32, itemId: UInt32, serialNumber: UInt32) {\n            self.setId = setId\n            self.itemId = itemId\n            self.serialNumber = serialNumber\n        }\n\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Id of the Set that the Collectible comes from"}, {"role": "assistant", "content": "pub let setId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Id of the Item that the Collectible references"}, {"role": "assistant", "content": "pub let itemId: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The place in the edition that this Collectible was minted"}, {"role": "assistant", "content": "pub let serialNumber: UInt32"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The resource that represents the Collectible NFT"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT {\n\n        // Global unique Collectible Id\n        pub let id: UInt64\n\n        // Struct of Collectible metadata\n        pub let data: CollectibleData\n\n        init(serialNumber: UInt32, itemId: UInt32, setId: UInt32) {\n\n            // Increment the global Collectible Id\n            TuneGO.totalSupply = TuneGO.totalSupply + UInt64(1)\n\n            self.id = TuneGO.totalSupply\n\n            self.data = CollectibleData(setId: setId, itemId: itemId, serialNumber: serialNumber)\n\n            emit CollectibleMinted(id: self.id, itemId: itemId, setId: setId, serialNumber: self.data.serialNumber)\n        }\n\n        // If the Collectible is destroyed, emit an event\n        destroy() {\n            emit CollectibleDestroyed(id: self.id)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Global unique Collectible Id"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Struct of Collectible metadata"}, {"role": "assistant", "content": "pub let data: CollectibleData"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: If the Collectible is destroyed, emit an event"}, {"role": "assistant", "content": "destroy() {\n            emit CollectibleDestroyed(id: self.id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Admin is an authorization resource that allows the owner to modify\nvarious aspects of the Items, Sets, and Collectibles"}, {"role": "assistant", "content": "pub resource Admin {\n        // Create a new Item struct and store it in the Items dictionary in the contract\n        pub fun createItem(metadata: {String: String}): UInt32 {\n            var newItem = Item(metadata: metadata)\n            let newId = newItem.itemId\n\n            TuneGO.itemDatas[newId] = newItem\n\n            return newId\n        }\n\n        // Create a new Set resource and store it in the sets mapping in the contract\n        pub fun createSet(name: String, description: String?) {\n            var newSet <- create Set(name: name, description: description)\n            TuneGO.sets[newSet.setId] <-! newSet\n        }\n\n        // Return a reference to a set in the contract\n        pub fun borrowSet(setId: UInt32): &Set {\n            pre {\n                TuneGO.sets[setId] != nil: \"Cannot borrow set: The set doesn't exist.\"\n            }\n\n            return (&TuneGO.sets[setId] as &Set?)!\n        }\n\n        // End the current series and start a new one\n        pub fun startNewSeries(): UInt32 {\n            TuneGO.currentSeries = TuneGO.currentSeries + UInt32(1)\n\n            emit NewSeriesStarted(newCurrentSeries: TuneGO.currentSeries)\n\n            return TuneGO.currentSeries\n        }\n\n        // Create a new Admin resource\n        pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create a new Item struct and store it in the Items dictionary in the contract"}, {"role": "assistant", "content": "pub fun createItem(metadata: {String: String}): UInt32 {\n            var newItem = Item(metadata: metadata)\n            let newId = newItem.itemId\n\n            TuneGO.itemDatas[newId] = newItem\n\n            return newId\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create a new Set resource and store it in the sets mapping in the contract"}, {"role": "assistant", "content": "pub fun createSet(name: String, description: String?) {\n            var newSet <- create Set(name: name, description: description)\n            TuneGO.sets[newSet.setId] <-! newSet\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Return a reference to a set in the contract"}, {"role": "assistant", "content": "pub fun borrowSet(setId: UInt32): &Set {\n            pre {\n                TuneGO.sets[setId] != nil: \"Cannot borrow set: The set doesn't exist.\"\n            }\n\n            return (&TuneGO.sets[setId] as &Set?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: End the current series and start a new one"}, {"role": "assistant", "content": "pub fun startNewSeries(): UInt32 {\n            TuneGO.currentSeries = TuneGO.currentSeries + UInt32(1)\n\n            emit NewSeriesStarted(newCurrentSeries: TuneGO.currentSeries)\n\n            return TuneGO.currentSeries\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create a new Admin resource"}, {"role": "assistant", "content": "pub fun createNewAdmin(): @Admin {\n            return <-create Admin()\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Interface that users can cast their TuneGO Collection as\nto allow others to deposit TuneGO Collectibles into their Collection."}, {"role": "assistant", "content": "pub resource interface TuneGOCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowCollectible(id: UInt64): &TuneGO.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow collectible reference: The id of the returned reference is incorrect.\"\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection is a resource that every user who owns NFTs\nwill store in their account to manage their NFTS"}, {"role": "assistant", "content": "pub resource Collection: TuneGOCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {\n        // Dictionary of Collectible conforming tokens\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        init() {\n            self.ownedNFTs <- {}\n        }\n\n        // Remove a Collectible from the Collection and moves it to the caller\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\n            let token <- self.ownedNFTs.remove(key: withdrawID)\n                ?? panic(\"Cannot withdraw: Collectible does not exist in the collection.\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // Withdraw multiple tokens and returns them as a Collection\n        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            var batchCollection <- create Collection()\n\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n\n            return <-batchCollection\n        }\n\n        // Add a Collectible to the Collections dictionary\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n\n            // Cast the deposited token as a Collectible NFT to make sure\n            // it is the correct type\n            let token <- token as! @TuneGO.NFT\n\n            let id = token.id\n\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Emit a deposit event if the Collection is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty removed token\n            destroy oldToken\n        }\n\n        // Deposit multiple NFTs into this Collection\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            let keys = tokens.getIDs()\n\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // Get the Ids that are in the Collection\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // Return a borrowed reference to a Collectible in the Collection\n        // This only allows the caller to read the ID of the NFT,\n        // not any Collectible specific data.\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // Return a borrowed reference to a Collectible\n        // This  allows the caller to read the setId, itemId, serialNumber,\n        // and use them to read the setData or Item data from the contract\n        pub fun borrowCollectible(id: UInt64): &TuneGO.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TuneGO.NFT\n            } else {\n                return nil\n            }\n        }\n\n        // If a transaction destroys the Collection object,\n        // All the NFTs contained within are also destroyed!\n        destroy() {\n            destroy self.ownedNFTs\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Dictionary of Collectible conforming tokens"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Remove a Collectible from the Collection and moves it to the caller"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n\n            let token <- self.ownedNFTs.remove(key: withdrawID)\n                ?? panic(\"Cannot withdraw: Collectible does not exist in the collection.\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Withdraw multiple tokens and returns them as a Collection"}, {"role": "assistant", "content": "pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {\n            var batchCollection <- create Collection()\n\n            for id in ids {\n                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))\n            }\n\n            return <-batchCollection\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Add a Collectible to the Collections dictionary"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n\n            // Cast the deposited token as a Collectible NFT to make sure\n            // it is the correct type\n            let token <- token as! @TuneGO.NFT\n\n            let id = token.id\n\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            // Emit a deposit event if the Collection is in an account's storage\n            if self.owner?.address != nil {\n                emit Deposit(id: id, to: self.owner?.address)\n            }\n\n            // Destroy the empty removed token\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Deposit multiple NFTs into this Collection"}, {"role": "assistant", "content": "pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n\n            let keys = tokens.getIDs()\n\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the Ids that are in the Collection"}, {"role": "assistant", "content": "pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Return a borrowed reference to a Collectible in the Collection\nThis only allows the caller to read the ID of the NFT,\nnot any Collectible specific data."}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Return a borrowed reference to a Collectible\nThis  allows the caller to read the setId, itemId, serialNumber,\nand use them to read the setData or Item data from the contract"}, {"role": "assistant", "content": "pub fun borrowCollectible(id: UInt64): &TuneGO.NFT? {\n            if self.ownedNFTs[id] != nil {\n                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n                return ref as! &TuneGO.NFT\n            } else {\n                return nil\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: If a transaction destroys the Collection object,\nAll the NFTs contained within are also destroyed!"}, {"role": "assistant", "content": "destroy() {\n            destroy self.ownedNFTs\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create a new, empty Collection object so that a user can store it in their account storage\nand be able to receive Collectibles"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <-create TuneGO.Collection()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Return all the Collectible Items"}, {"role": "assistant", "content": "pub fun getAllItems(): [TuneGO.Item] {\n        return TuneGO.itemDatas.values\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get all metadata of an Item"}, {"role": "assistant", "content": "pub fun getItemMetadata(itemId: UInt32): {String: String}? {\n        return self.itemDatas[itemId]?.metadata\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get a metadata field of an Item"}, {"role": "assistant", "content": "pub fun getItemMetadataByField(itemId: UInt32, field: String): String? {\n        if let item = TuneGO.itemDatas[itemId] {\n            return item.metadata[field]\n        } else {\n            return nil\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the name of the Set"}, {"role": "assistant", "content": "pub fun getSetName(setId: UInt32): String? {\n        return TuneGO.setDatas[setId]?.name\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the description of the Set"}, {"role": "assistant", "content": "pub fun getSetDescription(setId: UInt32): String? {\n        return TuneGO.setDatas[setId]?.description\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the series that the specified Set is associated with"}, {"role": "assistant", "content": "pub fun getSetSeries(setId: UInt32): UInt32? {\n        return TuneGO.setDatas[setId]?.series\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the Ids that the specified Set name is associated with"}, {"role": "assistant", "content": "pub fun getSetIdsByName(setName: String): [UInt32]? {\n        var setIds: [UInt32] = []\n\n        for setData in TuneGO.setDatas.values {\n            if setName == setData.name {\n                setIds.append(setData.setId)\n            }\n        }\n\n        if setIds.length == 0 {\n            return nil\n        } else {\n            return setIds\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the list of Item Ids that are in the Set"}, {"role": "assistant", "content": "pub fun getItemsInSet(setId: UInt32): [UInt32]? {\n        return TuneGO.sets[setId]?.items\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Indicates if a Set/Item combo (otherwise known as an edition) is retired"}, {"role": "assistant", "content": "pub fun isEditionRetired(setId: UInt32, itemId: UInt32): Bool? {\n        if let setToRead <- TuneGO.sets.remove(key: setId) {\n            let retired = setToRead.retired[itemId]\n            TuneGO.sets[setId] <-! setToRead\n            return retired\n        } else {\n            return nil\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Indicates if the Set is locked or not"}, {"role": "assistant", "content": "pub fun isSetLocked(setId: UInt32): Bool? {\n        return TuneGO.sets[setId]?.locked\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Total number of Collectibles that have been minted from an edition"}, {"role": "assistant", "content": "pub fun getNumberCollectiblesInEdition(setId: UInt32, itemId: UInt32): UInt32? {\n        if let setToRead <- TuneGO.sets.remove(key: setId) {\n            let amount = setToRead.numberMintedPerItem[itemId]\n\n            // Put the Set back into the Sets dictionary\n            TuneGO.sets[setId] <-! setToRead\n\n            return amount\n        } else {\n            return nil\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: pre-defined lockup schedules\nkey: timestamp\nvalue: percentage of BLT that must remain in the BloctoPass at this timestamp"}, {"role": "assistant", "content": "access(contract) var predefinedLockupSchedules: [{UFix64: UFix64}]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT holder vault"}, {"role": "assistant", "content": "access(self) let vault: @BloctoToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT staker handle"}, {"role": "assistant", "content": "access(self) let staker: @BloctoTokenStaking.Staker"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BloctoPass ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BloctoPass owner address\nIf the pass is transferred to another user, some perks will be disabled"}, {"role": "assistant", "content": "pub let originalOwner: Address?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BloctoPass metadata"}, {"role": "assistant", "content": "access(self) var metadata: {String: String}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BloctoPass usage stamps, including voting records and special events"}, {"role": "assistant", "content": "access(self) var stamps: [String]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Total amount that's subject to lockup schedule"}, {"role": "assistant", "content": "pub let lockupAmount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: ID of predefined lockup schedule\nIf lockupScheduleId == nil, use custom lockup schedule instead"}, {"role": "assistant", "content": "pub let lockupScheduleId: Int?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Defines how much BloctoToken must remain in the BloctoPass on different dates\nkey: timestamp\nvalue: percentage of BLT that must remain in the BloctoPass at this timestamp"}, {"role": "assistant", "content": "access(self) let lockupSchedule: {UFix64: UFix64}?"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Private staking methods"}, {"role": "assistant", "content": "pub fun stakeNewTokens(amount: UFix64) {\n            self.staker.stakeNewTokens(<- self.vault.withdraw(amount: amount))\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: CollectionPublic is a custom interface that allows us to\naccess the public fields and methods for our BloctoPass Collection"}, {"role": "assistant", "content": "pub resource interface CollectionPublic {\n        pub fun borrowBloctoPassPublic(id: UInt64): &BloctoPass.NFT{BloctoPass.BloctoPassPublic, FungibleToken.Receiver, NonFungibleToken.INFT}\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an NFT from the collection and moves it to the caller\nwithdrawal is disabled during lockup period"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a NFT and adds it to the collections dictionary\nand adds the ID to the id array"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @BloctoPass.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: getIDs returns an array of the IDs that are in the collection"}, {"role": "assistant", "content": "pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowNFT gets a reference to an NFT in the collection\nso that the caller can read its metadata and call its methods"}, {"role": "assistant", "content": "pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowBloctoPassPublic gets the public references to a BloctoPass NFT in the collection\nand returns it to the caller as a reference to the NFT"}, {"role": "assistant", "content": "pub fun borrowBloctoPassPublic(id: UInt64): &BloctoPass.NFT{BloctoPass.BloctoPassPublic, FungibleToken.Receiver, NonFungibleToken.INFT} {\n            let bloctoPassRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n            let intermediateRef = bloctoPassRef as! auth &BloctoPass.NFT\n\n            return intermediateRef as &BloctoPass.NFT{BloctoPass.BloctoPassPublic, FungibleToken.Receiver, NonFungibleToken.INFT}\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: borrowBloctoPassPrivate gets the private references to a BloctoPass NFT in the collection\nand returns it to the caller as a reference to the NFT"}, {"role": "assistant", "content": "pub fun borrowBloctoPassPrivate(id: UInt64): &BloctoPass.NFT {\n            let bloctoPassRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!\n\n            return bloctoPassRef as! &BloctoPass.NFT\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: public function that anyone can call to create a new empty collection"}, {"role": "assistant", "content": "pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Resource that an admin or something similar would own to be\nable to mint new NFTs\n"}, {"role": "assistant", "content": "pub resource NFTMinter: MinterPublic {\n\n        // adds a new predefined lockup schedule\n        pub fun setupPredefinedLockupSchedule(lockupSchedule: {UFix64: UFix64}) {\n            BloctoPass.predefinedLockupSchedules.append(lockupSchedule)\n\n            emit LockupScheduleDefined(id: BloctoPass.predefinedLockupSchedules.length, lockupSchedule: lockupSchedule)\n        }\n\n        // updates a predefined lockup schedule\n        // note that this function should be avoided \n        pub fun updatePredefinedLockupSchedule(id: Int, lockupSchedule: {UFix64: UFix64}) {\n            BloctoPass.predefinedLockupSchedules[id] = lockupSchedule\n\n            emit LockupScheduleUpdated(id: id, lockupSchedule: lockupSchedule)\n        }\n\n        // mintBasicNFT mints a new NFT without any special metadata or lockups\n        pub fun mintBasicNFT(recipient: &{NonFungibleToken.CollectionPublic}) {\n            self.mintNFT(recipient: recipient, metadata: {})\n        }\n\n        // mintNFT mints a new NFT with a new ID\n        // and deposit it in the recipients collection using their collection reference\n        pub fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, metadata: {String: String}) {\n            self.mintNFTWithCustomLockup(\n                recipient: recipient,\n                metadata: metadata,\n                vault: <- BloctoToken.createEmptyVault(),\n                lockupSchedule: {0.0: 0.0}\n            )\n        }\n\n        pub fun mintNFTWithPredefinedLockup(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            metadata: {String: String},\n            vault: @FungibleToken.Vault,\n            lockupScheduleId: Int?\n        ) {\n\n            // create a new NFT\n            var newNFT <- create NFT(\n                initID: BloctoPass.totalSupply,\n                originalOwner: recipient.owner?.address,\n                metadata: metadata,\n                vault: <- vault,\n                lockupScheduleId: lockupScheduleId,\n                lockupSchedule: nil\n            )\n\n            // deposit it in the recipient's account using their reference\n            recipient.deposit(token: <-newNFT)\n\n            BloctoPass.totalSupply = BloctoPass.totalSupply + UInt64(1)\n        }\n\n        pub fun mintNFTWithCustomLockup(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            metadata: {String: String},\n            vault: @FungibleToken.Vault,\n            lockupSchedule: {UFix64: UFix64}\n        ) {\n\n            // create a new NFT\n            var newNFT <- create NFT(\n                initID: BloctoPass.totalSupply,\n                originalOwner: recipient.owner?.address,\n                metadata: metadata,\n                vault: <- vault,\n                lockupScheduleId: nil,\n                lockupSchedule: lockupSchedule\n            )\n\n            // deposit it in the recipient's account using their reference\n            recipient.deposit(token: <-newNFT)\n\n            BloctoPass.totalSupply = BloctoPass.totalSupply + UInt64(1)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: adds a new predefined lockup schedule"}, {"role": "assistant", "content": "pub fun setupPredefinedLockupSchedule(lockupSchedule: {UFix64: UFix64}) {\n            BloctoPass.predefinedLockupSchedules.append(lockupSchedule)\n\n            emit LockupScheduleDefined(id: BloctoPass.predefinedLockupSchedules.length, lockupSchedule: lockupSchedule)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: updates a predefined lockup schedule\nnote that this function should be avoided"}, {"role": "assistant", "content": "pub fun updatePredefinedLockupSchedule(id: Int, lockupSchedule: {UFix64: UFix64}) {\n            BloctoPass.predefinedLockupSchedules[id] = lockupSchedule\n\n            emit LockupScheduleUpdated(id: id, lockupSchedule: lockupSchedule)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintBasicNFT mints a new NFT without any special metadata or lockups"}, {"role": "assistant", "content": "pub fun mintBasicNFT(recipient: &{NonFungibleToken.CollectionPublic}) {\n            self.mintNFT(recipient: recipient, metadata: {})\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintNFT mints a new NFT with a new ID\nand deposit it in the recipients collection using their collection reference"}, {"role": "assistant", "content": "pub fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, metadata: {String: String}) {\n            self.mintNFTWithCustomLockup(\n                recipient: recipient,\n                metadata: metadata,\n                vault: <- BloctoToken.createEmptyVault(),\n                lockupSchedule: {0.0: 0.0}\n            )\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BloctoPassStamp ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BloctoPassStamp message"}, {"role": "assistant", "content": "access(self) var message: String"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit takes a NFT and adds it to the collections dictionary\nand adds the ID to the id array"}, {"role": "assistant", "content": "pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @BloctoPassStamp.NFT\n\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Resource that an admin or something similar would own to be\nable to mint new NFTs\n"}, {"role": "assistant", "content": "pub resource NFTMinter {\n\n        // mintNFT mints a new NFT with a new ID\n        // and deposit it in the recipients collection using their collection reference\n        pub fun mintNFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            message: String\n        ) {\n\n            // create a new NFT\n            var newNFT <- create NFT(\n                initID: BloctoPassStamp.totalSupply,\n                message: message\n            )\n\n            // deposit it in the recipient's account using their reference\n            recipient.deposit(token: <-newNFT)\n\n            BloctoPassStamp.totalSupply = BloctoPassStamp.totalSupply + UInt64(1)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintNFT mints a new NFT with a new ID\nand deposit it in the recipients collection using their collection reference"}, {"role": "assistant", "content": "pub fun mintNFT(\n            recipient: &{NonFungibleToken.CollectionPublic},\n            message: String\n        ) {\n\n            // create a new NFT\n            var newNFT <- create NFT(\n                initID: BloctoPassStamp.totalSupply,\n                message: message\n            )\n\n            // deposit it in the recipient's account using their reference\n            recipient.deposit(token: <-newNFT)\n\n            BloctoPassStamp.totalSupply = BloctoPassStamp.totalSupply + UInt64(1)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Token contract of Blocto Token (BLT)"}, {"role": "assistant", "content": "pub contract BloctoToken: FungibleToken {\n\n    // Total supply of Flow tokens in existence\n    pub var totalSupply: UFix64\n\n    // Defines token vault storage path\n    pub let TokenStoragePath: StoragePath\n\n    // Defines token vault public balance path\n    pub let TokenPublicBalancePath: PublicPath\n\n    // Defines token vault public receiver path\n    pub let TokenPublicReceiverPath: PublicPath\n\n    // Defines token minter storage path\n    pub let TokenMinterStoragePath: StoragePath\n\n    // Event that is emitted when the contract is created\n    pub event TokensInitialized(initialSupply: UFix64)\n\n    // Event that is emitted when tokens are withdrawn from a Vault\n    pub event TokensWithdrawn(amount: UFix64, from: Address?)\n\n    // Event that is emitted when tokens are deposited to a Vault\n    pub event TokensDeposited(amount: UFix64, to: Address?)\n\n    // Event that is emitted when new tokens are minted\n    pub event TokensMinted(amount: UFix64)\n\n    // Event that is emitted when tokens are destroyed\n    pub event TokensBurned(amount: UFix64)\n\n    // Event that is emitted when a new minter resource is created\n    pub event MinterCreated(allowedAmount: UFix64)\n\n    // Event that is emitted when a new burner resource is created\n    pub event BurnerCreated()\n\n    // Vault\n    //\n    // Each user stores an instance of only the Vault in their storage\n    // The functions in the Vault and governed by the pre and post conditions\n    // in FungibleToken when they are called.\n    // The checks happen at runtime whenever a function is called.\n    //\n    // Resources can only be created in the context of the contract that they\n    // are defined in, so there is no way for a malicious user to create Vaults\n    // out of thin air. A special Minter resource needs to be defined to mint\n    // new tokens.\n    //\n    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {\n\n        // holds the balance of a users tokens\n        pub var balance: UFix64\n\n        // initialize the balance at resource creation time\n        init(balance: UFix64) {\n            self.balance = balance\n        }\n\n        // withdraw\n        //\n        // Function that takes an integer amount as an argument\n        // and withdraws that amount from the Vault.\n        // It creates a new temporary Vault that is used to hold\n        // the money that is being transferred. It returns the newly\n        // created Vault to the context that called so it can be deposited\n        // elsewhere.\n        //\n        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }\n\n        // deposit\n        //\n        // Function that takes a Vault object as an argument and adds\n        // its balance to the balance of the owners Vault.\n        // It is allowed to destroy the sent Vault because the Vault\n        // was a temporary holder of the tokens. The Vault's balance has\n        // been consumed and therefore can be destroyed.\n        pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @BloctoToken.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }\n\n        destroy() {\n            BloctoToken.totalSupply = BloctoToken.totalSupply - self.balance\n        }\n    }\n\n    // createEmptyVault\n    //\n    // Function that creates a new Vault with a balance of zero\n    // and returns it to the calling context. A user must call this function\n    // and store the returned Vault in their storage in order to allow their\n    // account to be able to receive deposits of this token type.\n    //\n    pub fun createEmptyVault(): @FungibleToken.Vault {\n        return <-create Vault(balance: 0.0)\n    }\n\n    pub resource Administrator {\n        // createNewMinter\n        //\n        // Function that creates and returns a new minter resource\n        //\n        pub fun createNewMinter(allowedAmount: UFix64): @Minter {\n            emit MinterCreated(allowedAmount: allowedAmount)\n            return <-create Minter(allowedAmount: allowedAmount)\n        }\n\n        // createNewBurner\n        //\n        // Function that creates and returns a new burner resource\n        //\n        pub fun createNewBurner(): @Burner {\n            emit BurnerCreated()\n            return <-create Burner()\n        }\n    }\n\n    // Minter\n    //\n    // Resource object that token admin accounts can hold to mint new tokens.\n    //\n    pub resource Minter {\n\n        // the amount of tokens that the minter is allowed to mint\n        pub var allowedAmount: UFix64\n\n        // mintTokens\n        //\n        // Function that mints new tokens, adds them to the total supply,\n        // and returns them to the calling context.\n        //\n        pub fun mintTokens(amount: UFix64): @BloctoToken.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            BloctoToken.totalSupply = BloctoToken.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }\n\n        init(allowedAmount: UFix64) {\n            self.allowedAmount = allowedAmount\n        }\n    }\n\n    // Burner\n    //\n    // Resource object that token admin accounts can hold to burn tokens.\n    //\n    pub resource Burner {\n\n        // burnTokens\n        //\n        // Function that destroys a Vault instance, effectively burning the tokens.\n        //\n        // Note: the burned tokens are automatically subtracted from the\n        // total supply in the Vault destructor.\n        //\n        pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @BloctoToken.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }\n    }\n\n    init() {\n        // Total supply of BLT is 500M\n        // 70% is created at genesis but locked up\n        // 30% will minted from staking and mining\n        self.totalSupply = 350_000_000.0\n\n        self.TokenStoragePath = /storage/bloctoTokenVault\n        self.TokenPublicReceiverPath = /public/bloctoTokenReceiver\n        self.TokenPublicBalancePath = /public/bloctoTokenBalance\n        self.TokenMinterStoragePath = /storage/bloctoTokenMinter\n\n        // Create the Vault with the total supply of tokens and save it in storage\n        let vault <- create Vault(balance: self.totalSupply)\n        self.account.save(<-vault, to: self.TokenStoragePath)\n\n        // Create a public capability to the stored Vault that only exposes\n        // the `deposit` method through the `Receiver` interface\n        self.account.link<&BloctoToken.Vault{FungibleToken.Receiver}>(\n            self.TokenPublicReceiverPath,\n            target: self.TokenStoragePath\n        )\n\n        // Create a public capability to the stored Vault that only exposes\n        // the `balance` field through the `Balance` interface\n        self.account.link<&BloctoToken.Vault{FungibleToken.Balance}>(\n            self.TokenPublicBalancePath,\n            target: self.TokenStoragePath\n        )\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/bloctoTokenAdmin)\n\n        // Emit an event that shows that the contract was initialized\n        emit TokensInitialized(initialSupply: self.totalSupply)\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Total supply of Flow tokens in existence"}, {"role": "assistant", "content": "pub var totalSupply: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Defines token vault storage path"}, {"role": "assistant", "content": "pub let TokenStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Defines token vault public balance path"}, {"role": "assistant", "content": "pub let TokenPublicBalancePath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Defines token vault public receiver path"}, {"role": "assistant", "content": "pub let TokenPublicReceiverPath: PublicPath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Defines token minter storage path"}, {"role": "assistant", "content": "pub let TokenMinterStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Vault\n\nEach user stores an instance of only the Vault in their storage\nThe functions in the Vault and governed by the pre and post conditions\nin FungibleToken when they are called.\nThe checks happen at runtime whenever a function is called.\n\nResources can only be created in the context of the contract that they\nare defined in, so there is no way for a malicious user to create Vaults\nout of thin air. A special Minter resource needs to be defined to mint\nnew tokens.\n"}, {"role": "assistant", "content": "pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {\n\n        // holds the balance of a users tokens\n        pub var balance: UFix64\n\n        // initialize the balance at resource creation time\n        init(balance: UFix64) {\n            self.balance = balance\n        }\n\n        // withdraw\n        //\n        // Function that takes an integer amount as an argument\n        // and withdraws that amount from the Vault.\n        // It creates a new temporary Vault that is used to hold\n        // the money that is being transferred. It returns the newly\n        // created Vault to the context that called so it can be deposited\n        // elsewhere.\n        //\n        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {\n            self.balance = self.balance - amount\n            emit TokensWithdrawn(amount: amount, from: self.owner?.address)\n            return <-create Vault(balance: amount)\n        }\n\n        // deposit\n        //\n        // Function that takes a Vault object as an argument and adds\n        // its balance to the balance of the owners Vault.\n        // It is allowed to destroy the sent Vault because the Vault\n        // was a temporary holder of the tokens. The Vault's balance has\n        // been consumed and therefore can be destroyed.\n        pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @BloctoToken.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }\n\n        destroy() {\n            BloctoToken.totalSupply = BloctoToken.totalSupply - self.balance\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: deposit\n\nFunction that takes a Vault object as an argument and adds\nits balance to the balance of the owners Vault.\nIt is allowed to destroy the sent Vault because the Vault\nwas a temporary holder of the tokens. The Vault's balance has\nbeen consumed and therefore can be destroyed."}, {"role": "assistant", "content": "pub fun deposit(from: @FungibleToken.Vault) {\n            let vault <- from as! @BloctoToken.Vault\n            self.balance = self.balance + vault.balance\n            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)\n            vault.balance = 0.0\n            destroy vault\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Minter\n\nResource object that token admin accounts can hold to mint new tokens.\n"}, {"role": "assistant", "content": "pub resource Minter {\n\n        // the amount of tokens that the minter is allowed to mint\n        pub var allowedAmount: UFix64\n\n        // mintTokens\n        //\n        // Function that mints new tokens, adds them to the total supply,\n        // and returns them to the calling context.\n        //\n        pub fun mintTokens(amount: UFix64): @BloctoToken.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            BloctoToken.totalSupply = BloctoToken.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }\n\n        init(allowedAmount: UFix64) {\n            self.allowedAmount = allowedAmount\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: mintTokens\n\nFunction that mints new tokens, adds them to the total supply,\nand returns them to the calling context.\n"}, {"role": "assistant", "content": "pub fun mintTokens(amount: UFix64): @BloctoToken.Vault {\n            pre {\n                amount > UFix64(0): \"Amount minted must be greater than zero\"\n                amount <= self.allowedAmount: \"Amount minted must be less than the allowed amount\"\n            }\n            BloctoToken.totalSupply = BloctoToken.totalSupply + amount\n            self.allowedAmount = self.allowedAmount - amount\n            emit TokensMinted(amount: amount)\n            return <-create Vault(balance: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Burner\n\nResource object that token admin accounts can hold to burn tokens.\n"}, {"role": "assistant", "content": "pub resource Burner {\n\n        // burnTokens\n        //\n        // Function that destroys a Vault instance, effectively burning the tokens.\n        //\n        // Note: the burned tokens are automatically subtracted from the\n        // total supply in the Vault destructor.\n        //\n        pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @BloctoToken.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: burnTokens\n\nFunction that destroys a Vault instance, effectively burning the tokens.\n\nNote: the burned tokens are automatically subtracted from the\ntotal supply in the Vault destructor.\n"}, {"role": "assistant", "content": "pub fun burnTokens(from: @FungibleToken.Vault) {\n            let vault <- from as! @BloctoToken.Vault\n            let amount = vault.balance\n            destroy vault\n            emit TokensBurned(amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT holder vault"}, {"role": "assistant", "content": "access(contract) let bltVault: @BloctoToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: tUSDT holder vault"}, {"role": "assistant", "content": "access(contract) let tusdtVault: @TeleportedTetherToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Paths for storing sale resources"}, {"role": "assistant", "content": "pub let SaleAdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT token price (tUSDT per BLT)"}, {"role": "assistant", "content": "access(contract) var price: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT lockup schedule, used for lockup terms"}, {"role": "assistant", "content": "access(contract) var lockupScheduleId: Int"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT communitu sale purchase cap (in tUSDT)"}, {"role": "assistant", "content": "access(contract) var personalCap: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: All purchase records"}, {"role": "assistant", "content": "access(contract) var purchases: {Address: PurchaseInfo}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Purchaser address"}, {"role": "assistant", "content": "pub let address: Address"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Purchase amount in tUSDT"}, {"role": "assistant", "content": "pub let amount: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Random ticked ID"}, {"role": "assistant", "content": "pub let ticketId: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: State of the purchase"}, {"role": "assistant", "content": "pub(set) var state: PurchaseState"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: BLT purchase method\nUser pays tUSDT and get a BloctoPass NFT with lockup terms\nNote that \"address\" can potentially be faked, but there's no incentive doing so"}, {"role": "assistant", "content": "pub fun purchase(from: @TeleportedTetherToken.Vault, address: Address) {\n        pre {\n            self.isSaleActive: \"Token sale is not active\"\n            self.purchases[address] == nil: \"Already purchased by the same account\"\n            from.balance <= self.personalCap: \"Purchase amount exceeds personal cap\"\n        }\n\n        let collectionRef = getAccount(address).getCapability(BloctoPass.CollectionPublicPath)\n            .borrow<&{NonFungibleToken.CollectionPublic}>()\n            ?? panic(\"Could not borrow blocto pass collection public reference\")\n\n        // Make sure user does not already have a BloctoPass\n        assert (\n            collectionRef.getIDs().length == 0,\n            message: \"User already has a BloctoPass\"\n        )\n\n        let amount = from.balance\n        self.tusdtVault.deposit(from: <- from)\n\n        let purchaseInfo = PurchaseInfo(address: address, amount: amount)\n        self.purchases[address] = purchaseInfo\n\n        emit Purchased(address: address, amount: amount, ticketId: purchaseInfo.ticketId)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get all purchaser addresses"}, {"role": "assistant", "content": "pub fun getPurchasers(): [Address] {\n        return self.purchases.keys\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get all purchase records"}, {"role": "assistant", "content": "pub fun getPurchases(): {Address: PurchaseInfo} {\n        return self.purchases\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get purchase record from an address"}, {"role": "assistant", "content": "pub fun getPurchase(address: Address): PurchaseInfo? {\n        return self.purchases[address]\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Staker Events"}, {"role": "assistant", "content": "pub event NewStakerCreated(stakerID: UInt64, amountCommitted: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Staker Events"}, {"role": "assistant", "content": "(stakerID: UInt64, amountCommitted: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Contract Field Change Events"}, {"role": "assistant", "content": "pub event NewWeeklyPayout(newPayout: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Contract Field Change Events"}, {"role": "assistant", "content": "(newPayout: UFix64)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Holds the identity table for all the stakers in the network.\n/ Includes stakers that aren't actively participating\n/ key = staker ID (also corresponds to BloctoPass ID)\n/ value = the record of that staker's info, tokens, and delegators"}, {"role": "assistant", "content": "access(contract) var stakers: @{UInt64: StakerRecord}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / The total amount of tokens that are staked for all the stakers"}, {"role": "assistant", "content": "access(contract) var totalTokensStaked: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / The total amount of tokens that are paid as rewards every epoch\n/ could be manually changed by the admin resource"}, {"role": "assistant", "content": "access(contract) var epochTokenPayout: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Indicates if the staking auction is currently enabled"}, {"role": "assistant", "content": "access(contract) var stakingEnabled: Bool"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Paths for storing staking resources"}, {"role": "assistant", "content": "pub let StakingAdminStoragePath: StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Contains information that is specific to a staker"}, {"role": "assistant", "content": "pub resource StakerRecord {\n\n        /// The unique ID of the staker\n        /// Corresponds to the BloctoPass NFT ID\n        pub let id: UInt64\n\n        /// The total tokens that only this staker currently has staked\n        pub var tokensStaked: @BloctoToken.Vault\n\n        /// The tokens that this staker has committed to stake for the next epoch.\n        pub var tokensCommitted: @BloctoToken.Vault\n\n        /// Tokens that this staker is able to withdraw whenever they want\n        pub var tokensUnstaked: @BloctoToken.Vault\n\n        /// Staking rewards are paid to this bucket\n        /// Can be withdrawn whenever\n        pub var tokensRewarded: @BloctoToken.Vault\n\n        /// The amount of tokens that this staker has requested to unstake for the next epoch\n        pub(set) var tokensRequestedToUnstake: UFix64\n\n        init(id: UInt64) {\n            pre {\n                BloctoTokenStaking.stakers[id] == nil: \"The ID cannot already exist in the record\"\n            }\n\n            self.id = id\n\n            self.tokensCommitted <- BloctoToken.createEmptyVault() as! @BloctoToken.Vault\n            self.tokensStaked <- BloctoToken.createEmptyVault() as! @BloctoToken.Vault\n            self.tokensUnstaked <- BloctoToken.createEmptyVault() as! @BloctoToken.Vault\n            self.tokensRewarded <- BloctoToken.createEmptyVault() as! @BloctoToken.Vault\n            self.tokensRequestedToUnstake = 0.0\n\n            emit NewStakerCreated(stakerID: self.id, amountCommitted: self.tokensCommitted.balance)\n        }\n\n        destroy() {\n            let bloctoTokenRef = BloctoTokenStaking.account.borrow<&BloctoToken.Vault>(from: BloctoToken.TokenStoragePath)!\n            BloctoTokenStaking.totalTokensStaked = BloctoTokenStaking.totalTokensStaked - self.tokensStaked.balance\n            bloctoTokenRef.deposit(from: <-self.tokensStaked)\n            bloctoTokenRef.deposit(from: <-self.tokensCommitted)\n            bloctoTokenRef.deposit(from: <-self.tokensUnstaked)\n            bloctoTokenRef.deposit(from: <-self.tokensRewarded)\n        }\n\n        /// Utility Function that checks a staker's overall committed balance from its borrowed record\n        access(contract) fun stakerFullCommittedBalance(): UFix64 {\n            if (self.tokensCommitted.balance + self.tokensStaked.balance) < self.tokensRequestedToUnstake {\n                return 0.0\n            } else {\n                return self.tokensCommitted.balance + self.tokensStaked.balance - self.tokensRequestedToUnstake\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / The unique ID of the staker\n/ Corresponds to the BloctoPass NFT ID"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / The total tokens that only this staker currently has staked"}, {"role": "assistant", "content": "pub var tokensStaked: @BloctoToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / The tokens that this staker has committed to stake for the next epoch."}, {"role": "assistant", "content": "pub var tokensCommitted: @BloctoToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Tokens that this staker is able to withdraw whenever they want"}, {"role": "assistant", "content": "pub var tokensUnstaked: @BloctoToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Staking rewards are paid to this bucket\n/ Can be withdrawn whenever"}, {"role": "assistant", "content": "pub var tokensRewarded: @BloctoToken.Vault"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / The amount of tokens that this staker has requested to unstake for the next epoch"}, {"role": "assistant", "content": "pub(set) var tokensRequestedToUnstake: UFix64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Utility Function that checks a staker's overall committed balance from its borrowed record"}, {"role": "assistant", "content": "access(contract) fun stakerFullCommittedBalance(): UFix64 {\n            if (self.tokensCommitted.balance + self.tokensStaked.balance) < self.tokensRequestedToUnstake {\n                return 0.0\n            } else {\n                return self.tokensCommitted.balance + self.tokensStaked.balance - self.tokensRequestedToUnstake\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Struct to create to get read-only info about a staker"}, {"role": "assistant", "content": "pub struct StakerInfo {\n        pub let id: UInt64\n        pub let tokensStaked: UFix64\n        pub let tokensCommitted: UFix64\n        pub let tokensUnstaked: UFix64\n        pub let tokensRewarded: UFix64\n        pub let tokensRequestedToUnstake: UFix64\n\n        init(stakerID: UInt64) {\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n\n            self.id = stakerRecord.id\n            self.tokensStaked = stakerRecord.tokensStaked.balance\n            self.tokensCommitted = stakerRecord.tokensCommitted.balance\n            self.tokensUnstaked = stakerRecord.tokensUnstaked.balance\n            self.tokensRewarded = stakerRecord.tokensRewarded.balance\n            self.tokensRequestedToUnstake = stakerRecord.tokensRequestedToUnstake\n        }\n\n        pub fun totalTokensInRecord(): UFix64 {\n            return self.tokensStaked + self.tokensCommitted + self.tokensUnstaked + self.tokensRewarded\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Resource that the staker operator controls for staking"}, {"role": "assistant", "content": "pub resource Staker: StakerPublic {\n\n        /// Unique ID for the staker operator\n        pub let id: UInt64\n\n        init(id: UInt64) {\n            self.id = id\n        }\n\n        /// Add new tokens to the system to stake during the next epoch\n        pub fun stakeNewTokens(_ tokens: @FungibleToken.Vault) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot stake if the staking auction isn't in progress\"\n            }\n\n            // Borrow the staker's record from the staking contract\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            emit TokensCommitted(stakerID: stakerRecord.id, amount: tokens.balance)\n\n            // Add the new tokens to tokens committed\n            stakerRecord.tokensCommitted.deposit(from: <-tokens)\n        }\n\n        /// Stake tokens that are in the tokensUnstaked bucket\n        pub fun stakeUnstakedTokens(amount: UFix64) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot stake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            var remainingAmount = amount\n\n            // If there are any tokens that have been requested to unstake for the current epoch,\n            // cancel those first before staking new unstaked tokens\n            if remainingAmount <= stakerRecord.tokensRequestedToUnstake {\n                stakerRecord.tokensRequestedToUnstake = stakerRecord.tokensRequestedToUnstake - remainingAmount\n                remainingAmount = 0.0\n            } else if remainingAmount > stakerRecord.tokensRequestedToUnstake {\n                remainingAmount = remainingAmount - stakerRecord.tokensRequestedToUnstake\n                stakerRecord.tokensRequestedToUnstake = 0.0\n            }\n\n            // Commit the remaining amount from the tokens unstaked bucket\n            stakerRecord.tokensCommitted.deposit(from: <-stakerRecord.tokensUnstaked.withdraw(amount: remainingAmount))\n\n            emit TokensCommitted(stakerID: stakerRecord.id, amount: remainingAmount)\n        }\n\n        /// Stake tokens that are in the tokensRewarded bucket\n        pub fun stakeRewardedTokens(amount: UFix64) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot stake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            stakerRecord.tokensCommitted.deposit(from: <-stakerRecord.tokensRewarded.withdraw(amount: amount))\n\n            emit TokensCommitted(stakerID: stakerRecord.id, amount: amount)\n        }\n\n        /// Request amount tokens to be removed from staking at the end of the next epoch\n        pub fun requestUnstaking(amount: UFix64) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot unstake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            // If the request is greater than the total number of tokens\n            // that can be unstaked, revert\n            assert (\n                stakerRecord.tokensStaked.balance +\n                stakerRecord.tokensCommitted.balance\n                >= amount + stakerRecord.tokensRequestedToUnstake,\n                message: \"Not enough tokens to unstake!\"\n            )\n\n            // Get the balance of the tokens that are currently committed\n            let amountCommitted = stakerRecord.tokensCommitted.balance\n\n            // If the request can come from committed, withdraw from committed to unstaked\n            if amountCommitted >= amount {\n\n                // withdraw the requested tokens from committed since they have not been staked yet\n                stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: amount))\n\n            } else {\n                let amountCommitted = stakerRecord.tokensCommitted.balance\n\n                // withdraw the requested tokens from committed since they have not been staked yet\n                stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: amountCommitted))\n\n                // update request to show that leftover amount is requested to be unstaked\n                stakerRecord.tokensRequestedToUnstake = stakerRecord.tokensRequestedToUnstake + (amount - amountCommitted)\n            }\n        }\n\n        /// Requests to unstake all of the staker operators staked and committed tokens\n        /// as well as all the staked and committed tokens of all of their delegators\n        pub fun unstakeAll() {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot unstake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            /// if the request can come from committed, withdraw from committed to unstaked\n            /// withdraw the requested tokens from committed since they have not been staked yet\n            stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: stakerRecord.tokensCommitted.balance))\n\n            /// update request to show that leftover amount is requested to be unstaked\n            stakerRecord.tokensRequestedToUnstake = stakerRecord.tokensStaked.balance\n        }\n\n        /// Withdraw tokens from the unstaked bucket\n        pub fun withdrawUnstakedTokens(amount: UFix64): @FungibleToken.Vault {\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            emit UnstakedTokensWithdrawn(stakerID: stakerRecord.id, amount: amount)\n\n            return <- stakerRecord.tokensUnstaked.withdraw(amount: amount)\n        }\n\n        /// Withdraw tokens from the rewarded bucket\n        pub fun withdrawRewardedTokens(amount: UFix64): @FungibleToken.Vault {\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            emit RewardTokensWithdrawn(stakerID: stakerRecord.id, amount: amount)\n\n            return <- stakerRecord.tokensRewarded.withdraw(amount: amount)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Unique ID for the staker operator"}, {"role": "assistant", "content": "pub let id: UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Add new tokens to the system to stake during the next epoch"}, {"role": "assistant", "content": "pub fun stakeNewTokens(_ tokens: @FungibleToken.Vault) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot stake if the staking auction isn't in progress\"\n            }\n\n            // Borrow the staker's record from the staking contract\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            emit TokensCommitted(stakerID: stakerRecord.id, amount: tokens.balance)\n\n            // Add the new tokens to tokens committed\n            stakerRecord.tokensCommitted.deposit(from: <-tokens)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Stake tokens that are in the tokensUnstaked bucket"}, {"role": "assistant", "content": "pub fun stakeUnstakedTokens(amount: UFix64) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot stake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            var remainingAmount = amount\n\n            // If there are any tokens that have been requested to unstake for the current epoch,\n            // cancel those first before staking new unstaked tokens\n            if remainingAmount <= stakerRecord.tokensRequestedToUnstake {\n                stakerRecord.tokensRequestedToUnstake = stakerRecord.tokensRequestedToUnstake - remainingAmount\n                remainingAmount = 0.0\n            } else if remainingAmount > stakerRecord.tokensRequestedToUnstake {\n                remainingAmount = remainingAmount - stakerRecord.tokensRequestedToUnstake\n                stakerRecord.tokensRequestedToUnstake = 0.0\n            }\n\n            // Commit the remaining amount from the tokens unstaked bucket\n            stakerRecord.tokensCommitted.deposit(from: <-stakerRecord.tokensUnstaked.withdraw(amount: remainingAmount))\n\n            emit TokensCommitted(stakerID: stakerRecord.id, amount: remainingAmount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Stake tokens that are in the tokensRewarded bucket"}, {"role": "assistant", "content": "pub fun stakeRewardedTokens(amount: UFix64) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot stake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            stakerRecord.tokensCommitted.deposit(from: <-stakerRecord.tokensRewarded.withdraw(amount: amount))\n\n            emit TokensCommitted(stakerID: stakerRecord.id, amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Request amount tokens to be removed from staking at the end of the next epoch"}, {"role": "assistant", "content": "pub fun requestUnstaking(amount: UFix64) {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot unstake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            // If the request is greater than the total number of tokens\n            // that can be unstaked, revert\n            assert (\n                stakerRecord.tokensStaked.balance +\n                stakerRecord.tokensCommitted.balance\n                >= amount + stakerRecord.tokensRequestedToUnstake,\n                message: \"Not enough tokens to unstake!\"\n            )\n\n            // Get the balance of the tokens that are currently committed\n            let amountCommitted = stakerRecord.tokensCommitted.balance\n\n            // If the request can come from committed, withdraw from committed to unstaked\n            if amountCommitted >= amount {\n\n                // withdraw the requested tokens from committed since they have not been staked yet\n                stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: amount))\n\n            } else {\n                let amountCommitted = stakerRecord.tokensCommitted.balance\n\n                // withdraw the requested tokens from committed since they have not been staked yet\n                stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: amountCommitted))\n\n                // update request to show that leftover amount is requested to be unstaked\n                stakerRecord.tokensRequestedToUnstake = stakerRecord.tokensRequestedToUnstake + (amount - amountCommitted)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Requests to unstake all of the staker operators staked and committed tokens\n/ as well as all the staked and committed tokens of all of their delegators"}, {"role": "assistant", "content": "pub fun unstakeAll() {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot unstake if the staking auction isn't in progress\"\n            }\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            /// if the request can come from committed, withdraw from committed to unstaked\n            /// withdraw the requested tokens from committed since they have not been staked yet\n            stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: stakerRecord.tokensCommitted.balance))\n\n            /// update request to show that leftover amount is requested to be unstaked\n            stakerRecord.tokensRequestedToUnstake = stakerRecord.tokensStaked.balance\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Withdraw tokens from the unstaked bucket"}, {"role": "assistant", "content": "pub fun withdrawUnstakedTokens(amount: UFix64): @FungibleToken.Vault {\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            emit UnstakedTokensWithdrawn(stakerID: stakerRecord.id, amount: amount)\n\n            return <- stakerRecord.tokensUnstaked.withdraw(amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Withdraw tokens from the rewarded bucket"}, {"role": "assistant", "content": "pub fun withdrawRewardedTokens(amount: UFix64): @FungibleToken.Vault {\n\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(self.id)\n\n            emit RewardTokensWithdrawn(stakerID: stakerRecord.id, amount: amount)\n\n            return <- stakerRecord.tokensRewarded.withdraw(amount: amount)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Admin resource that has the ability to create new staker objects and pay rewards\n/ to stakers at the end of an epoch"}, {"role": "assistant", "content": "pub resource Admin {\n\n        /// A staker record is created when a BloctoPass NFT is created\n        /// It returns the resource for stakers that they can store in their account storage\n        pub fun addStakerRecord(id: UInt64): @Staker {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot register a staker operator if the staking auction isn't in progress\"\n            }\n\n            let newStakerRecord <- create StakerRecord(id: id)\n\n            // Insert the staker to the table\n            BloctoTokenStaking.stakers[id] <-! newStakerRecord\n\n            // return a new Staker object that the staker operator stores in their account\n            return <-create Staker(id: id)\n        }\n\n        /// Starts the staking auction, the period when stakers and delegators\n        /// are allowed to perform staking related operations\n        pub fun startNewEpoch() {\n            BloctoTokenStaking.stakingEnabled = true\n            BloctoTokenStaking.setEpoch(BloctoTokenStaking.getEpoch() + (1 as UInt64))\n            emit NewEpoch(epoch: BloctoTokenStaking.getEpoch(), totalStaked: BloctoTokenStaking.getTotalStaked(), totalRewardPayout: BloctoTokenStaking.epochTokenPayout)\n        }\n\n        /// Starts the staking auction, the period when stakers and delegators\n        /// are allowed to perform staking related operations\n        pub fun startStakingAuction() {\n            BloctoTokenStaking.stakingEnabled = true\n        }\n\n        /// Ends the staking Auction by removing any unapproved stakers\n        /// and setting stakingEnabled to false\n        pub fun endStakingAuction() {\n            BloctoTokenStaking.stakingEnabled = false\n        }\n\n        /// Called at the end of the epoch to pay rewards to staker operators\n        /// based on the tokens that they have staked\n        pub fun payRewards(_ stakerIDs: [UInt64]) {\n            pre {\n                !BloctoTokenStaking.stakingEnabled: \"Cannot pay rewards if the staking auction is still in progress\"\n            }\n\n            let BloctoTokenMinter = BloctoTokenStaking.account.borrow<&BloctoToken.Minter>(from: /storage/bloctoTokenStakingMinter)\n                ?? panic(\"Could not borrow minter reference\")\n\n            // calculate the total number of tokens staked\n            var totalStaked = BloctoTokenStaking.getTotalStaked()\n\n            if totalStaked == 0.0 {\n                return\n            }\n            var totalRewardScale = BloctoTokenStaking.epochTokenPayout / totalStaked\n\n            let epoch = BloctoTokenStaking.getEpoch()\n            let epochPath = BloctoTokenStaking.getStakingRewardPath(epoch: epoch)\n            var stakingRewardRecordsRefOpt = BloctoTokenStaking.account.borrow<&{String: Bool}>(from: epochPath)\n            if stakingRewardRecordsRefOpt == nil {\n                BloctoTokenStaking.account.save<{String: Bool}>({} as {String: Bool}, to: epochPath)\n                stakingRewardRecordsRefOpt = BloctoTokenStaking.account.borrow<&{String: Bool}>(from: epochPath)\n            }\n            var stakingRewardRecordsRef = stakingRewardRecordsRefOpt!\n\n            /// iterate through stakers to pay\n            for stakerID in stakerIDs {\n                // add reward record\n                let key = BloctoTokenStaking.getStakingRewardKey(epoch: epoch, stakerID: stakerID)\n                if stakingRewardRecordsRef[key] != nil && stakingRewardRecordsRef[key]! {\n                    continue\n                }\n                stakingRewardRecordsRef[key] = true\n\n                let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n\n                if stakerRecord.tokensStaked.balance == 0.0 { continue }\n\n                let rewardAmount = stakerRecord.tokensStaked.balance * totalRewardScale\n\n                if rewardAmount == 0.0 { continue }\n\n                /// Mint the tokens to reward the operator\n                let tokenReward <- BloctoTokenMinter.mintTokens(amount: rewardAmount)\n\n                if tokenReward.balance > 0.0 {\n                    emit RewardsPaid(stakerID: stakerRecord.id, amount: tokenReward.balance)\n\n                    /// Deposit the staker Rewards into their tokensRewarded bucket\n                    stakerRecord.tokensRewarded.deposit(from: <-tokenReward)\n                } else {\n                    destroy tokenReward\n                }\n            }\n        }\n\n        /// Called at the end of the epoch to move tokens between buckets\n        /// for stakers\n        /// Tokens that have been committed are moved to the staked bucket\n        /// Tokens that were unstaking during the last epoch are fully unstaked\n        /// Unstaking requests are filled by moving those tokens from staked to unstaking\n        pub fun moveTokens(_ stakerIDs: [UInt64]) {\n            pre {\n                !BloctoTokenStaking.stakingEnabled: \"Cannot move tokens if the staking auction is still in progress\"\n            }\n\n            for stakerID in stakerIDs {\n                // get staker record\n                let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n\n                // Update total number of tokens staked by all the stakers of each type\n                BloctoTokenStaking.totalTokensStaked = BloctoTokenStaking.totalTokensStaked + stakerRecord.tokensCommitted.balance\n\n                // mark the committed tokens as staked\n                if stakerRecord.tokensCommitted.balance > 0.0 {\n                    emit TokensStaked(stakerID: stakerRecord.id, amount: stakerRecord.tokensCommitted.balance)\n                    stakerRecord.tokensStaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: stakerRecord.tokensCommitted.balance))\n                }\n\n                // unstake the requested tokens and move them to tokensUnstaking\n                if stakerRecord.tokensRequestedToUnstake > 0.0 {\n                    emit TokensUnstaked(stakerID: stakerRecord.id, amount: stakerRecord.tokensRequestedToUnstake)\n                    stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensStaked.withdraw(amount: stakerRecord.tokensRequestedToUnstake))\n\n                    // subtract their requested tokens from the total staked for their staker type\n                    BloctoTokenStaking.totalTokensStaked = BloctoTokenStaking.totalTokensStaked - stakerRecord.tokensRequestedToUnstake\n\n                    // Reset the tokens requested field so it can be used for the next epoch\n                    stakerRecord.tokensRequestedToUnstake = 0.0\n                }\n\n                emit MoveToken(stakerID: stakerID)\n            }\n        }\n\n        /// Changes the total weekly payout to a new value\n        pub fun setEpochTokenPayout(_ newPayout: UFix64) {\n            BloctoTokenStaking.epochTokenPayout = newPayout\n\n            emit NewWeeklyPayout(newPayout: newPayout)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / A staker record is created when a BloctoPass NFT is created\n/ It returns the resource for stakers that they can store in their account storage"}, {"role": "assistant", "content": "pub fun addStakerRecord(id: UInt64): @Staker {\n            pre {\n                BloctoTokenStaking.stakingEnabled: \"Cannot register a staker operator if the staking auction isn't in progress\"\n            }\n\n            let newStakerRecord <- create StakerRecord(id: id)\n\n            // Insert the staker to the table\n            BloctoTokenStaking.stakers[id] <-! newStakerRecord\n\n            // return a new Staker object that the staker operator stores in their account\n            return <-create Staker(id: id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Starts the staking auction, the period when stakers and delegators\n/ are allowed to perform staking related operations"}, {"role": "assistant", "content": "pub fun startNewEpoch() {\n            BloctoTokenStaking.stakingEnabled = true\n            BloctoTokenStaking.setEpoch(BloctoTokenStaking.getEpoch() + (1 as UInt64))\n            emit NewEpoch(epoch: BloctoTokenStaking.getEpoch(), totalStaked: BloctoTokenStaking.getTotalStaked(), totalRewardPayout: BloctoTokenStaking.epochTokenPayout)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Starts the staking auction, the period when stakers and delegators\n/ are allowed to perform staking related operations"}, {"role": "assistant", "content": "pub fun startStakingAuction() {\n            BloctoTokenStaking.stakingEnabled = true\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Ends the staking Auction by removing any unapproved stakers\n/ and setting stakingEnabled to false"}, {"role": "assistant", "content": "pub fun endStakingAuction() {\n            BloctoTokenStaking.stakingEnabled = false\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Called at the end of the epoch to pay rewards to staker operators\n/ based on the tokens that they have staked"}, {"role": "assistant", "content": "pub fun payRewards(_ stakerIDs: [UInt64]) {\n            pre {\n                !BloctoTokenStaking.stakingEnabled: \"Cannot pay rewards if the staking auction is still in progress\"\n            }\n\n            let BloctoTokenMinter = BloctoTokenStaking.account.borrow<&BloctoToken.Minter>(from: /storage/bloctoTokenStakingMinter)\n                ?? panic(\"Could not borrow minter reference\")\n\n            // calculate the total number of tokens staked\n            var totalStaked = BloctoTokenStaking.getTotalStaked()\n\n            if totalStaked == 0.0 {\n                return\n            }\n            var totalRewardScale = BloctoTokenStaking.epochTokenPayout / totalStaked\n\n            let epoch = BloctoTokenStaking.getEpoch()\n            let epochPath = BloctoTokenStaking.getStakingRewardPath(epoch: epoch)\n            var stakingRewardRecordsRefOpt = BloctoTokenStaking.account.borrow<&{String: Bool}>(from: epochPath)\n            if stakingRewardRecordsRefOpt == nil {\n                BloctoTokenStaking.account.save<{String: Bool}>({} as {String: Bool}, to: epochPath)\n                stakingRewardRecordsRefOpt = BloctoTokenStaking.account.borrow<&{String: Bool}>(from: epochPath)\n            }\n            var stakingRewardRecordsRef = stakingRewardRecordsRefOpt!\n\n            /// iterate through stakers to pay\n            for stakerID in stakerIDs {\n                // add reward record\n                let key = BloctoTokenStaking.getStakingRewardKey(epoch: epoch, stakerID: stakerID)\n                if stakingRewardRecordsRef[key] != nil && stakingRewardRecordsRef[key]! {\n                    continue\n                }\n                stakingRewardRecordsRef[key] = true\n\n                let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n\n                if stakerRecord.tokensStaked.balance == 0.0 { continue }\n\n                let rewardAmount = stakerRecord.tokensStaked.balance * totalRewardScale\n\n                if rewardAmount == 0.0 { continue }\n\n                /// Mint the tokens to reward the operator\n                let tokenReward <- BloctoTokenMinter.mintTokens(amount: rewardAmount)\n\n                if tokenReward.balance > 0.0 {\n                    emit RewardsPaid(stakerID: stakerRecord.id, amount: tokenReward.balance)\n\n                    /// Deposit the staker Rewards into their tokensRewarded bucket\n                    stakerRecord.tokensRewarded.deposit(from: <-tokenReward)\n                } else {\n                    destroy tokenReward\n                }\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Called at the end of the epoch to move tokens between buckets\n/ for stakers\n/ Tokens that have been committed are moved to the staked bucket\n/ Tokens that were unstaking during the last epoch are fully unstaked\n/ Unstaking requests are filled by moving those tokens from staked to unstaking"}, {"role": "assistant", "content": "pub fun moveTokens(_ stakerIDs: [UInt64]) {\n            pre {\n                !BloctoTokenStaking.stakingEnabled: \"Cannot move tokens if the staking auction is still in progress\"\n            }\n\n            for stakerID in stakerIDs {\n                // get staker record\n                let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n\n                // Update total number of tokens staked by all the stakers of each type\n                BloctoTokenStaking.totalTokensStaked = BloctoTokenStaking.totalTokensStaked + stakerRecord.tokensCommitted.balance\n\n                // mark the committed tokens as staked\n                if stakerRecord.tokensCommitted.balance > 0.0 {\n                    emit TokensStaked(stakerID: stakerRecord.id, amount: stakerRecord.tokensCommitted.balance)\n                    stakerRecord.tokensStaked.deposit(from: <-stakerRecord.tokensCommitted.withdraw(amount: stakerRecord.tokensCommitted.balance))\n                }\n\n                // unstake the requested tokens and move them to tokensUnstaking\n                if stakerRecord.tokensRequestedToUnstake > 0.0 {\n                    emit TokensUnstaked(stakerID: stakerRecord.id, amount: stakerRecord.tokensRequestedToUnstake)\n                    stakerRecord.tokensUnstaked.deposit(from: <-stakerRecord.tokensStaked.withdraw(amount: stakerRecord.tokensRequestedToUnstake))\n\n                    // subtract their requested tokens from the total staked for their staker type\n                    BloctoTokenStaking.totalTokensStaked = BloctoTokenStaking.totalTokensStaked - stakerRecord.tokensRequestedToUnstake\n\n                    // Reset the tokens requested field so it can be used for the next epoch\n                    stakerRecord.tokensRequestedToUnstake = 0.0\n                }\n\n                emit MoveToken(stakerID: stakerID)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Changes the total weekly payout to a new value"}, {"role": "assistant", "content": "pub fun setEpochTokenPayout(_ newPayout: UFix64) {\n            BloctoTokenStaking.epochTokenPayout = newPayout\n\n            emit NewWeeklyPayout(newPayout: newPayout)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / borrow a reference to to one of the stakers in the record"}, {"role": "assistant", "content": "access(account) fun borrowStakerRecord(_ stakerID: UInt64): &StakerRecord {\n        pre {\n            BloctoTokenStaking.stakers[stakerID] != nil:\n                \"Specified staker ID does not exist in the record\"\n        }\n        return( &BloctoTokenStaking.stakers[stakerID] as! &StakerRecord?)!\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets an array of all the stakerIDs that are staked.\n/ Only stakers that are participating in the current epoch\n/ can be staked, so this is an array of all the active stakers"}, {"role": "assistant", "content": "pub fun getStakedStakerIDs(): [UInt64] {\n        var stakers: [UInt64] = []\n\n        for stakerID in BloctoTokenStaking.getStakerIDs() {\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n\n            if stakerRecord.tokensStaked.balance > 0.0\n            {\n                stakers.append(stakerID)\n            }\n        }\n\n        return stakers\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets an slice of stakerIDs who's staking balance > 0"}, {"role": "assistant", "content": "pub fun getStakedStakerIDsSlice(start: UInt64, end: UInt64): [UInt64] {\n        // all staker ids\n        var allStakerIDs: [UInt64] = BloctoTokenStaking.getStakerIDs()\n\n        // output\n        var stakers: [UInt64] = []\n\n        // filter staker ids by staking balance\n        var current = start\n        while current < end {\n            let stakerID = allStakerIDs[current]\n            let stakerRecord = BloctoTokenStaking.borrowStakerRecord(stakerID)\n            if stakerRecord.tokensStaked.balance > 0.0 {\n                stakers.append(stakerID)\n            }\n            current = current + 1\n        }\n        return stakers\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets an array of all the staker IDs that have ever registered"}, {"role": "assistant", "content": "pub fun getStakerIDs(): [UInt64] {\n        return BloctoTokenStaking.stakers.keys\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets an slice of stakerIDs who's staking balance > 0"}, {"role": "assistant", "content": "pub fun getStakerIDsSlice(start: UInt64, end: UInt64): [UInt64] {\n        // all staker ids\n        var allStakerIDs: [UInt64] = BloctoTokenStaking.getStakerIDs()\n\n        // output\n        var stakers: [UInt64] = []\n\n        // filter staker ids by staking balance\n        var current = start\n        while current < end {\n            stakers.append(allStakerIDs[current])\n            current = current + 1\n        }\n        return stakers\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets staker id count"}, {"role": "assistant", "content": "pub fun getStakerIDCount(): Int {\n        return BloctoTokenStaking.stakers.keys.length\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets the token payout value for the current epoch"}, {"role": "assistant", "content": "pub fun getEpochTokenPayout(): UFix64 {\n        return self.epochTokenPayout\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Gets the total number of BLT that is currently staked\n/ by all of the staked stakers in the current epoch"}, {"role": "assistant", "content": "pub fun getTotalStaked(): UFix64 {\n        return BloctoTokenStaking.totalTokensStaked\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / Epoch"}, {"role": "assistant", "content": "pub fun getEpoch(): UInt64 {\n        return self.account.copy<UInt64>(from: /storage/bloctoTokenStakingEpoch) ?? (0 as UInt64)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: / staking reward records"}, {"role": "assistant", "content": "pub fun hasSentStakingReward(epoch: UInt64, stakerID: UInt64): Bool {\n        let stakingRewardRecordsRef = self.account.borrow<&{String: Bool}>(from: BloctoTokenStaking.getStakingRewardPath(epoch: epoch))\n        if stakingRewardRecordsRef == nil {\n            return false\n        }\n\n        let key = BloctoTokenStaking.getStakingRewardKey(epoch: epoch, stakerID: stakerID)\n        if stakingRewardRecordsRef![key] == nil {\n            return false\n        }\n\n        return stakingRewardRecordsRef![key]!\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: The Genies NFTs and metadata contract\n"}, {"role": "assistant", "content": "pub contract Genies: NonFungibleToken {\n    //------------------------------------------------------------\n    // Events\n    //------------------------------------------------------------\n\n    // Contract Events\n    //\n    pub event ContractInitialized()\n\n    // NFT Collection (not Genies Collection!) Events\n    //\n    pub event Withdraw(id: UInt64, from: Address?)\n    pub event Deposit(id: UInt64, to: Address?)\n\n    // Series Events\n    //\n    // Emitted when a new series has been triggered by an admin\n    pub event NewSeriesStarted(newCurrentSeries: UInt32, name: String, metadata: {String: String})\n    pub event SeriesDeactivated(id: UInt32)\n\n    // Collection Events\n    //\n    pub event CollectionCreated(id: UInt32, seriesID: UInt32, name: String, metadata: {String: String})\n    pub event CollectionClosed(id: UInt32)\n\n    // Edition Events\n    //\n    pub event EditionCreated(id: UInt32, collectionID: UInt32, name: String, metadata: {String: String})\n    pub event EditionRetired(id: UInt32)\n\n    // NFT Events\n    //\n    pub event NFTMinted(id: UInt64, editionID: UInt32, serialNumber: UInt32)\n    pub event NFTBurned(id: UInt64)\n\n    //------------------------------------------------------------\n    // Named values\n    //------------------------------------------------------------\n\n    // Named Paths\n    //\n    pub let CollectionStoragePath:  StoragePath\n    pub let CollectionPublicPath:   PublicPath\n    pub let AdminStoragePath:       StoragePath\n    pub let MinterPrivatePath:      PrivatePath\n\n    //------------------------------------------------------------\n    // Publcly readable contract state\n    //------------------------------------------------------------\n\n    // Entity Counts\n    //\n    pub var totalSupply:        UInt64\n    pub var currentSeriesID:    UInt32\n    pub var nextCollectionID:   UInt32\n    pub var nextEditionID:    UInt32\n\n    //------------------------------------------------------------\n    // Internal contract state\n    //------------------------------------------------------------\n\n    // Metadata Dictionaries\n    //\n    // This is so we can find Series by their names (via seriesByID)\n    access(self) let seriesIDByName:    {String: UInt32}\n    // This avoids storing Series in an array where the index is off by one\n    access(self) let seriesByID:        @{UInt32: Series}\n    access(self) let collectionByID:    @{UInt32: GeniesCollection}\n    access(self) let editionByID:     @{UInt32: Edition}\n\n    //------------------------------------------------------------\n    // Series\n    //------------------------------------------------------------\n\n    // A public struct to access Series data\n    //\n    pub struct SeriesData {\n        pub let id: UInt32\n        pub let name: String\n        pub let metadata: {String: String}\n        pub let active: Bool\n        pub let collectionIDs: [UInt32]\n        pub let collectionsOpen: UInt32\n\n        // initializer\n        //\n        init (id: UInt32) {    \n            let series = (&Genies.seriesByID[id] as &Genies.Series?)!\n            self.id = series.id\n            self.name = series.name\n            self.metadata = series.metadata\n            self.active = series.active\n            self.collectionIDs = series.collectionIDs\n            self.collectionsOpen = series.collectionsOpen\n        }\n    }\n\n    // A top-level Series with a unique ID and name\n    //\n    pub resource Series {\n        pub let id: UInt32\n        pub let name: String\n        // Contents writable if borrowed!\n        // This is deliberate, as it allows admins to update the data.\n        pub let metadata: {String: String}\n        // We manage this list, but need to access it to fill out the struct,\n        // so it is access(contract)\n        access(contract) let collectionIDs: [UInt32]\n        pub var collectionsOpen: UInt32\n        pub var active: Bool\n\n        // Deactivate this series\n        //\n        pub fun deactivate() {\n            pre {\n                self.active == true: \"not active\"\n                self.collectionsOpen == 0: \"must closeAllCollections before deactivating\"\n            }\n\n            self.active = false\n\n            emit SeriesDeactivated(id: self.id)\n        }\n\n        // Create and add a collection to the series.\n        // You can only do so via this function, which updates the relevant fields.\n        //\n        pub fun addCollection(\n            collectionName: String,\n            collectionMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                self.active == true: \"Cannot add collection to previous series\"\n            }\n\n            let collection <- create Genies.GeniesCollection(\n                seriesID: self.id,\n                name: collectionName,\n                metadata: collectionMetadata\n            )\n            let collectionID = collection.id\n            Genies.collectionByID[collectionID] <-! collection\n            self.collectionIDs.append(collectionID)\n            self.collectionsOpen = self.collectionsOpen + 1 as UInt32\n\n            return collectionID\n        }\n\n        // Close a collection, and update the relevant fields\n        //\n        pub fun closeGeniesCollection(collectionID: UInt32) {\n            pre {\n                Genies.collectionByID[collectionID] != nil: \"no such collectionID\"\n            }\n\n            let collection = (&Genies.collectionByID[collectionID] as &Genies.GeniesCollection?)!\n            collection.close()\n            self.collectionsOpen = self.collectionsOpen - 1 as UInt32\n        }\n\n        // Recursively ensure that all of the collections are closed,\n        // and all the editions in each are retired,\n        // allowing advanceSeries to proceed\n        //\n        pub fun closeAllGeniesCollections() {\n            for collectionID in self.collectionIDs {\n                let collection = (&Genies.collectionByID[collectionID] as &Genies.GeniesCollection?)!\n                if collection.open {\n                    collection.retireAllEditions()\n                    self.closeGeniesCollection(collectionID: collectionID)\n                }\n            }\n        }\n\n        // initializer\n        // We pass in ID as the logic for it is more complex than it should be,\n        // and we don't want to spread it out.\n        //\n        init (id: UInt32, name: String, metadata: {String: String}) {\n            pre {\n                !Genies.seriesIDByName.containsKey(name): \"A Series with that name already exists\"\n            }\n\n            self.id = id\n            self.name = name\n            self.metadata = metadata\n            self.collectionIDs = []\n            self.collectionsOpen = 0 as UInt32\n            self.active = true\n\n            emit NewSeriesStarted(\n                newCurrentSeries: self.id,\n                name: self.name,\n                metadata: self.metadata\n            )\n        }\n    }\n\n    // Get the publicly available data for a Series by id\n    //\n    pub fun getSeriesData(id: UInt32): Genies.SeriesData {\n        pre {\n            Genies.seriesByID[id] != nil: \"Cannot borrow series, no such id\"\n        }\n\n        return Genies.SeriesData(id: id)\n    }\n\n    // Get the publicly available data for a Series by name\n    //\n    pub fun getSeriesDataByName(name: String): Genies.SeriesData {\n        pre {\n            Genies.seriesIDByName[name] != nil: \"Cannot borrow series, no such name\"\n        }\n\n        let id = Genies.seriesIDByName[name]!\n\n        return Genies.SeriesData(id: id)\n    }\n\n    // Get all series names (this will be *long*)\n    //\n    pub fun getAllSeriesNames(): [String] {\n        return Genies.seriesIDByName.keys\n    }\n\n    // Get series id for name\n    //\n    pub fun getSeriesIDByName(name: String): UInt32? {\n        return Genies.seriesIDByName[name]\n    }\n\n    //------------------------------------------------------------\n    // GeniesCollection\n    //------------------------------------------------------------\n\n    // A public struct to access GeniesCollection data\n    //\n    pub struct GeniesCollectionData {\n        pub let id: UInt32\n        pub let seriesID: UInt32\n        pub let name: String\n        pub let metadata: {String: String}\n        pub let open: Bool\n        pub let editionIDs: [UInt32]\n        pub let editionsActive: UInt32\n\n        // initializer\n        //\n        init (id: UInt32) {\n            let collection = (&Genies.collectionByID[id] as &Genies.GeniesCollection?)!\n            self.id = id\n            self.seriesID = collection.seriesID\n            self.name = collection.name\n            self.metadata = collection.metadata\n            self.open = collection.open\n            self.editionIDs = collection.editionIDs\n            self.editionsActive = collection.editionsActive\n        }\n    }\n\n    // A Genies collection (not to be confused with a NonFungibleToken.Collection) within a series\n    //\n    pub resource GeniesCollection {\n        pub let id: UInt32\n        pub let seriesID: UInt32\n        pub let name: String\n        // Contents writable if borrowed!\n        // This is deliberate, as it allows admins to update the data.\n        pub let metadata: {String: String}\n        pub var open: Bool\n        // We manage this list, but need to access it to fill out the struct,\n        // so it is access(contract)\n        access(contract) let editionIDs: [UInt32]\n        pub var editionsActive: UInt32\n\n        // Create and add an Edition to the series.\n        // You can only do so via this function, which updates the relevant fields.\n        //\n        pub fun addEdition(\n            editionName: String,\n            editionMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                self.open == true: \"Cannot add edition to closed collection\"\n            }\n            let edition <- create Genies.Edition(\n                collectionID: self.id,\n                name: editionName,\n                metadata: editionMetadata\n            )\n\n            let editionID = edition.id\n            Genies.editionByID[editionID] <-! edition\n            self.editionIDs.append(editionID)\n            self.editionsActive = self.editionsActive + 1 as UInt32\n\n            return editionID\n        }\n\n        // Close an Edition, and update the relevant fields\n        //\n        pub fun retireEdition(editionID: UInt32) {\n            pre {\n                Genies.editionByID[editionID] != nil: \"editionID doesn't exist\"\n            }\n\n            let edition = (&Genies.editionByID[editionID] as &Edition?)!\n            edition.retire()\n            self.editionsActive = self.editionsActive - 1 as UInt32\n        }\n\n        // Retire all of the Editions, allowing this collection to be closed\n        //\n        pub fun retireAllEditions() {\n            for editionID in self.editionIDs {\n                self.retireEdition(editionID: editionID)\n            }\n        }\n\n        // Close the collection\n        // access(contract) to enforce calling through its parent series\n        //\n        access(contract) fun close() {\n            pre{\n                self.editionsActive == 0:\n                    \"All editions in this collection must be closed before closing it\"\n            }\n\n            self.open = false\n\n            emit CollectionClosed(id: self.id)\n        }\n\n        // initializer\n        //\n        init (seriesID: UInt32, name: String, metadata: {String: String}) {\n            pre {\n                Genies.seriesByID.containsKey(seriesID) != nil: \"seriesID does not exist\"\n            }\n\n            self.id = Genies.nextCollectionID\n            self.seriesID = seriesID\n            self.name = name\n            self.metadata = metadata\n            self.editionIDs = []\n            self.editionsActive = 0 as UInt32\n            self.open = true\n\n            Genies.nextCollectionID = Genies.nextCollectionID + 1 as UInt32\n\n            emit CollectionCreated(id: self.id, seriesID: self.seriesID, name: self.name, metadata: self.metadata)\n        }\n    }\n\n    // Get the publicly available data for a GeniesCollection\n    // Not an NFT Collection!\n    //\n    pub fun getGeniesCollectionData(id: UInt32): Genies.GeniesCollectionData {\n        pre {\n            Genies.collectionByID[id] != nil: \"Cannot borrow Genies collection, no such id\"\n        }\n\n        return GeniesCollectionData(id: id)\n    }\n\n    //------------------------------------------------------------\n    // Edition\n    //------------------------------------------------------------\n\n    // A public struct to access Edition data\n    //\n    pub struct EditionData {\n        pub let id: UInt32\n        pub let collectionID: UInt32\n        pub let name: String\n        pub let metadata: {String: String}\n        pub let open: Bool\n        pub let numMinted: UInt32\n\n        // initializer\n        //\n        init (id: UInt32) {\n            let edition = (&Genies.editionByID[id] as &Genies.Edition?)!\n            self.id = id\n            self.collectionID = edition.collectionID\n            self.name = edition.name\n            self.metadata = edition.metadata\n            self.open = edition.open\n            self.numMinted = edition.numMinted\n        }\n    }\n\n    // An Edition (NFT type) within a Genies collection\n    //\n    pub resource Edition {\n        pub let id: UInt32\n        pub let collectionID: UInt32\n        pub let name: String\n        // Contents writable if borrowed!\n        // This is deliberate, as it allows admins to update the data.\n        pub let metadata: {String: String}\n        pub var numMinted: UInt32\n        pub var open: Bool\n\n        // Retire this edition so that no more Genies NFTs can be minted in it\n        // access(contract) to enforce calling through its parent GeniesCollection\n        //\n        access(contract) fun retire() {\n            pre {\n                self.open == true: \"already retired\"\n            }\n\n            self.open = false\n\n            emit EditionRetired(id: self.id)\n        }\n\n        // Mint a Genies NFT in this edition, with the given minting mintingDate.\n        // Note that this will panic if this edition is retired.\n        //\n        pub fun mint(): @Genies.NFT {\n            pre {\n                self.open: \"edition closed, cannot mint\"\n            }\n\n            // Keep a running total (you'll notice we used this as the serial number\n            // and pre-increment it so that serial numbers start at 1 ).\n            self.numMinted = self.numMinted + 1 as UInt32\n\n            // Create the Genies NFT, filled out with our information\n            let geniesNFT <- create NFT(\n                id: Genies.totalSupply,\n                editionID: self.id,\n                serialNumber: self.numMinted\n            )\n            Genies.totalSupply = Genies.totalSupply + 1\n\n            return <- geniesNFT\n        }\n\n        // initializer\n        //\n        init (\n            collectionID: UInt32,\n            name: String,\n            metadata: {String: String}\n        ) {\n            pre {\n                Genies.collectionByID.containsKey(collectionID): \"collectionID does not exist\"\n            }\n\n            self.id = Genies.nextEditionID\n            self.collectionID = collectionID\n            self.name = name\n            self.metadata = metadata\n            self.numMinted = 0 as UInt32\n            self.open = true\n\n            Genies.nextEditionID = Genies.nextEditionID + 1 as UInt32\n\n            emit EditionCreated(\n                id: self.id,\n                collectionID: self.collectionID,\n                name: self.name,\n                metadata: self.metadata\n            )\n        }\n    }\n\n    // Get the publicly available data for an Edition\n    //\n    pub fun getEditionData(id: UInt32): EditionData {\n        pre {\n            Genies.editionByID[id] != nil: \"Cannot borrow edition, no such id\"\n        }\n\n        let edition = (&Genies.editionByID[id] as &Genies.Edition?)!\n\n        return EditionData(id: id)\n    }\n\n    //------------------------------------------------------------\n    // NFT\n    //------------------------------------------------------------\n\n    // A Genies NFT\n    //\n    pub resource NFT: NonFungibleToken.INFT {\n        pub let id: UInt64\n        pub let editionID: UInt32\n        pub let serialNumber: UInt32\n        pub let mintingDate: UFix64\n\n        // Destructor\n        //\n        destroy() {\n            emit NFTBurned(id: self.id)\n        }\n\n        // NFT initializer\n        //\n        init(\n            id: UInt64,\n            editionID: UInt32,\n            serialNumber: UInt32\n        ) {\n            pre {\n                Genies.editionByID[editionID] != nil: \"no such editionID\"\n                (&Genies.editionByID[editionID] as &Edition?)!.open:\n                    \"editionID is retired\"\n            }\n\n            self.id = id\n            self.editionID = editionID\n            self.serialNumber = serialNumber\n            self.mintingDate = getCurrentBlock().timestamp\n\n            emit NFTMinted(id: self.id, editionID: self.editionID, serialNumber: self.serialNumber)\n        }\n    }\n\n    //------------------------------------------------------------\n    // Collection\n    //------------------------------------------------------------\n\n    // A public collection interface that allows Genies NFTs to be borrowed\n    //\n    pub resource interface GeniesNFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowGeniesNFT(id: UInt64): &Genies.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow Genies NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }\n\n    // An NFT Collection (not to be confused with a GeniesCollection)\n    //\n    pub resource Collection:\n        NonFungibleToken.Provider,\n        NonFungibleToken.Receiver,\n        NonFungibleToken.CollectionPublic,\n        GeniesNFTCollectionPublic\n    {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an UInt64 ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // deposit takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @Genies.NFT\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        //\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT gets a reference to an NFT in the collection\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // borrowGeniesNFT gets a reference to an NFT in the collection\n        //\n        pub fun borrowGeniesNFT(id: UInt64): &Genies.NFT? {\n            return (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)! as! &Genies.NFT\n        }\n\n        // Collection destructor\n        //\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // Collection initializer\n        //\n        init() {\n            self.ownedNFTs <- {}\n        }\n    }\n\n    // public function that anyone can call to create a new empty collection\n    //\n    pub fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n\n    //------------------------------------------------------------\n    // Admin\n    //------------------------------------------------------------\n\n    // An interface containing the Admin function that allows minting NFTs\n    //\n    pub resource interface NFTMinter {\n        // Mint a single NFT\n        // The Edition for the given ID must already exist\n        //\n        pub fun mintNFT(editionID: UInt32): @Genies.NFT\n    }\n\n    // A resource that allows managing metadata and minting NFTs\n    //\n    pub resource Admin: NFTMinter {\n        // Create a new series and set it to be the current one, deactivating the previous one if needed.\n        // You probably want to call closeAllCollections() on the current series before this.\n        //\n        pub fun advanceSeries(\n            nextSeriesName: String,\n            nextSeriesMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                Genies.seriesByID[Genies.currentSeriesID] == nil\n                    || (&Genies.seriesByID[Genies.currentSeriesID] as &Genies.Series?)!.collectionsOpen == 0:\n                    \"All collections must be closed before advancing the series\"\n            }\n\n            // The contract starts with currentSeriesID 0 but no entry for series zero.\n            // We have to call advanceSeries to create series 0, so we have to handle that special case.\n            // This test handles that case.\n            // Its body will be called every time after the initial advance, which is what we want.\n            if Genies.seriesByID[Genies.currentSeriesID] != nil {\n                let currentSeries = (&Genies.seriesByID[Genies.currentSeriesID] as &Genies.Series?)!\n                if currentSeries.active {\n                    // Make sure everything in the series is closed\n                    currentSeries.closeAllGeniesCollections()\n                    // Deactivate the current series\n                    currentSeries.deactivate()\n                    // Advance the currentSeriesID\n                    Genies.currentSeriesID = Genies.currentSeriesID + 1 as UInt32\n                }\n            }\n\n            // Create and store the new series\n            let series <- create Genies.Series(\n                id: Genies.currentSeriesID,\n                name: nextSeriesName,\n                metadata: nextSeriesMetadata\n            )\n            Genies.seriesByID[Genies.currentSeriesID] <-! series\n\n            // Cache the new series's name => ID\n            Genies.seriesIDByName[nextSeriesName] = Genies.currentSeriesID\n\n            // Return the new ID for convenience\n            return Genies.currentSeriesID\n        }\n\n        // Borrow a Series\n        //\n        pub fun borrowSeries(id: UInt32): &Genies.Series {\n            pre {\n                Genies.seriesByID[id] != nil: \"Cannot borrow series, no such id\"\n            }\n\n            return (&Genies.seriesByID[id] as &Genies.Series?)!\n        }\n\n        // Borrow a Genies Collection. Not an NFT Collection!\n        //\n        pub fun borrowGeniesCollection(id: UInt32): &Genies.GeniesCollection {\n            pre {\n                Genies.collectionByID[id] != nil: \"Cannot borrow Genies collection, no such id\"\n            }\n\n            return (&Genies.collectionByID[id] as &Genies.GeniesCollection?)!\n        }\n\n        // Borrow an Edition\n        //\n        pub fun borrowEdition(id: UInt32): &Genies.Edition {\n            pre {\n                Genies.editionByID[id] != nil: \"Cannot borrow edition, no such id\"\n            }\n\n            return (&Genies.editionByID[id] as &Genies.Edition?)!\n        }\n\n        // Mint a single NFT\n        // The Edition for the given ID must already exist\n        //\n        pub fun mintNFT(editionID: UInt32): @Genies.NFT {\n            pre {\n                // Make sure the edition we are creating this NFT in exists\n                Genies.editionByID.containsKey(editionID): \"No such EditionID\"\n            }\n\n            return <- self.borrowEdition(id: editionID).mint()\n        }\n    }\n\n    //------------------------------------------------------------\n    // Contract lifecycle\n    //------------------------------------------------------------\n\n    // Genies contract initializer\n    //\n    init() {\n        // Set the named paths\n        self.CollectionStoragePath = /storage/GeniesNFTCollection\n        self.CollectionPublicPath = /public/GeniesNFTCollection\n        self.AdminStoragePath = /storage/GeniesAdmin\n        self.MinterPrivatePath = /private/GeniesMinter\n\n        // Initialize the entity counts\n        self.totalSupply = 0\n        self.currentSeriesID = 0\n        self.nextCollectionID = 0\n        self.nextEditionID = 0\n\n        // Initialize the metadata lookup dictionaries\n        self.seriesByID <- {}\n        self.seriesIDByName = {}\n        self.collectionByID <- {}\n        self.editionByID <- {}\n\n        // Create an Admin resource and save it to storage\n        let admin <- create Admin()\n        self.account.save(<-admin, to: self.AdminStoragePath)\n        // Link capabilites to the admin constrained to the Minter\n        // and Metadata interfaces\n        self.account.link<&Genies.Admin{Genies.NFTMinter}>(\n            self.MinterPrivatePath,\n            target: self.AdminStoragePath\n        )\n\n        // Let the world know we are here\n        emit ContractInitialized()\n    }\n}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Contract Events\n"}, {"role": "assistant", "content": "pub event ContractInitialized()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Contract Events\n"}, {"role": "assistant", "content": "()"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: NFT Collection (not Genies Collection!) Events\n"}, {"role": "assistant", "content": "pub event Withdraw(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: NFT Collection (not Genies Collection!) Events\n"}, {"role": "assistant", "content": "(id: UInt64, from: Address?)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Series Events\n\nEmitted when a new series has been triggered by an admin"}, {"role": "assistant", "content": "pub event NewSeriesStarted(newCurrentSeries: UInt32, name: String, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Series Events\n\nEmitted when a new series has been triggered by an admin"}, {"role": "assistant", "content": "(newCurrentSeries: UInt32, name: String, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection Events\n"}, {"role": "assistant", "content": "pub event CollectionCreated(id: UInt32, seriesID: UInt32, name: String, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Collection Events\n"}, {"role": "assistant", "content": "(id: UInt32, seriesID: UInt32, name: String, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Edition Events\n"}, {"role": "assistant", "content": "pub event EditionCreated(id: UInt32, collectionID: UInt32, name: String, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Edition Events\n"}, {"role": "assistant", "content": "(id: UInt32, collectionID: UInt32, name: String, metadata: {String: String})"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: NFT Events\n"}, {"role": "assistant", "content": "pub event NFTMinted(id: UInt64, editionID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: NFT Events\n"}, {"role": "assistant", "content": "(id: UInt64, editionID: UInt32, serialNumber: UInt32)"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Named Paths\n"}, {"role": "assistant", "content": "pub let CollectionStoragePath:  StoragePath"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Entity Counts\n"}, {"role": "assistant", "content": "pub var totalSupply:        UInt64"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Metadata Dictionaries\n\nThis is so we can find Series by their names (via seriesByID)"}, {"role": "assistant", "content": "access(self) let seriesIDByName:    {String: UInt32}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: This avoids storing Series in an array where the index is off by one"}, {"role": "assistant", "content": "access(self) let seriesByID:        @{UInt32: Series}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A public struct to access Series data\n"}, {"role": "assistant", "content": "pub struct SeriesData {\n        pub let id: UInt32\n        pub let name: String\n        pub let metadata: {String: String}\n        pub let active: Bool\n        pub let collectionIDs: [UInt32]\n        pub let collectionsOpen: UInt32\n\n        // initializer\n        //\n        init (id: UInt32) {    \n            let series = (&Genies.seriesByID[id] as &Genies.Series?)!\n            self.id = series.id\n            self.name = series.name\n            self.metadata = series.metadata\n            self.active = series.active\n            self.collectionIDs = series.collectionIDs\n            self.collectionsOpen = series.collectionsOpen\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (id: UInt32) {    \n            let series = (&Genies.seriesByID[id] as &Genies.Series?)!\n            self.id = series.id\n            self.name = series.name\n            self.metadata = series.metadata\n            self.active = series.active\n            self.collectionIDs = series.collectionIDs\n            self.collectionsOpen = series.collectionsOpen\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A top-level Series with a unique ID and name\n"}, {"role": "assistant", "content": "pub resource Series {\n        pub let id: UInt32\n        pub let name: String\n        // Contents writable if borrowed!\n        // This is deliberate, as it allows admins to update the data.\n        pub let metadata: {String: String}\n        // We manage this list, but need to access it to fill out the struct,\n        // so it is access(contract)\n        access(contract) let collectionIDs: [UInt32]\n        pub var collectionsOpen: UInt32\n        pub var active: Bool\n\n        // Deactivate this series\n        //\n        pub fun deactivate() {\n            pre {\n                self.active == true: \"not active\"\n                self.collectionsOpen == 0: \"must closeAllCollections before deactivating\"\n            }\n\n            self.active = false\n\n            emit SeriesDeactivated(id: self.id)\n        }\n\n        // Create and add a collection to the series.\n        // You can only do so via this function, which updates the relevant fields.\n        //\n        pub fun addCollection(\n            collectionName: String,\n            collectionMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                self.active == true: \"Cannot add collection to previous series\"\n            }\n\n            let collection <- create Genies.GeniesCollection(\n                seriesID: self.id,\n                name: collectionName,\n                metadata: collectionMetadata\n            )\n            let collectionID = collection.id\n            Genies.collectionByID[collectionID] <-! collection\n            self.collectionIDs.append(collectionID)\n            self.collectionsOpen = self.collectionsOpen + 1 as UInt32\n\n            return collectionID\n        }\n\n        // Close a collection, and update the relevant fields\n        //\n        pub fun closeGeniesCollection(collectionID: UInt32) {\n            pre {\n                Genies.collectionByID[collectionID] != nil: \"no such collectionID\"\n            }\n\n            let collection = (&Genies.collectionByID[collectionID] as &Genies.GeniesCollection?)!\n            collection.close()\n            self.collectionsOpen = self.collectionsOpen - 1 as UInt32\n        }\n\n        // Recursively ensure that all of the collections are closed,\n        // and all the editions in each are retired,\n        // allowing advanceSeries to proceed\n        //\n        pub fun closeAllGeniesCollections() {\n            for collectionID in self.collectionIDs {\n                let collection = (&Genies.collectionByID[collectionID] as &Genies.GeniesCollection?)!\n                if collection.open {\n                    collection.retireAllEditions()\n                    self.closeGeniesCollection(collectionID: collectionID)\n                }\n            }\n        }\n\n        // initializer\n        // We pass in ID as the logic for it is more complex than it should be,\n        // and we don't want to spread it out.\n        //\n        init (id: UInt32, name: String, metadata: {String: String}) {\n            pre {\n                !Genies.seriesIDByName.containsKey(name): \"A Series with that name already exists\"\n            }\n\n            self.id = id\n            self.name = name\n            self.metadata = metadata\n            self.collectionIDs = []\n            self.collectionsOpen = 0 as UInt32\n            self.active = true\n\n            emit NewSeriesStarted(\n                newCurrentSeries: self.id,\n                name: self.name,\n                metadata: self.metadata\n            )\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Contents writable if borrowed!\nThis is deliberate, as it allows admins to update the data."}, {"role": "assistant", "content": "pub let metadata: {String: String}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: We manage this list, but need to access it to fill out the struct,\nso it is access(contract)"}, {"role": "assistant", "content": "access(contract) let collectionIDs: [UInt32]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Deactivate this series\n"}, {"role": "assistant", "content": "pub fun deactivate() {\n            pre {\n                self.active == true: \"not active\"\n                self.collectionsOpen == 0: \"must closeAllCollections before deactivating\"\n            }\n\n            self.active = false\n\n            emit SeriesDeactivated(id: self.id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create and add a collection to the series.\nYou can only do so via this function, which updates the relevant fields.\n"}, {"role": "assistant", "content": "pub fun addCollection(\n            collectionName: String,\n            collectionMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                self.active == true: \"Cannot add collection to previous series\"\n            }\n\n            let collection <- create Genies.GeniesCollection(\n                seriesID: self.id,\n                name: collectionName,\n                metadata: collectionMetadata\n            )\n            let collectionID = collection.id\n            Genies.collectionByID[collectionID] <-! collection\n            self.collectionIDs.append(collectionID)\n            self.collectionsOpen = self.collectionsOpen + 1 as UInt32\n\n            return collectionID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Close a collection, and update the relevant fields\n"}, {"role": "assistant", "content": "pub fun closeGeniesCollection(collectionID: UInt32) {\n            pre {\n                Genies.collectionByID[collectionID] != nil: \"no such collectionID\"\n            }\n\n            let collection = (&Genies.collectionByID[collectionID] as &Genies.GeniesCollection?)!\n            collection.close()\n            self.collectionsOpen = self.collectionsOpen - 1 as UInt32\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Recursively ensure that all of the collections are closed,\nand all the editions in each are retired,\nallowing advanceSeries to proceed\n"}, {"role": "assistant", "content": "pub fun closeAllGeniesCollections() {\n            for collectionID in self.collectionIDs {\n                let collection = (&Genies.collectionByID[collectionID] as &Genies.GeniesCollection?)!\n                if collection.open {\n                    collection.retireAllEditions()\n                    self.closeGeniesCollection(collectionID: collectionID)\n                }\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\nWe pass in ID as the logic for it is more complex than it should be,\nand we don't want to spread it out.\n"}, {"role": "assistant", "content": "init (id: UInt32, name: String, metadata: {String: String}) {\n            pre {\n                !Genies.seriesIDByName.containsKey(name): \"A Series with that name already exists\"\n            }\n\n            self.id = id\n            self.name = name\n            self.metadata = metadata\n            self.collectionIDs = []\n            self.collectionsOpen = 0 as UInt32\n            self.active = true\n\n            emit NewSeriesStarted(\n                newCurrentSeries: self.id,\n                name: self.name,\n                metadata: self.metadata\n            )\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the publicly available data for a Series by id\n"}, {"role": "assistant", "content": "pub fun getSeriesData(id: UInt32): Genies.SeriesData {\n        pre {\n            Genies.seriesByID[id] != nil: \"Cannot borrow series, no such id\"\n        }\n\n        return Genies.SeriesData(id: id)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the publicly available data for a Series by name\n"}, {"role": "assistant", "content": "pub fun getSeriesDataByName(name: String): Genies.SeriesData {\n        pre {\n            Genies.seriesIDByName[name] != nil: \"Cannot borrow series, no such name\"\n        }\n\n        let id = Genies.seriesIDByName[name]!\n\n        return Genies.SeriesData(id: id)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get all series names (this will be *long*)\n"}, {"role": "assistant", "content": "pub fun getAllSeriesNames(): [String] {\n        return Genies.seriesIDByName.keys\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get series id for name\n"}, {"role": "assistant", "content": "pub fun getSeriesIDByName(name: String): UInt32? {\n        return Genies.seriesIDByName[name]\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A public struct to access GeniesCollection data\n"}, {"role": "assistant", "content": "pub struct GeniesCollectionData {\n        pub let id: UInt32\n        pub let seriesID: UInt32\n        pub let name: String\n        pub let metadata: {String: String}\n        pub let open: Bool\n        pub let editionIDs: [UInt32]\n        pub let editionsActive: UInt32\n\n        // initializer\n        //\n        init (id: UInt32) {\n            let collection = (&Genies.collectionByID[id] as &Genies.GeniesCollection?)!\n            self.id = id\n            self.seriesID = collection.seriesID\n            self.name = collection.name\n            self.metadata = collection.metadata\n            self.open = collection.open\n            self.editionIDs = collection.editionIDs\n            self.editionsActive = collection.editionsActive\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (id: UInt32) {\n            let collection = (&Genies.collectionByID[id] as &Genies.GeniesCollection?)!\n            self.id = id\n            self.seriesID = collection.seriesID\n            self.name = collection.name\n            self.metadata = collection.metadata\n            self.open = collection.open\n            self.editionIDs = collection.editionIDs\n            self.editionsActive = collection.editionsActive\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Genies collection (not to be confused with a NonFungibleToken.Collection) within a series\n"}, {"role": "assistant", "content": "pub resource GeniesCollection {\n        pub let id: UInt32\n        pub let seriesID: UInt32\n        pub let name: String\n        // Contents writable if borrowed!\n        // This is deliberate, as it allows admins to update the data.\n        pub let metadata: {String: String}\n        pub var open: Bool\n        // We manage this list, but need to access it to fill out the struct,\n        // so it is access(contract)\n        access(contract) let editionIDs: [UInt32]\n        pub var editionsActive: UInt32\n\n        // Create and add an Edition to the series.\n        // You can only do so via this function, which updates the relevant fields.\n        //\n        pub fun addEdition(\n            editionName: String,\n            editionMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                self.open == true: \"Cannot add edition to closed collection\"\n            }\n            let edition <- create Genies.Edition(\n                collectionID: self.id,\n                name: editionName,\n                metadata: editionMetadata\n            )\n\n            let editionID = edition.id\n            Genies.editionByID[editionID] <-! edition\n            self.editionIDs.append(editionID)\n            self.editionsActive = self.editionsActive + 1 as UInt32\n\n            return editionID\n        }\n\n        // Close an Edition, and update the relevant fields\n        //\n        pub fun retireEdition(editionID: UInt32) {\n            pre {\n                Genies.editionByID[editionID] != nil: \"editionID doesn't exist\"\n            }\n\n            let edition = (&Genies.editionByID[editionID] as &Edition?)!\n            edition.retire()\n            self.editionsActive = self.editionsActive - 1 as UInt32\n        }\n\n        // Retire all of the Editions, allowing this collection to be closed\n        //\n        pub fun retireAllEditions() {\n            for editionID in self.editionIDs {\n                self.retireEdition(editionID: editionID)\n            }\n        }\n\n        // Close the collection\n        // access(contract) to enforce calling through its parent series\n        //\n        access(contract) fun close() {\n            pre{\n                self.editionsActive == 0:\n                    \"All editions in this collection must be closed before closing it\"\n            }\n\n            self.open = false\n\n            emit CollectionClosed(id: self.id)\n        }\n\n        // initializer\n        //\n        init (seriesID: UInt32, name: String, metadata: {String: String}) {\n            pre {\n                Genies.seriesByID.containsKey(seriesID) != nil: \"seriesID does not exist\"\n            }\n\n            self.id = Genies.nextCollectionID\n            self.seriesID = seriesID\n            self.name = name\n            self.metadata = metadata\n            self.editionIDs = []\n            self.editionsActive = 0 as UInt32\n            self.open = true\n\n            Genies.nextCollectionID = Genies.nextCollectionID + 1 as UInt32\n\n            emit CollectionCreated(id: self.id, seriesID: self.seriesID, name: self.name, metadata: self.metadata)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: We manage this list, but need to access it to fill out the struct,\nso it is access(contract)"}, {"role": "assistant", "content": "access(contract) let editionIDs: [UInt32]"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Create and add an Edition to the series.\nYou can only do so via this function, which updates the relevant fields.\n"}, {"role": "assistant", "content": "pub fun addEdition(\n            editionName: String,\n            editionMetadata: {String: String}\n        ): UInt32 {\n            pre {\n                self.open == true: \"Cannot add edition to closed collection\"\n            }\n            let edition <- create Genies.Edition(\n                collectionID: self.id,\n                name: editionName,\n                metadata: editionMetadata\n            )\n\n            let editionID = edition.id\n            Genies.editionByID[editionID] <-! edition\n            self.editionIDs.append(editionID)\n            self.editionsActive = self.editionsActive + 1 as UInt32\n\n            return editionID\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Close an Edition, and update the relevant fields\n"}, {"role": "assistant", "content": "pub fun retireEdition(editionID: UInt32) {\n            pre {\n                Genies.editionByID[editionID] != nil: \"editionID doesn't exist\"\n            }\n\n            let edition = (&Genies.editionByID[editionID] as &Edition?)!\n            edition.retire()\n            self.editionsActive = self.editionsActive - 1 as UInt32\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire all of the Editions, allowing this collection to be closed\n"}, {"role": "assistant", "content": "pub fun retireAllEditions() {\n            for editionID in self.editionIDs {\n                self.retireEdition(editionID: editionID)\n            }\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Close the collection\naccess(contract) to enforce calling through its parent series\n"}, {"role": "assistant", "content": "access(contract) fun close() {\n            pre{\n                self.editionsActive == 0:\n                    \"All editions in this collection must be closed before closing it\"\n            }\n\n            self.open = false\n\n            emit CollectionClosed(id: self.id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (seriesID: UInt32, name: String, metadata: {String: String}) {\n            pre {\n                Genies.seriesByID.containsKey(seriesID) != nil: \"seriesID does not exist\"\n            }\n\n            self.id = Genies.nextCollectionID\n            self.seriesID = seriesID\n            self.name = name\n            self.metadata = metadata\n            self.editionIDs = []\n            self.editionsActive = 0 as UInt32\n            self.open = true\n\n            Genies.nextCollectionID = Genies.nextCollectionID + 1 as UInt32\n\n            emit CollectionCreated(id: self.id, seriesID: self.seriesID, name: self.name, metadata: self.metadata)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the publicly available data for a GeniesCollection\nNot an NFT Collection!\n"}, {"role": "assistant", "content": "pub fun getGeniesCollectionData(id: UInt32): Genies.GeniesCollectionData {\n        pre {\n            Genies.collectionByID[id] != nil: \"Cannot borrow Genies collection, no such id\"\n        }\n\n        return GeniesCollectionData(id: id)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A public struct to access Edition data\n"}, {"role": "assistant", "content": "pub struct EditionData {\n        pub let id: UInt32\n        pub let collectionID: UInt32\n        pub let name: String\n        pub let metadata: {String: String}\n        pub let open: Bool\n        pub let numMinted: UInt32\n\n        // initializer\n        //\n        init (id: UInt32) {\n            let edition = (&Genies.editionByID[id] as &Genies.Edition?)!\n            self.id = id\n            self.collectionID = edition.collectionID\n            self.name = edition.name\n            self.metadata = edition.metadata\n            self.open = edition.open\n            self.numMinted = edition.numMinted\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (id: UInt32) {\n            let edition = (&Genies.editionByID[id] as &Genies.Edition?)!\n            self.id = id\n            self.collectionID = edition.collectionID\n            self.name = edition.name\n            self.metadata = edition.metadata\n            self.open = edition.open\n            self.numMinted = edition.numMinted\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: An Edition (NFT type) within a Genies collection\n"}, {"role": "assistant", "content": "pub resource Edition {\n        pub let id: UInt32\n        pub let collectionID: UInt32\n        pub let name: String\n        // Contents writable if borrowed!\n        // This is deliberate, as it allows admins to update the data.\n        pub let metadata: {String: String}\n        pub var numMinted: UInt32\n        pub var open: Bool\n\n        // Retire this edition so that no more Genies NFTs can be minted in it\n        // access(contract) to enforce calling through its parent GeniesCollection\n        //\n        access(contract) fun retire() {\n            pre {\n                self.open == true: \"already retired\"\n            }\n\n            self.open = false\n\n            emit EditionRetired(id: self.id)\n        }\n\n        // Mint a Genies NFT in this edition, with the given minting mintingDate.\n        // Note that this will panic if this edition is retired.\n        //\n        pub fun mint(): @Genies.NFT {\n            pre {\n                self.open: \"edition closed, cannot mint\"\n            }\n\n            // Keep a running total (you'll notice we used this as the serial number\n            // and pre-increment it so that serial numbers start at 1 ).\n            self.numMinted = self.numMinted + 1 as UInt32\n\n            // Create the Genies NFT, filled out with our information\n            let geniesNFT <- create NFT(\n                id: Genies.totalSupply,\n                editionID: self.id,\n                serialNumber: self.numMinted\n            )\n            Genies.totalSupply = Genies.totalSupply + 1\n\n            return <- geniesNFT\n        }\n\n        // initializer\n        //\n        init (\n            collectionID: UInt32,\n            name: String,\n            metadata: {String: String}\n        ) {\n            pre {\n                Genies.collectionByID.containsKey(collectionID): \"collectionID does not exist\"\n            }\n\n            self.id = Genies.nextEditionID\n            self.collectionID = collectionID\n            self.name = name\n            self.metadata = metadata\n            self.numMinted = 0 as UInt32\n            self.open = true\n\n            Genies.nextEditionID = Genies.nextEditionID + 1 as UInt32\n\n            emit EditionCreated(\n                id: self.id,\n                collectionID: self.collectionID,\n                name: self.name,\n                metadata: self.metadata\n            )\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Retire this edition so that no more Genies NFTs can be minted in it\naccess(contract) to enforce calling through its parent GeniesCollection\n"}, {"role": "assistant", "content": "access(contract) fun retire() {\n            pre {\n                self.open == true: \"already retired\"\n            }\n\n            self.open = false\n\n            emit EditionRetired(id: self.id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Mint a Genies NFT in this edition, with the given minting mintingDate.\nNote that this will panic if this edition is retired.\n"}, {"role": "assistant", "content": "pub fun mint(): @Genies.NFT {\n            pre {\n                self.open: \"edition closed, cannot mint\"\n            }\n\n            // Keep a running total (you'll notice we used this as the serial number\n            // and pre-increment it so that serial numbers start at 1 ).\n            self.numMinted = self.numMinted + 1 as UInt32\n\n            // Create the Genies NFT, filled out with our information\n            let geniesNFT <- create NFT(\n                id: Genies.totalSupply,\n                editionID: self.id,\n                serialNumber: self.numMinted\n            )\n            Genies.totalSupply = Genies.totalSupply + 1\n\n            return <- geniesNFT\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: initializer\n"}, {"role": "assistant", "content": "init (\n            collectionID: UInt32,\n            name: String,\n            metadata: {String: String}\n        ) {\n            pre {\n                Genies.collectionByID.containsKey(collectionID): \"collectionID does not exist\"\n            }\n\n            self.id = Genies.nextEditionID\n            self.collectionID = collectionID\n            self.name = name\n            self.metadata = metadata\n            self.numMinted = 0 as UInt32\n            self.open = true\n\n            Genies.nextEditionID = Genies.nextEditionID + 1 as UInt32\n\n            emit EditionCreated(\n                id: self.id,\n                collectionID: self.collectionID,\n                name: self.name,\n                metadata: self.metadata\n            )\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Get the publicly available data for an Edition\n"}, {"role": "assistant", "content": "pub fun getEditionData(id: UInt32): EditionData {\n        pre {\n            Genies.editionByID[id] != nil: \"Cannot borrow edition, no such id\"\n        }\n\n        let edition = (&Genies.editionByID[id] as &Genies.Edition?)!\n\n        return EditionData(id: id)\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A Genies NFT\n"}, {"role": "assistant", "content": "pub resource NFT: NonFungibleToken.INFT {\n        pub let id: UInt64\n        pub let editionID: UInt32\n        pub let serialNumber: UInt32\n        pub let mintingDate: UFix64\n\n        // Destructor\n        //\n        destroy() {\n            emit NFTBurned(id: self.id)\n        }\n\n        // NFT initializer\n        //\n        init(\n            id: UInt64,\n            editionID: UInt32,\n            serialNumber: UInt32\n        ) {\n            pre {\n                Genies.editionByID[editionID] != nil: \"no such editionID\"\n                (&Genies.editionByID[editionID] as &Edition?)!.open:\n                    \"editionID is retired\"\n            }\n\n            self.id = id\n            self.editionID = editionID\n            self.serialNumber = serialNumber\n            self.mintingDate = getCurrentBlock().timestamp\n\n            emit NFTMinted(id: self.id, editionID: self.editionID, serialNumber: self.serialNumber)\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: Destructor\n"}, {"role": "assistant", "content": "destroy() {\n            emit NFTBurned(id: self.id)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: NFT initializer\n"}, {"role": "assistant", "content": "init(\n            id: UInt64,\n            editionID: UInt32,\n            serialNumber: UInt32\n        ) {\n            pre {\n                Genies.editionByID[editionID] != nil: \"no such editionID\"\n                (&Genies.editionByID[editionID] as &Edition?)!.open:\n                    \"editionID is retired\"\n            }\n\n            self.id = id\n            self.editionID = editionID\n            self.serialNumber = serialNumber\n            self.mintingDate = getCurrentBlock().timestamp\n\n            emit NFTMinted(id: self.id, editionID: self.editionID, serialNumber: self.serialNumber)\n        }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: A public collection interface that allows Genies NFTs to be borrowed\n"}, {"role": "assistant", "content": "pub resource interface GeniesNFTCollectionPublic {\n        pub fun deposit(token: @NonFungibleToken.NFT)\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)\n        pub fun getIDs(): [UInt64]\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        pub fun borrowGeniesNFT(id: UInt64): &Genies.NFT? {\n            // If the result isn't nil, the id of the returned reference\n            // should be the same as the argument to the function\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow Genies NFT reference: The ID of the returned reference is incorrect\"\n            }\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: An NFT Collection (not to be confused with a GeniesCollection)\n"}, {"role": "assistant", "content": "pub resource Collection:\n        NonFungibleToken.Provider,\n        NonFungibleToken.Receiver,\n        NonFungibleToken.CollectionPublic,\n        GeniesNFTCollectionPublic\n    {\n        // dictionary of NFT conforming tokens\n        // NFT is a resource type with an UInt64 ID field\n        //\n        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n\n        // withdraw removes an NFT from the collection and moves it to the caller\n        //\n        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }\n\n        // deposit takes a NFT and adds it to the collections dictionary\n        // and adds the ID to the id array\n        //\n        pub fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @Genies.NFT\n            let id: UInt64 = token.id\n\n            // add the new token to the dictionary which removes the old one\n            let oldToken <- self.ownedNFTs[id] <- token\n\n            emit Deposit(id: id, to: self.owner?.address)\n\n            destroy oldToken\n        }\n\n        // batchDeposit takes a Collection object as an argument\n        // and deposits each contained NFT into this Collection\n        //\n        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {\n            // Get an array of the IDs to be deposited\n            let keys = tokens.getIDs()\n\n            // Iterate through the keys in the collection and deposit each one\n            for key in keys {\n                self.deposit(token: <-tokens.withdraw(withdrawID: key))\n            }\n\n            // Destroy the empty Collection\n            destroy tokens\n        }\n\n        // getIDs returns an array of the IDs that are in the collection\n        //\n        pub fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n\n        // borrowNFT gets a reference to an NFT in the collection\n        //\n        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n\n        // borrowGeniesNFT gets a reference to an NFT in the collection\n        //\n        pub fun borrowGeniesNFT(id: UInt64): &Genies.NFT? {\n            return (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)! as! &Genies.NFT\n        }\n\n        // Collection destructor\n        //\n        destroy() {\n            destroy self.ownedNFTs\n        }\n\n        // Collection initializer\n        //\n        init() {\n            self.ownedNFTs <- {}\n        }\n    }"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: dictionary of NFT conforming tokens\nNFT is a resource type with an UInt64 ID field\n"}, {"role": "assistant", "content": "pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}"}]}
{"messages": [{"role": "system", "content": "this is a Cadence coder"}, {"role": "user", "content": "the input is: withdraw removes an NFT from the collection and moves it to the caller\n"}, {"role": "assistant", "content": "pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n\n            emit Withdraw(id: token.id, from: self.owner?.address)\n\n            return <-token\n        }"}]}
